[{"id":"e2da92db1d53886d7a5862c5351a8470","title":"专升本英语","content":"专升本英语名词可数名词个体名词（可数）：表示人或事物的个体名称\n\ncity\npanda\nchair\nhospital\nnurse\ncup\ncat\n\n集体名词（可数）：表示一群人或一些事物的总称\n\npublic\npeople\nclass\nfamily\npolice\n\n不可数名词物资名词（不可数）：表示无法分为个体的物质或材料的名词\n\nrice\nsnow\nsteel\ncotton\ncorn\nair\nadvice\nequipment\nhomework\nfurniture\nhair\ninformation\ntraffic\nknowledge\nmoney\nprogress\nwater\nnews\ngas\nmeat\n\n抽象名词（不可数）：表示行为、状态、品质、感情等抽象概念的名词\n\ncourage\ndetermination\nsatisfaction\nhappiness\nsuccess\nlove\n\n专有名词表示人名、地名、国名：\n\nLondon\nTom\nthe Great Wall\nAsia\n\n表示书名、电影名、各种标语：\n\nSpider Man\n\n表示机构、组织、团体：\n\nUNESCO\nBeijing University\n\n表示月份、星期、节日：\n\nMonday\nNational day\n\n复数前提是可数名词，才有单复数形式。\n元音字母的变化\ngoose - geese\nmouse - mice\ntooth - teeth\nman - men\nwoman - women\n\n单复同型\nfish\ndeer\nsheep\nmeans\npolice\ncattle\npoultry\n\n只有复数形式\ntrousers\nclothes\nglasses\narms\nremains\nsavings\nearnings\ngoods\n\n\n\n\n\n\n\n\n\n\n一般在名词结尾加-s 在清辅音后读/s/、在浊辅音盒元音后读/z/：\n\nexercise - exercises\ndesk - desks\n\n以s、x、ch、sh结尾的名词加-es，读/i/：\n\nwatch - watches\nbox📦 - boxes\n\n以辅音字母 加  y 结尾的名词， 去-y改-i加-es：\n\nfactory - factories\nlady - ladies\n\n以f或者fe结尾的词，一般吧f或fe改v加-es：\n\nwolf🐺 - wolves\nknife🔪 - knives\n\n以o结尾的可数名词，有生命点加-es、无生命的加-s （黑人英雄爱吃西红柿和土豆🥔）：\n\npotato🥔 - potatoes\npiano🎹 - pianos\n\n复数不规则变化\nmedium - media\nphenomenon - phenomena\ncriterion - criteria\n\n特殊情况\nchild - children\n\n复合名词两个或者两个以上的词连接在一起构成的名词：\n\npasser-by\nbrother-in-law\n\n复合名词的复数通常复数加在其所包含的主体词上\n\nson-in-law - sons-in-law\npasser-by - passers-by\neditor-in-chief - editors-in-chief\nshoe-maker - shoe-makers\ntooth-brush - tooth - brushes\n\n复合名词中没有主体名词时，在最后一个名词后加-s\n\ngrown-up - grown-ups\ngo-between - go-betweens\n\n数词加名词做定语时，名词要用单数\n\na two-thousand-word letter\na ten-mile walk\na hundred-year plan\n\n以man和woman构成的合成词变复数是，将man和woman变复数\n\nfireman - firemen\nchairwoman - chairwomen\n\n以man和woman修饰别的主体词，这两个词要连同主体词一起进行变化\n\nMan-servant - men-servants\nwoman doctor - women doctors\n\n物质名词表示不具备确定形状和大小的个体的物质：\n\nwater\nsnow\nsunshine\nhair\n\n抽象名词表示动作，状态，品质或其他抽象概念：\n\nhope\nhealth\nlove\nweather\nlabor\nfriendship\n\n","slug":"升本/英语/专升本英语","date":"2023-09-20T00:30:00.000Z","categories_index":"升本","tags_index":"英语,笔记,升本","author_index":"Honman"},{"id":"07b752aac11b463f2c36e48384f5d22f","title":"高等数学","content":"高等数学第一章函数函数概念\n定义： 自变量  、因变量  ， 通过一个对应的法则与一一对应，即  。\n考点：\n定义域：的取值范围\n对应法则：对的处理方式（、、）\n\n\n\n具体函数定义域具体函数：知道函数的具体表达式的，如 、、\n常见的具体函数定义域：\n\n 重点\n 重点\n  重点\n 重点\n \n \n、 \n、 重点\n\n\n\n\n\n\n\n\n\n\neg: 求  的定义域。\n令  求得定义域 \n\n求根公式： \n十字相乘法\n\n抽象函数定义域题目：考虑抽象函数 ，其定义为 。求函数  的定义域。\n解法：要求函数  的定义域，我们需要确定能够使得函数有意义的输入值范围。\n\n我们注意到函数中存在一个分母 。为了避免分母为零，我们需要确保 。解这个方程可以得到 。\n\n我们知道平方根函数的定义域为非负实数集合，即  在实数范围内当且仅当 。因此，我们需要确保 。\n\n将不等式  解出来，我们可以得到 ，即 。由于分母为正数时，不等式符号不变，所以我们无需考虑分母的正负性。\n\n\n综上所述，函数  的定义域为 ，即除去  的所有实数。\n函数表达式根据函数对应法则，求出函数表达式。\n\n直接代入法 已知： 求或者已知求 \n\n换元法 已知：，求 \n\n\n\n\n\n\n\n\n\n求（） \n要解决方程 ，并求解函数 ，请按照以下步骤进行：\n\n假设 ，即将  替换为 ，得到 。\n将方程中的  替换为具体的给定值。\n解方程 ，找到函数  的解。这可能需要使用适当的数学方法和技巧，具体取决于函数  的形式和给定的值。\n如果找到了函数  的解，那么解就是  的表达式。将  替换回 ，即可得到  的表达式。\n\n\n配凑法\n\n\n\n\n\n\n\n\n\n一般结合三角函数公式转换来使用。\n以下是全部的三角函数转换公式和平方公式：\n\n三角函数转换公式：\n正弦函数转换公式：\n\n\n\n\n\n\n\n\n余弦函数转换公式：\n\n\n\n\n\n\n\n\n正切函数转换公式：\n\n\n\n\n\n\n\n\n平方公式：\n一元二次方程求根公式：\n\n\n\n平方差公式：\n\n\n\n\n\n\n\n以下是与三角函数相关的一些常见公式：\n\n基本关系：\n\n\n\n\n\n\n\n\n三角函数的周期性：\n\n\n\n\n\n\n三角函数的和差公式：\n\n\n\n\n\n\n三角函数的倍角公式：\n\n\n\n\n\n\n三角函数的半角公式：\n\n\n\n\n\n\n三角函数的积化和差公式：\n\n\n\n\n\n\n三角函数降次公式：\n\n余弦的降次公式：\n\n正弦的降次公式：\n\n正切的降次公式：\n\n\n\n\n\n\n反函数概念反函数是指对于一个函数，如果它的某个输入值通过该函数可以得到唯一的输出值，那么反函数就是将这个输出值作为输入，通过逆向操作得到原始的输入值。简而言之，反函数是原函数的逆过程。\n概念上来说，如果函数  的定义域为 ，值域为 ，那么函数  的反函数  的定义域为 ，值域为 。反函数的作用是将原函数的输出值映射回原始的输入值。\n从定义上来说，对于函数  和它的反函数 ，下面两个条件必须满足：\n\n对于定义域  内的任意 ，有 ，即通过函数  得到的输出值再通过反函数  得到的结果是原始的输入值。\n对于值域  内的任意 ，有 ，即通过反函数  得到的输出值再通过函数  得到的结果是原始的输入值。\n\n反函数的存在与可逆性有关，即函数  必须是一对一的（即不会出现多个不同的输入对应同一个输出的情况）才能存在反函数。\n求解一个函数的反函数的过程可以分为以下几个步骤：\n\n假设函数  的反函数为 ，我们需要找到  的表达式或规律。\n\n将  中的自变量  和因变量  互换，得到等式 。\n\n将等式中的  替换为 ，将  替换为 ，得到等式 。\n\n解上述等式，将  表达为  的函数形式。这一步可能需要使用代数运算、方程求解技巧或其他数学方法。\n\n验证反函数的定义域和值域是否与原函数相对应。确保反函数满足反函数的定义。\n\n\n常见的基本初等函数基本初等函数的例子：\n\n幂函数（Power Function）：，，\n指数函数（Exponential Function）：， (其中  是自然对数的底数，约等于2.71828)\n对数函数（Logarithmic Function）：， (其中  表示以  为底的对数)\n三角函数（Trigonometric Function）：，，\n反三角函数（Inverse Trigonometric Function）：，，\n双曲函数（Hyperbolic Function）：，\n反双曲函数（Inverse Hyperbolic Function）：，\n绝对值函数（Absolute Value Function）：，\n常数函数（Constant Function）：，\n线性函数（Linear Function）：，\n\n以下是每个基本初等函数的一些常见特点：\n\n幂函数（Power Function）：\n\n：开口向上的抛物线，对称于轴，顶点在原点。\n：开口向上的图像，具有一个拐点，对称于原点。\n：非负的开口向上的图像，随着的增加逐渐变陡。\n\n\n指数函数（Exponential Function）：\n\n：逐渐增加的曲线，以指数形式增长。\n：逐渐增加的曲线，以自然对数的底数为底增长。\n\n\n对数函数（Logarithmic Function）：\n\n：定义域为正实数，值域为实数，曲线逐渐增长但增长速度减慢。\n：定义域为正实数，值域为实数，曲线逐渐增长但增长速度减慢。\n\n对数函数在四则运算中的规则如下：\n\n对数的加法：\n对数的减法：\n对数的乘法：\n对数的除法： \n \n\n\n\n三角函数（Trigonometric Function）：\n\n：周期性的正弦曲线，振幅为1，周期为。\n：周期性的余弦曲线，振幅为1，周期为。\n：周期性的正切曲线，存在无穷多个渐近线。\n\n常见角度的三角函数值的表格：\n\n\n\n角度（度）\n角度（弧度）\n正弦值（sin）\n余弦值（cos）\n正切值（tan）\n余切值（cot）\n正割值（sec）\n余割值（csc）\n\n\n\n0°\n0\n0\n1\n0\n无定义\n1\n无定义\n\n\n30°\nπ/6\n1/2\n√3/2\n√3/3\n√3\n2/√3\n2\n\n\n45°\nπ/4\n√2/2\n√2/2\n1\n1\n√2\n√2\n\n\n60°\nπ/3\n√3/2\n1/2\n√3\n√3/3\n2\n2/√3\n\n\n90°\nπ/2\n1\n0\n无穷大\n0\n无穷大\n1\n\n\n\n\n复合函数及其分解函数内再套一个函数就叫复合函数。\n分解：从外向里，层层递进，分解到含x的基本初等函数。\neg=&gt; 、、、\n函数的奇偶性函数的四大性质是定义域、值域、单调性和奇偶性。\n\n定义域（Domain）：函数的定义域是指函数在自变量上的取值范围，即使函数有意义的输入值的集合。在定义域内，函数有明确定义的值。例如，对于函数 ，其定义域表示为 。\n\n值域（Range）：函数的值域是指函数在因变量上的取值范围，即函数输出值的集合。值域可以是实数集、整数集、非负数集等，具体取决于函数的性质和定义域。例如，对于函数 ，其值域表示为 。\n\n单调性（Monotonicity）：函数的单调性描述了函数在定义域内的增减趋势。一个函数可以是递增的、递减的或者保持常数。如果对于定义域内的任意两个数  和 ，当  时，有 ，则函数是递增的**；**如果 ，则函数是递减的。\n\n周期性：经过一段时间，重新出现。例如（）\n\n奇偶性（Parity）：函数的奇偶性描述了函数的对称性质。一个函数可以是奇函数、偶函数或者既不是奇函数也不是偶函数。如果对于定义域内的任意数 ，有 ，则函数是奇函数；如果 ，则函数是偶函数。\n奇函数和偶函数的四则运算规则：\n\n奇函数的性质：\n奇函数与奇函数的和（差）仍然是奇函数。即，如果  和  都是奇函数，则  也是奇函数。\n奇函数与奇函数的乘积是偶函数。即，如果  和  都是奇函数，则  是偶函数。\n奇函数关于原点对称。即，对于奇函数 ，有 。\n\n\n偶函数的性质：\n偶函数与偶函数的和（差）仍然是偶函数。即，如果  和  都是偶函数，则  也是偶函数。\n偶函数与偶函数的乘积是偶函数。即，如果  和 g(x)都是偶函数，则 是偶函数。\n偶函数关于  轴对称。即，对于偶函数 ，有 。\n\n\n奇偶函数：\n奇函数与偶函数的和（差）是非奇非偶函数。即，如果  和  分别是奇函数、偶函数，则  是非奇非偶函数。\n奇函数与偶函数的乘积是奇函数。即，如果  和  分别是奇函数、偶函数，则  是奇函数。\n\n\n复合函数的奇偶性（全奇则奇，遇偶则偶。）：\n奇函数（奇函数）= 奇函数\n奇函数（偶函数）= 偶函数\n偶函数（奇函数）= 偶函数\n 是偶函数\n 是奇函数\n\n\n\n\n\n函数的有界性在数学中，一个函数的有界性描述了函数在定义域内是否存在上界和下界。一个函数被称为有界函数，如果存在两个常数  和 ，使得对于定义域内的所有 ，都有 。\n具体地说，一个函数可以是上界有界、下界有界或同时具有上界和下界。下面是对这些情况的解释：\n\n上界有界函数：如果存在一个常数 ，使得对于定义域内的所有 ，都有 ，那么函数  是上界有界的。\n下界有界函数：如果存在一个常数 ，使得对于定义域内的所有 ，都有 ，那么函数  是下界有界的。\n上界和下界有界函数：如果存在两个常数  和 ，使得对于定义域内的所有 ，都有 ，那么函数  是上界和下界有界的。\n\n考点：    *  0 * 有界 = 0    *  遇 、、 要考虑有界\n极限极限概念描述某个东西，在一定条件下的趋势。\n在数学中，极限是描述函数或数列在接近某个特定值时的行为的概念。极限可以用来研究函数的趋势、收敛性和连续性等性质。\n对于函数 ，当自变量  靠近某个特定值  时，如果函数的取值  逐渐接近一个确定的值 ，则称函数  在  趋近于  时的极限为 ，记作：\n\n这个定义可以用以下方式解释：无论多么接近 ，只要  足够靠近 ，函数  的取值都会无限接近 。\n类似地，对于数列 ，当序号  趋近于无穷大时，如果数列的项  逐渐接近一个确定的值 ，则称数列  的极限为 ，记作：\n\n极限的计算和性质可以通过一些规则和定理来确定。常见的极限规则包括四则运算法则、复合函数的极限法则、极限的唯一性和极限的保序性等。\n极限的概念在微积分、实分析和数学分析等领域中具有重要的作用，它为研究函数和数列的性质提供了基础。\n极限及其四则运算\n函数极限： ,  为确定的数。\n数列极限：  ， 为确定的数。极限存在，任意子列也收敛。\n左右极限/单侧极限：\n左极限： ，当  从左侧无限接近  时，函数  的取值逐渐接近 。\n右极限： ，当  从右侧无限接近  时，函数  的取值逐渐接近 。\n\n\n极限存在：左右极限存在且相等。一般填空题考。\n 在某个点  处的极限值，与 在该点有无定义/ 无关。\n\n\n\n\n\n\n\n\n\n\n函数极限计算 &lt;=&gt; 四则运算（前提条件：极限存在）\n下面是一些常见的四则运算法则与函数极限的关系：\n\n两个函数的和的极限等于各自函数的极限之和：如果  且 ，那么 。\n两个函数的差的极限等于各自函数的极限之差：如果  且 ，那么 。\n两个函数的乘积的极限等于各自函数的极限之积：  如果  且 ，那么 。\n两个函数的商的极限等于各自函数的极限之商（前提是除数函数的极限不为零）：如果  且 （其中 ），那么 。\n\n函数极限计算小知识\n习惯：\n先定型 =&gt; 将 x -&gt; x0 中的 x0 代入f(x)中。\n定法：根据类型定方法。\n\n\n在定型的时候，可将非零的常数部分（乘、除关系中）先计算出来。（非零因子先代入）\n 、\n\n无穷比无穷极限计算\n定义： 的极限。\n解法：抓大头。\n题型：\n幂函数抓大头\n指数函数\n通过抓大头求参数\n\n\n\n\n\n\n\n\n\n\n\n\n考虑以下极限：。\n我们可以使用抓大头的方法来计算这个极限。抓大头的思想是，在分子和分母中选择具有最高次幂的项进行计算。\n在这个例子中，最高次幂的项是，因此我们可以将分子和分母都除以，得到：\n\n简化后得到：\n\n现在我们可以取趋近于无穷大，可以发现和都趋近于零。因此，我们可以将它们视为等价无穷小量，得到：\n\n所以，根据抓大头的方法，。\n0:0函数极限计算\n\n\n\n\n\n\n\n\n\n定义：分子-&gt;0，分母-&gt;0\n解法：利用等价无穷小量求解。\n等价来源：x -&gt; 0   x~sinx\n\n常用的等价公式\n\n当x -&gt; 0时\n第一组\n\n 、 \n 、 \n、\n\n第二组\n\n\n\n第三组\n\n 子  \n  父\n\n第四组\n\n\n\n\n\n补充\n\n\n\n\n以上在乘除关系中使用，加减运算慎用！！！趋于0的时候使用\n\n\n0 x 有界 = 0\n\n\n\n\n\n\n\n\n遇到 、、 优先考虑 0 * 有界 = 0\n洛必达法则\n\n\n\n\n\n\n\n\n0:0 、无穷：无穷型\n\n分子、分母各自同时求导。\n洛必达法则，一般会配合等价使用。\n万事不对洛必达！\n\n洛必达法则是一种用于求解极限的重要工具，特别适用于形式为  或  的不定型极限。该法则由法国数学家Guillaume de l’Hôpital在17世纪提出。\n不定型极限不定型极限是指在求解极限时，得到的结果无法确定的情况。常见的不定型形式包括 、、、、、 等。\n洛必达法则的表述洛必达法则可以表述为以下形式：\n如果函数  和  在某一点  的某个去心邻域内可导，且满足以下条件：\n\n 或 \n 或 \n 存在（其中  和  分别表示  和  的导数）\n\n则有：\n\n洛必达法则的步骤使用洛必达法则求解极限的一般步骤如下：\n\n确定极限形式是否为不定型，即  或 。\n对于给定的不定型极限，计算  和  并求导得到  和 。\n计算 ，如果该极限存在，则它就是原始极限的值。\n\n示例下面是一个使用洛必达法则求解极限的示例：\n问题： 求解 。\n解答：\n\n极限形式为 ，是不定型极限。\n令 ，，则 ，。\n计算 。\n因此，。\n\n0 x 无穷型极限计算当我们遇到形式为  的极限时，我们不能直接得到确定的结果，因为乘积的结果取决于具体的情况。在这种情况下，我们需要进行进一步的分析和转化。\n极限形式形式为  的极限是一种不定型极限，它表示一个数乘以无穷大的结果。这种极限形式可能出现在函数的极限计算中，需要特殊的处理方法。\n转化方法为了计算形式为  的极限，我们可以尝试将其转化为其他形式的极限，以便更容易求解。常见的转化方法包括使用代数运算、换元法或洛必达法则。\n以下是几种常见的转化方法：\n方法一：代数运算如果在极限计算中，我们可以通过代数运算将  转化为更简单的形式，那么我们可以尝试使用这种方法。\n例如，如果我们有 ，其中 ，，我们可以尝试将其转化为  或 ，然后继续计算。\n方法二：换元法另一种常见的方法是使用换元法将  转化为其他形式的极限。\n例如，如果我们有 ，其中 ，，我们可以尝试进行换元，将  和  表示为新的函数，然后计算新函数的极限。\n方法三：洛必达法则如果我们遇到形式为  的极限，并且无法通过代数运算或换元法转化为其他形式，我们可以尝试使用洛必达法则。\n洛必达法则可以帮助我们处理形式为  或  的不定型极限。我们可以将  转化为  或  的形式，然后应用洛必达法则求解。\n示例下面是一个使用转化方法计算  极限的示例：\n问题： 求解 。\n解答：\n\n极限形式为 。\n将  转化为  的形式。\n应用洛必达法则，计算 。\n因此，。\n\n无穷 - 无穷极限计算U^v型极限计算连续函数间断点及其类型无穷小量比较利用极限求曲线渐近线第二章","slug":"升本/高等数学/高等数学","date":"2023-09-15T00:30:00.000Z","categories_index":"升本","tags_index":"笔记,升本,数学","author_index":"Honman"},{"id":"19e12028a5359d260a4ec9c616f8a947","title":"JavaScript-进阶笔记","content":"JavaScript进阶作用域\n\n\n\n\n\n\n\n\n了解作用域对程序执行的影响及作用域链的查找机制，使用闭包函数创建隔离作用域避免全局变量污染。\n作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为全局作用域和局部作用域。\n局部作用域局部作用域分为函数作用域和块作用域。\n函数作用域在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。\njs\n    // 声明 counter 函数\n    function counter(x, y) &#123;\n        // 函数内部声明的变量\n        const s = x + y\n        console.log(s) // 18\n    &#125;\n    // 设用 counter 函数\n    counter(10, 8)\n    // 访问变量 s\n    console.log(s)// 报错\n总结：\n\n函数内部声明的变量，在函数外部无法被访问\n函数的参数也是函数内部的局部变量\n不同函数内部声明的变量无法互相访问\n函数执行完毕后，函数内部的变量实际被清空了\n\n块作用域在 JavaScript 中使用 &#123;&#125; 包裹的代码称为代码块，代码块内部声明的变量外部将【有可能】无法被访问。\njs\n    &#123;\n        // age 只能在该代码块中被访问\n        let age = 18;\n        console.log(age); // 正常\n    &#125;\n\n    // 超出了 age 的作用域\n    console.log(age) // 报错\n\n    let flag = true;\n    if (flag) &#123;\n        // str 只能在该代码块中被访问\n        let str = &#39;hello world!&#39;\n        console.log(str); // 正常\n    &#125;\n\n    // 超出了 age 的作用域\n    console.log(str); // 报错\n\n    for (let t = 1; t &lt;= 6; t++) &#123;\n        // t 只能在该代码块中被访问\n        console.log(t); // 正常\n    &#125;\n\n    // 超出了 t 的作用域\n    console.log(t); // 报错\nJavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。\njs\n    // 必须要有值\n    const version = &#39;1.0.0&#39;;\n\n    // 不能重新赋值\n    // version = &#39;1.0.1&#39;;\n\n    // 常量值为对象类型\n    const user = &#123;\n        name: &#39;小明&#39;,\n        age: 18\n    &#125;\n\n    // 不能重新赋值\n    user = &#123;&#125;;\n\n    // 属性和方法允许被修改\n    user.name = &#39;小小明&#39;;\n    user.gender = &#39;男&#39;;\n总结：\n\nlet 声明的变量会产生块作用域，var 不会产生块作用域\nconst 声明的常量也会产生块作用域\n不同代码块之间的变量无法互相访问\n推荐使用 let 或 const\n\n注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。\n全局作用域&lt;script&gt; 标签和 .js 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。\njs\n    // 此处是全局\n    function sayHi() &#123;\n        // 此处为局部\n    &#125;\n  // 此处为全局\n全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：\njs\n    // 全局变量 name\n    const name = &#39;小明&#39;\n\n    // 函数作用域中访问全局\n    function sayHi() &#123;\n        // 此处为局部\n        console.log(&#39;你好&#39; + name)\n    &#125;\n\n    // 全局变量 flag 和 x\n    const flag = true\n    let x = 10\n\n    // 块作用域中访问全局\n    if (flag) &#123;\n        let y = 5\n        console.log(x + y) // x 是全局的\n    &#125;\n总结：\n\n为 window 对象动态添加的属性默认也是全局的，不推荐！\n函数中未使用任何关键字声明的变量为全局变量，不推荐！！！\n尽可能少的声明全局变量，防止全局变量被污染\n\nJavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。\n作用域链在解释什么是作用域链前先来看一段代码：\njs\n  // 全局作用域\n  let a = 1\n  let b = 2\n  // 局部作用域\n  function f() &#123;\n    let c\n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n    &#125;\n  &#125;\n函数内部允许创建新的函数，f 函数内部创建的新函数 g，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。\n如下图所示，父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。\n作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域，如下代码所示：\njs\n  // 全局作用域\n  let a = 1\n  let b = 2\n\n  // 局部作用域\n  function f() &#123;\n    let c\n    // let a = 10;\n    console.log(a) // 1 或 10\n    console.log(d) // 报错\n    \n    // 局部作用域\n    function g() &#123;\n      let d = &#39;yo&#39;\n      // let b = 20;\n      console.log(b) // 2 或 20\n    &#125;\n    \n    // 调用 g 函数\n    g()\n  &#125;\n\n  console.log(c) // 报错\n  console.log(d) // 报错\n  \n  f();\n总结：\n\n嵌套关系的作用域串联起来形成了作用域链\n相同作用域链中按着从小到大的规则查找变量\n子作用域能够访问父作用域，父级作用域无法访问子级作用域\n\n闭包闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数，如下代码所示：\njs\n\n    // 1. 闭包 : 内层函数 + 外层函数变量\n    // function outer() &#123;\n    //   const a = 1\n    //   function f() &#123;\n    //     console.log(a)\n    //   &#125;\n    //   f()\n    // &#125;\n    // outer()\n\n    // 2. 闭包的应用： 实现数据的私有。统计函数的调用次数\n    // let count = 1\n    // function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n\n    // 3. 闭包的写法  统计函数的调用次数\n    function outer() &#123;\n      let count = 1\n      function fn() &#123;\n        count++\n        console.log(`函数被调用$&#123;count&#125;次`)\n      &#125;\n      return fn\n    &#125;\n    const re = outer()\n    // const re = function fn() &#123;\n    //   count++\n    //   console.log(`函数被调用$&#123;count&#125;次`)\n    // &#125;\n    re()\n    re()\n    // const fn = function() &#123; &#125;  函数表达式\n    // 4. 闭包存在的问题： 可能会造成内存泄漏\n\n总结：\n1.怎么理解闭包？\n\n闭包 &#x3D; 内层函数 + 外层函数的变量\n\n2.闭包的作用？\n\n封闭数据，实现数据私有，外部也可以访问函数内部的变量\n闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来\n\n3.闭包可能引起的问题？\n\n内存泄漏\n\n变量提升变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问，\njs\n  // 访问变量 str\n  console.log(str + &#39;world!&#39;);\n\n  // 声明变量 str\n  var str = &#39;hello &#39;;\n总结：\n\n变量在未声明即被访问时会报语法错误\n变量在声明之前即被访问，变量的值为 undefined\nlet 声明的变量不存在变量提升，推荐使用 let\n变量提升出现在相同作用域当中\n实际开发中推荐先声明再访问变量\n\n注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 let 可以轻松规避变量的提升，因此在此不做过多的探讨，有兴趣可查阅资料。\n函数\n\n\n\n\n\n\n\n\n知道函数参数默认值、动态参数、剩余参数的使用细节，提升函数应用的灵活度，知道箭头函数的语法及与普通函数的差异。\n函数提升函数提升与变量提升比较类似，是指函数在声明之前即可被调用。\njs\n  // 调用函数\n  foo()\n  // 声明函数\n  function foo() &#123;\n    console.log(&#39;声明之前即被调用...&#39;)\n  &#125;\n\n  // 不存在提升现象\n  bar()  // 错误\n  var bar = function () &#123;\n    console.log(&#39;函数表达式不存在提升现象...&#39;)\n  &#125;\n总结：\n\n函数提升能够使函数的声明调用更灵活\n函数表达式不存在提升的现象\n函数提升出现在相同作用域当中\n\n函数参数函数参数的使用细节，能够提升函数应用的灵活度。\n默认值js\n  // 设置参数默认值\n  function sayHi(name=&quot;小明&quot;, age=18) &#123;\n    document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;岁了。&lt;/p&gt;`);\n  &#125;\n  // 调用函数\n  sayHi();\n  sayHi(&#39;小红&#39;);\n  sayHi(&#39;小刚&#39;, 21);\n总结：\n\n声明函数时为形参赋值即为参数的默认值\n如果参数未自定义默认值时，参数的默认值为 undefined\n调用函数时没有传入对应实参时，参数的默认值被当做实参传入\n\n动态参数arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参。\njs\n  // 求生函数，计算所有参数的和\n  function sum() &#123;\n    // console.log(arguments)\n    let s = 0\n    for(let i = 0; i &lt; arguments.length; i++) &#123;\n      s += arguments[i]\n    &#125;\n    console.log(s)\n  &#125;\n  // 调用求和函数\n  sum(5, 10)// 两个参数\n  sum(1, 2, 4) // 两个参数\n总结：\n\narguments 是一个伪数组\narguments 的作用是动态获取函数的实参\n\n剩余参数js\n  function config(baseURL, ...other) &#123;\n    console.log(baseURL) // 得到 &#39;http://baidu.com&#39;\n    console.log(other)  // other  得到 [&#39;get&#39;, &#39;json&#39;]\n  &#125;\n  // 调用函数\n  config(&#39;http://baidu.com&#39;, &#39;get&#39;, &#39;json&#39;);\n总结：\n\n... 是语法符号，置于最末函数形参之前，用于获取多余的实参\n借助 ... 获取的剩余实参，是个真数组\n\n箭头函数箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。\njs\n\n    // const fn = function () &#123;\n    //   console.log(123)\n    // &#125;\n    // 1. 箭头函数 基本语法\n    // const fn = () =&gt; &#123;\n    //   console.log(123)\n    // &#125;\n    // fn()\n    // const fn = (x) =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // 2. 只有一个形参的时候，可以省略小括号\n    // const fn = x =&gt; &#123;\n    //   console.log(x)\n    // &#125;\n    // fn(1)\n    // // 3. 只有一行代码的时候，我们可以省略大括号\n    // const fn = x =&gt; console.log(x)\n    // fn(1)\n    // 4. 只有一行代码的时候，可以省略return\n    // const fn = x =&gt; x + x\n    // console.log(fn(1))\n    // 5. 箭头函数可以直接返回一个对象\n    // const fn = (uname) =&gt; (&#123; uname: uname &#125;)\n    // console.log(fn(&#39;刘德华&#39;))\n\n总结：\n\n箭头函数属于表达式函数，因此不存在函数提升\n箭头函数只有一个参数时可以省略圆括号 ()\n箭头函数函数体只有一行代码时可以省略花括号 &#123;&#125;，并自动做为返回值被返回\n\n箭头函数参数箭头函数中没有 arguments，只能使用 ... 动态获取实参\njs\n    // 1. 利用箭头函数来求和\n    const getSum = (...arr) =&gt; &#123;\n      let sum = 0\n      for (let i = 0; i &lt; arr.length; i++) &#123;\n        sum += arr[i]\n      &#125;\n      return sum\n    &#125;\n    const result = getSum(2, 3, 4)\n    console.log(result) // 9\n箭头函数 this箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。\njs\n    // 以前this的指向：  谁调用的这个函数，this 就指向谁\n    // console.log(this)  // window\n    // // 普通函数\n    // function fn() &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // window.fn()\n    // // 对象方法里面的this\n    // const obj = &#123;\n    //   name: &#39;andy&#39;,\n    //   sayHi: function () &#123;\n    //     console.log(this)  // obj\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    // 2. 箭头函数的this  是上一层作用域的this 指向\n    // const fn = () =&gt; &#123;\n    //   console.log(this)  // window\n    // &#125;\n    // fn()\n    // 对象方法箭头函数 this\n    // const obj = &#123;\n    //   uname: &#39;pink老师&#39;,\n    //   sayHi: () =&gt; &#123;\n    //     console.log(this)  // this 指向谁？ window\n    //   &#125;\n    // &#125;\n    // obj.sayHi()\n\n    const obj = &#123;\n      uname: &#39;pink老师&#39;,\n      sayHi: function () &#123;\n        console.log(this)  // obj\n        let i = 10\n        const count = () =&gt; &#123;\n          console.log(this)  // obj \n        &#125;\n        count()\n      &#125;\n    &#125;\n    obj.sayHi()\n解构赋值\n\n\n\n\n\n\n\n\n知道解构的语法及分类，使用解构简洁语法快速为变量赋值。\n解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。\n数组解构数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示：\njs\n  // 普通的数组\n  let arr = [1, 2, 3]\n  // 批量声明变量 a b c \n  // 同时将数组单元值 1 2 3 依次赋值给变量 a b c\n  let [a, b, c] = arr\n  console.log(a); // 1\n  console.log(b); // 2\n  console.log(c); // 3\n总结：\n\n赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量\n变量的顺序对应数组单元值的位置依次进行赋值操作\n变量的数量大于单元值数量时，多余的变量将被赋值为  undefined\n变量的数量小于单元值数量时，可以通过 ... 获取剩余单元值，但只能置于最末位\n允许初始化变量的默认值，且只有单元值为 undefined 时默认值才会生效\n\n注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析\n对象解构对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：\njs\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;;\n  // 批量声明变量 name age\n  // 同时将数组单元值 小明  18 依次赋值给变量 name  age\n  const &#123;name, age&#125; = user\n\n  console.log(name) // 小明\n  console.log(age) // 18\n总结：\n\n赋值运算符 = 左侧的 &#123;&#125; 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量\n对象属性的值将被赋值给与属性名相同的变量\n对象中找不到与变量名一致的属性时变量值为 undefined\n允许初始化变量的默认值，属性不存在或单元值为 undefined 时默认值才会生效\n\n注：支持多维解构赋值\njs\n    // 1. 这是后台传递过来的数据\n    const msg = &#123;\n        &quot;code&quot;: 200,\n        &quot;msg&quot;: &quot;获取新闻列表成功&quot;,\n        &quot;data&quot;: [\n            &#123;\n                &quot;id&quot;: 1,\n                &quot;title&quot;: &quot;5G商用自己，三大运用商收入下降&quot;,\n                &quot;count&quot;: 58\n            &#125;,\n            &#123;\n                &quot;id&quot;: 2,\n                &quot;title&quot;: &quot;国际媒体头条速览&quot;,\n                &quot;count&quot;: 56\n            &#125;,\n            &#123;\n                &quot;id&quot;: 3,\n                &quot;title&quot;: &quot;乌克兰和俄罗斯持续冲突&quot;,\n                &quot;count&quot;: 1669\n            &#125;,\n\n        ]\n    &#125;\n\n    // 需求1： 请将以上msg对象  采用对象解构的方式 只选出  data 方面后面使用渲染页面\n    // const &#123; data &#125; = msg\n    // console.log(data)\n    // 需求2： 上面msg是后台传递过来的数据，我们需要把data选出当做参数传递给 函数\n    // const &#123; data &#125; = msg\n    // msg 虽然很多属性，但是我们利用解构只要 data值\n    function render(&#123; data &#125;) &#123;\n        // const &#123; data &#125; = arr\n        // 我们只要 data 数据\n        // 内部处理\n        console.log(data)\n\n    &#125;\n    render(msg)\n\n    // 需求3， 为了防止msg里面的data名字混淆，要求渲染函数里面的数据名改为 myData\n    function render(&#123; data: myData &#125;) &#123;\n        // 要求将 获取过来的 data数据 更名为 myData\n        // 内部处理\n        console.log(myData)\n\n    &#125;\n    render(msg)综合案例forEach遍历数组forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数\n\n\n\n\n\n\n\n\n\n注意：  \n1.forEach 主要是遍历数组\n2.参数当前数组元素是必须要写的， 索引号可选。\njs\n    // forEach 就是遍历  加强版的for循环  适合于遍历数组对象\n    const arr = [&#39;red&#39;, &#39;green&#39;, &#39;pink&#39;]\n    const result = arr.forEach(function (item, index) &#123;\n      console.log(item)  // 数组元素 red  green pink\n      console.log(index) // 索引号\n    &#125;)\n    // console.log(result)\nfilter筛选数组filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素\n主要使用场景： 筛选数组符合条件的元素，并返回筛选之后元素的新数组\njs\n    const arr = [10, 20, 30]\n    // const newArr = arr.filter(function (item, index) &#123;\n    //   // console.log(item)\n    //   // console.log(index)\n    //   return item &gt;= 20\n    // &#125;)\n    // 返回的符合条件的新数组\n\n    const newArr = arr.filter(item =&gt; item &gt;= 20)\n    console.log(newArr)深入对象\n\n\n\n\n\n\n\n\n了解面向对象的基础概念，能够利用构造函数创建对象。\n构造函数构造函数是专门用于创建对象的函数，如果一个函数使用 new 关键字调用，那么这个函数就是构造函数。\njs\n  // 定义函数\n  function foo() &#123;\n    console.log(&#39;通过 new 也能调用函数...&#39;);\n  &#125;\n  // 调用函数\n  new foo;总结：\n\n使用 new 关键字调用函数的行为被称为实例化\n实例化构造函数时没有参数时可以省略 ()\n构造函数的返回值即为新创建的对象\n构造函数内部的 return 返回的值无效！\n\n注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。\n实例成员通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。\njs\n  // 构造函数\n  function Person() &#123;\n    // 构造函数内部的 this 就是实例对象\n    // 实例对象中动态添加属性\n    this.name = &#39;小明&#39;\n    // 实例对象动态添加方法\n    this.sayHi = function () &#123;\n      console.log(&#39;大家好~&#39;)\n    &#125;\n  &#125;\n  // 实例化，p1 是实例对象\n  // p1 实际就是 构造函数内部的 this\n  const p1 = new Person()\n  console.log(p1)\n  console.log(p1.name) // 访问实例属性\n  p1.sayHi() // 调用实例方法总结：\n\n构造函数内部 this 实际上就是实例对象，为其动态添加的属性和方法即为实例成员\n为构造函数传入参数，动态创建结构相同但值不同的对象\n\n注：构造函数创建的实例对象彼此独立互不影响。\n静态成员在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。\njs\n  // 构造函数\n  function Person(name, age) &#123;\n    // 省略实例成员\n  &#125;\n  // 静态属性\n  Person.eyes = 2\n  Person.arms = 2\n  // 静态方法\n  Person.walk = function () &#123;\n    console.log(&#39;^_^人都会走路...&#39;)\n    // this 指向 Person\n    console.log(this.eyes)\n  &#125;总结：\n\n静态成员指的是添加到构造函数本身的属性和方法\n一般公共特征的属性或方法静态成员设置为静态成员\n静态成员方法中的 this 指向构造函数本身\n\n内置构造函数\n\n\n\n\n\n\n\n\n掌握各引用类型和包装类型对象属性和方法的使用。\n在 JavaScript 中最主要的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。\n在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的，JavaScript 基础阶段学习的 Date 就是内置的构造函数。\njs\n  // 实例化\n    let date = new Date();\n  \n  // date 即为实例对象\n  console.log(date);甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。\nObjectObject 是内置的构造函数，用于创建普通对象。\njs\n  // 通过构造函数创建普通对象\n  const user = new Object(&#123;name: &#39;小明&#39;, age: 15&#125;)\n\n  // 这种方式声明的变量称为【字面量】\n  let student = &#123;name: &#39;杜子腾&#39;, age: 21&#125;\n  \n  // 对象语法简写\n  let name = &#39;小红&#39;;\n  let people = &#123;\n    // 相当于 name: name\n    name,\n    // 相当于 walk: function () &#123;&#125;\n    walk () &#123;\n      console.log(&#39;人都要走路...&#39;);\n    &#125;\n  &#125;\n\n  console.log(student.constructor);\n  console.log(user.constructor);\n  console.log(student instanceof Object);总结：\n\n推荐使用字面量方式声明对象，而不是 Object 构造函数\nObject.assign 静态方法创建新的对象\nObject.keys 静态方法获取对象中所有属性\nObject.values 表态方法获取对象中所有属性值\n\nArrayArray 是内置的构造函数，用于创建数组。\njs\n  // 构造函数创建数组\n  let arr = new Array(5, 7, 8);\n\n  // 字面量方式创建数组\n  let list = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。\n总结：\n\n推荐使用字面量方式声明数组，而不是 Array 构造函数\n\n实例方法 forEach 用于遍历数组，替代 for 循环 (重点)\n\n实例方法 filter 过滤数组单元值，生成新数组(重点)\n\n实例方法 map 迭代原数组，生成新数组(重点)\n\n实例方法 join 数组元素拼接为字符串，返回字符串(重点)\n\n实例方法  find  查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点)\n\n实例方法every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回 true，否则返回 false(重点)\n\n实例方法some 检测数组中的元素是否满足指定条件   如果数组中有元素满足条件返回 true，否则返回 false\n\n实例方法 concat  合并两个数组，返回生成新数组\n\n实例方法 sort 对原数组单元值排序\n\n实例方法 splice 删除或替换原数组单元\n\n实例方法 reverse 反转数组\n\n实例方法 findIndex  查找元素的索引值\n\n\n包装类型在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：\njs\n  // 字符串类型\n  const str = &#39;hello world!&#39;\n     // 统计字符的长度（字符数量）\n  console.log(str.length)\n  \n  // 数值类型\n  const price = 12.345\n  // 保留两位小数\n  price.toFixed(2) // 12.34之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。\nStringString 是内置的构造函数，用于创建字符串。\njs\n  // 使用构造函数创建字符串\n  let str = new String(&#39;hello world!&#39;);\n\n  // 字面量创建字符串\n  let str2 = &#39;你好，世界！&#39;;\n\n  // 检测是否属于同一个构造函数\n  console.log(str.constructor === str2.constructor); // true\n  console.log(str instanceof String); // false总结：\n\n实例属性 length 用来获取字符串的度长(重点)\n实例方法 split(&#39;分隔符&#39;) 用来将字符串拆分成数组(重点)\n实例方法 substring（需要截取的第一个字符的索引[,结束的索引号]） 用于字符串截取(重点)\n实例方法 startsWith(检测字符串[, 检测位置索引号]) 检测是否以某字符开头(重点)\n实例方法 includes(搜索的字符串[, 检测位置索引号]) 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false(重点)\n实例方法 toUpperCase 用于将字母转换成大写\n实例方法 toLowerCase 用于将就转换成小写\n实例方法 indexOf  检测是否包含某字符\n实例方法 endsWith 检测是否以某字符结尾\n实例方法 replace 用于替换字符串，支持正则匹配\n实例方法 match 用于查找字符串，支持正则匹配\n\n注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。\nNumberNumber 是内置的构造函数，用于创建数值。\njs\n  // 使用构造函数创建数值\n  let x = new Number(&#39;10&#39;)\n  let y = new Number(5)\n\n  // 字面量创建数值\n  let z = 20总结：\n\n推荐使用字面量方式声明数值，而不是 Number 构造函数\n实例方法 toFixed 用于设置保留小数位的长度\n\n编程思想\n\n\n\n\n\n\n\n\n学习 JavaScript 中基于原型的面向对象编程序的语法实现，理解面向对象编程的特征。\n面向过程面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次\n调用就可以了。\n 举个栗子：蛋炒饭\n\n面向对象面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。\n\n在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。\n面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。\n面向对象的特性：\n\n封装性\n\n继承性\n\n多态性\n\n\n构造函数对比以下通过面向对象的构造函数实现的封装：\njs\n  function Person() &#123;\n    this.name = &#39;佚名&#39;\n    // 设置名字\n    this.setName = function (name) &#123;\n      this.name = name\n    &#125;\n    // 读取名字\n    this.getName = () =&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  // 实例对像，获得了构造函数中封装的所有逻辑\n  let p1 = new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  // 实例对象\n  let p2 = new Person()\n  console.log(p2.name)封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。\n同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之\n间是彼此不影响的\n\n\n\n\n\n\n\n\n\n总结：\n\n构造函数体现了面向对象的封装特性\n构造函数实例创建的对象彼此独立、互不影响\n\n封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。\n前面我们学过的构造函数方法很好用，但是 存在浪费内存的问题\n原型对象构造函数通过原型分配的函数是所有对象所 共享的。\n\nJavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象\n这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。\n构造函数和原型对象中的this 都指向 实例化的对象\n\njs\n  function Person() &#123;\n    \n  &#125;\n\n  // 每个函数都有 prototype 属性\n  console.log(Person.prototype)了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：\njs\n  function Person() &#123;\n    // 此处未定义任何方法\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n    \n  // 实例化\n  let p1 = new Person();\n  p1.sayHi(); // 输出结果为 Hi~构造函数 Person 中未定义任何方法，这时实例对象调用了原型对象中的方法 sayHi，接下来改动一下代码：\njs\n  function Person() &#123;\n    // 此处定义同名方法 sayHi\n    this.sayHi = function () &#123;\n      console.log(&#39;嗨!&#39;);\n    &#125;\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n\n  let p1 = new Person();\n  p1.sayHi(); // 输出结果为 嗨!构造函数 Person 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 sayHi。\n通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。\njs\n    function Person() &#123;\n    // 此处定义同名方法 sayHi\n    this.sayHi = function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  // 为构造函数的原型对象添加方法\n  Person.prototype.sayHi = function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  // 在构造函数的原型对象上添加属性\n  Person.prototype.name = &#39;小明&#39;\n\n  let p1 = new Person()\n  p1.sayHi(); // 输出结果为 嗨!\n  \n  let p2 = new Person()\n  p2.sayHi()总结：结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。\nconstructor 属性在哪里？ 每个原型对象里面都有个constructor 属性（constructor 构造函数）\n作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子\n使用场景：\n如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.\n但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了\n此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。\n对象原型对象都会有一个属性 proto 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype \n原型对象的属性和方法，就是因为对象有 proto 原型的存在。\n注意：\n\nproto 是JS非标准属性\n[[prototype]]和__proto__意义相同\n用来表明当前实例对象指向哪个原型对象prototype\n__proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数\n\n原型继承继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承\n的特性。\n龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。\njs\n    // 继续抽取   公共的部分放到原型上\n    // const Person1 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // const Person2 = &#123;\n    //   eyes: 2,\n    //   head: 1\n    // &#125;\n    // 构造函数  new 出来的对象 结构一样，但是对象不一样\n    function Person() &#123;\n      this.eyes = 2\n      this.head = 1\n    &#125;\n    // console.log(new Person)\n    // 女人  构造函数   继承  想要 继承 Person\n    function Woman() &#123;\n\n    &#125;\n    // Woman 通过原型来继承 Person\n    // 父构造函数（父类）   子构造函数（子类）\n    // 子类的原型 =  new 父类  \n    Woman.prototype = new Person()   // &#123;eyes: 2, head: 1&#125; \n    // 指回原来的构造函数\n    Woman.prototype.constructor = Woman\n\n    // 给女人添加一个方法  生孩子\n    Woman.prototype.baby = function () &#123;\n      console.log(&#39;宝贝&#39;)\n    &#125;\n    const red = new Woman()\n    console.log(red)\n    // console.log(Woman.prototype)\n    // 男人 构造函数  继承  想要 继承 Person\n    function Man() &#123;\n\n    &#125;\n    // 通过 原型继承 Person\n    Man.prototype = new Person()\n    Man.prototype.constructor = Man\n    const pink = new Man()\n    console.log(pink)原型链基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对\n象的链状结构关系称为原型链\n\njs\n    // function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh = new Person()\n    // console.log(ldh.__proto__ === Person.prototype)\n    // console.log(Person.prototype.__proto__ === Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。\n② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）\n③ 如果还没有就查找原型对象的原型（Object的原型对象）\n④ 依此类推一直找到 Object 为止（null）\n⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线\n⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n深浅拷贝浅拷贝首先浅拷贝和深拷贝只针对引用类型\n浅拷贝：拷贝的是地址\n常见方法：\n\n拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象\n拷贝数组：Array.prototype.concat() 或者 […arr]\n\n\n\n\n\n\n\n\n\n\n如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 (简单理解： 如果是单层对象，没问题，如果有多层就有问题)\n深拷贝首先浅拷贝和深拷贝只针对引用类型\n深拷贝：拷贝的是对象，不是地址\n常见方法：\n\n通过递归实现深拷贝\nlodash&#x2F;cloneDeep\n通过JSON.stringify()实现\n\n递归实现深拷贝函数递归：\n如果一个函数在内部可以调用其本身，那么这个函数就是递归函数\n\n简单理解:函数内部自己调用自己, 这个函数就是递归函数\n递归函数的作用和循环效果类似\n由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return\n\njs\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = &#123;&#125;\n    // 拷贝函数\n    function deepCopy(newObj, oldObj) &#123;\n      debugger\n      for (let k in oldObj) &#123;\n        // 处理数组的问题  一定先写数组 在写 对象 不能颠倒\n        if (oldObj[k] instanceof Array) &#123;\n          newObj[k] = []\n          //  newObj[k] 接收 []  hobby\n          //  oldObj[k]   [&#39;乒乓球&#39;, &#39;足球&#39;]\n          deepCopy(newObj[k], oldObj[k])\n        &#125; else if (oldObj[k] instanceof Object) &#123;\n          newObj[k] = &#123;&#125;\n          deepCopy(newObj[k], oldObj[k])\n        &#125;\n        else &#123;\n          //  k  属性名 uname age    oldObj[k]  属性值  18\n          // newObj[k]  === o.uname  给新对象添加属性\n          newObj[k] = oldObj[k]\n        &#125;\n      &#125;\n    &#125;\n    deepCopy(o, obj) // 函数调用  两个参数 o 新对象  obj 旧对象\n    console.log(o)\n    o.age = 20\n    o.hobby[0] = &#39;篮球&#39;\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n    console.log([1, 23] instanceof Object)\n    // 复习\n    // const obj = &#123;\n    //   uname: &#39;pink&#39;,\n    //   age: 18,\n    //   hobby: [&#39;乒乓球&#39;, &#39;足球&#39;]\n    // &#125;\n    // function deepCopy(&#123; &#125;, oldObj) &#123;\n    //   // k 属性名  oldObj[k] 属性值\n    //   for (let k in oldObj) &#123;\n    //     // 处理数组的问题   k 变量\n    //     newObj[k] = oldObj[k]\n    //     // o.uname = &#39;pink&#39;\n    //     // newObj.k  = &#39;pink&#39;\n    //   &#125;\n    // &#125;js库lodash里面cloneDeep内部实现了深拷贝html&lt;body&gt;\n  &lt;!-- 先引用 --&gt;\n  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o = _.cloneDeep(obj)\n    console.log(o)\n    o.family.baby = &#39;老pink&#39;\n    console.log(obj)\n  &lt;/script&gt;\n&lt;/body&gt;JSON序列化js\n    const obj = &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    // 把对象转换为 JSON 字符串\n    // console.log(JSON.stringify(obj))\n    const o = JSON.parse(JSON.stringify(obj))\n    console.log(o)\n    o.family.baby = &#39;123&#39;\n    console.log(obj)异常处理\n\n\n\n\n\n\n\n\n了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。\nthrow异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行\n总结：\n\nthrow 抛出异常信息，程序也会终止执行\nthrow 后面跟的是错误提示信息\nError 对象配合 throw 使用，能够设置更详细的错误信息\n\njs\n  function counter(x, y) &#123;\n\n    if(!x || !y) &#123;\n      // throw &#39;参数不能为空!&#39;;\n      throw new Error(&#39;参数不能为空!&#39;)\n    &#125;\n\n    return x + y\n  &#125;\n\n  counter()总结：\n\nthrow 抛出异常信息，程序也会终止执行\nthrow 后面跟的是错误提示信息\nError 对象配合 throw 使用，能够设置更详细的错误信息\n\ntry … catchjs\n   function foo() &#123;\n      try &#123;\n        // 查找 DOM 节点\n        const p = document.querySelector(&#39;.p&#39;)\n        p.style.color = &#39;red&#39;\n      &#125; catch (error) &#123;\n        // try 代码段中执行有错误时，会执行 catch 代码段\n        // 查看错误信息\n        console.log(error.message)\n        // 终止代码继续执行\n        return\n\n      &#125;\n      finally &#123;\n          alert(&#39;执行&#39;)\n      &#125;\n      console.log(&#39;如果出现错误，我的语句不会执行&#39;)\n    &#125;\n    foo()总结：\n\ntry...catch 用于捕获错误信息\n将预估可能发生错误的代码写在 try 代码段中\n如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息\n\ndebugger相当于断点调试\n处理this\n\n\n\n\n\n\n\n\n了解函数中 this 在不同场景下的默认值，知道动态指定函数 this 值的方法。\nthis 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 this 默认的取值】情况进行归纳和总结。\n普通函数普通函数的调用方式决定了 this 的值，即【谁调用 this 的值指向谁】，如下代码所示：\njs\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)  \n  &#125;\n  // 函数表达式\n  const sayHello = function () &#123;\n    console.log(this)\n  &#125;\n  // 函数的调用方式决定了 this 的值\n  sayHi() // window\n  window.sayHi()\n    \n\n// 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    walk: function () &#123;\n      console.log(this)\n    &#125;\n  &#125;\n  // 动态为 user 添加方法\n  user.sayHi = sayHi\n  uesr.sayHello = sayHello\n  // 函数调用方式，决定了 this 的值\n  user.sayHi()\n  user.sayHello()注： 普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined。\n箭头函数箭头函数中的 this 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 this ！箭头函数中访问的 this 不过是箭头函数所在作用域的 this 变量。\njs\n  console.log(this) // 此处为 window\n  // 箭头函数\n  const sayHi = function() &#123;\n    console.log(this) // 该箭头函数中的 this 为函数声明环境中 this 一致\n  &#125;\n  // 普通对象\n  const user = &#123;\n    name: &#39;小明&#39;,\n    // 该箭头函数中的 this 为函数声明环境中 this 一致\n    walk: () =&gt; &#123;\n      console.log(this)\n    &#125;,\n    \n    sleep: function () &#123;\n      let str = &#39;hello&#39;\n      console.log(this)\n      let fn = () =&gt; &#123;\n        console.log(str)\n        console.log(this) // 该箭头函数中的 this 与 sleep 中的 this 一致\n      &#125;\n      // 调用箭头函数\n      fn();\n    &#125;\n  &#125;\n\n  // 动态添加方法\n  user.sayHi = sayHi\n  \n  // 函数调用\n  user.sayHi()\n  user.sleep()\n  user.walk()在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：\njs\n  // DOM 节点\n  const btn = document.querySelector(&#39;.btn&#39;)\n  // 箭头函数 此时 this 指向了 window\n  btn.addEventListener(&#39;click&#39;, () =&gt; &#123;\n    console.log(this)\n  &#125;)\n  // 普通函数 此时 this 指向了 DOM 对象\n  btn.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(this)\n  &#125;)同样由于箭头函数 this 的原因，基于原型的面向对象也不推荐采用箭头函数，如下代码所示：\njs\n  function Person() &#123;\n  &#125;\n  // 原型对像上添加了箭头函数\n  Person.prototype.walk = () =&gt; &#123;\n    console.log(&#39;人都要走路...&#39;)\n    console.log(this); // window\n  &#125;\n  const p1 = new Person()\n  p1.walk()改变this指向以上归纳了普通函数和箭头函数中关于 this 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 this 的指向，有 3 个方法可以动态指定普通函数中 this 的指向：\ncall使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示：\njs\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this);\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.call(user); // this 值为 user\n  sayHi.call(student); // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y;\n  &#125;\n\n  // 调用 counter 函数，并传入参数\n  let result = counter.call(null, 5, 10);\n  console.log(result);总结：\n\ncall 方法能够在调用函数的同时指定 this 的值\n使用 call 方法调用函数时，第1个参数为 this 指定的值\ncall 方法的其余参数会依次自动传入函数做为函数的参数\n\napply使用 call 方法调用函数，同时指定函数中 this 的值，使用方法如下代码所示：\njs\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student = &#123;\n    name: &#39;小红&#39;,\n    age: 16\n  &#125;\n\n  // 调用函数并指定 this 的值\n  sayHi.apply(user) // this 值为 user\n  sayHi.apply(student) // this 值为 student\n\n  // 求和函数\n  function counter(x, y) &#123;\n    return x + y\n  &#125;\n  // 调用 counter 函数，并传入参数\n  let result = counter.apply(null, [5, 10])\n  console.log(result)总结：\n\napply 方法能够在调用函数的同时指定 this 的值\n使用 apply 方法调用函数时，第1个参数为 this 指定的值\napply 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数\n\nbindbind 方法并不会调用函数，而是创建一个指定了 this 值的新函数，使用方法如下代码所示：\njs\n  // 普通函数\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n  let user = &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n  // 调用 bind 指定 this 的值\n  let sayHello = sayHi.bind(user);\n  // 调用使用 bind 创建的新函数\n  sayHello()注：bind 方法创建新的函数，与原函数的唯一的变化是改变了 this 的值。\n防抖节流\n防抖（debounce）所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间\n节流（throttle）所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数\n\n","slug":"前端/JavaScript/JavaScript进阶","date":"2023-08-24T00:30:00.000Z","categories_index":"计算机,前端","tags_index":"笔记,JavaScript","author_index":"Honman"},{"id":"5db41f0a5fc879d1afc84eff3a276b04","title":"JavaScript-基础笔记","content":"JavaScript 基础介绍\n\n\n\n\n\n\n\n\n掌握 JavaScript 的引入方式，初步认识 JavaScript 的作用\n引入方式JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 script 标签将 JavaScript 代码引入到 HTML 中，有两种方式：\n内部方式通过 script 标签包裹 JavaScript 代码\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基础 - 引入方式&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- 内联形式：通过 script 标签包裹 JavaScript 代码 --&gt;\n  &lt;script&gt;\n    alert(&#39;嗨，欢迎来传智播学习前端技术！&#39;)\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;外部形式一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 script 标签的 src 属性引入\njs// demo.js\ndocument.write(&#39;嗨，欢迎来传智播学习前端技术！&#39;)html&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基础 - 引入方式&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;\n  &lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;如果 script 标签使用 src 属性引入了某 .js 文件，那么 标签的代码会被忽略！！！如下代码所示：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基础 - 引入方式&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;\n  &lt;script src=&quot;demo.js&quot;&gt;\n    // 此处的代码会被忽略掉！！！！\n      alert(666);  \n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;注释和结束符通过注释可以屏蔽代码被执行或者添加备注信息，JavaScript 支持两种形式注释语法：\n单行注释使用 //  注释单行代码\njs // 这种是单行注释的语法\n // 一次只能注释一行\n // 可以重复注释\n document.write(&#39;嗨，欢迎来到王者荣耀~ 学习前端技术！&#39;);多行注释使用 /* */ 注释多行代码\njs        /* 这种的是多行注释的语法 */\n    /*\n        更常见的多行注释是这种写法\n        在些可以任意换行\n        多少行都可以\n      */\n    document.write(&#39;嗨，欢迎来传智播学习前端技术！&#39;)注：编辑器中单行注释的快捷键为 ctrl + /\n结束符在 JavaScript 中 ; 代表一段代码的结束，多数情况下可以省略 ; 使用回车（enter）替代。\njs        alert(1);\n    alert(2);\n    alert(1)\n    alert(2)实际开发中有许多人主张书写 JavaScript 代码时省略结束符 ;\n输入和输出输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。\n举例说明：如按键盘上的方向键，向上&#x2F;下键可以滚动页面，按向上&#x2F;下键这个动作叫作输入，页面发生了滚动了这便叫输出。\n输出JavaScript 可以接收用户的输入，然后再将输入的结果输出：\nalert()、document.wirte()\n以数字为例，向 alert() 或 document.write()输入任意数字，他都会以弹窗形式展示（输出）给用户。\n输入向 prompt() 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。\njs\n    // 1. 输入的任意数字，都会以弹窗形式展示\n    document.write(&#39;要输出的内容&#39;)\n    alert(&#39;要输出的内容&#39;);\n\n    // 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号\n    prompt(&#39;请输入您的姓名:&#39;)变量\n\n\n\n\n\n\n\n\n理解变量是计算机存储数据的“容器”，掌握变量的声明方式\n变量是计算机中用来存储数据的“容器”，它可以让计算机变得有记忆，通俗的理解变量就是使用【某个符号】来代表【某个具体的数值】（数据）\njs\n  // x 符号代表了 5 这个数值\n  x = 5\n  // y 符号代表了 6 这个数值\n  y = 6\n    \n  //举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！\n\n  // 将用户输入的内容保存在 num 这个变量（容器）中\n  num = prompt(&#39;请输入一数字!&#39;)\n\n  // 通过 num 变量（容器）将用户输入的内容输出出来\n  alert(num)\n  document.write(num)声明声明(定义)变量有两部分构成：声明关键字、变量名（标识）\njs\n    // let 变量名\n    // 声明(定义)变量有两部分构成：声明关键字、变量名（标识）\n    // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语\n    // age 即变量的名称，也叫标识符\n    let age关键字是 JavaScript 中内置的一些英文词汇（单词或缩写），它们代表某些特定的含义，如 let 的含义是声明变量的，看到 let  后就可想到这行代码的意思是在声明变量，如 let age; \nlet 和 var 都是 JavaScript 中的声明变量的关键字，推荐使用 let 声明变量！！！\n赋值声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。\njs\n    // 声明(定义)变量有两部分构成：声明关键字、变量名（标识）\n    // let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语\n    // age 即变量的名称，也叫标识符\n    let age\n    // 赋值，将 18 这个数据存入了 age 这个“容器”中\n    age = 18\n    // 这样 age 的值就成了 18\n    document.write(age)\n    \n    // 也可以声明和赋值同时进行\n    let str = &#39;hello world!&#39;\n    alert(str);关键字JavaScript 使用专门的关键字 let 和 var 来声明（定义）变量，在使用时需要注意一些细节：\n以下是使用 let 时的注意事项：\n\n允许声明和赋值同时进行\n不允许重复声明\n允许同时声明多个变量并赋值\nJavaScript 中内置的一些关键字不能被当做变量名\n\n以下是使用 var 时的注意事项：\n\n允许声明和赋值同时进行\n允许重复声明\n允许同时声明多个变量并赋值\n\n大部分情况使用 let 和 var 区别不大，但是 let 相较 var 更严谨，因此推荐使用 let，后期会更进一步介绍二者间的区别。\n变量名命名规则关于变量的名称（标识符）有一系列的规则需要遵守：\n\n只能是字母、数字、下划线、$，且不能能数字开头\n字母区分大小写，如 Age 和 age 是不同的变量\nJavaScript 内部已占用于单词（关键字或保留字）不允许使用\n尽量保证变量具有一定的语义，见字知义\n\n注：所谓关键字是指 JavaScript 内部使用的词语，如 let 和var，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。\njs\n    let age = 18 // 正确\n    let age1 = 18 // 正确\n    let _age = 18 // 正确\n\n    // let 1age = 18; // 错误，不可以数字开头\n    let $age = 18 // 正确\n    let Age = 24 // 正确，它与小写的 age 是不同的变量\n    // let let = 18; // 错误，let 是关键字\n    let int = 123 // 不推荐，int 是保留字\n常量概念：使用 const 声明的变量称为“常量”。\n使用场景：当某个变量永远不会改变的时候，就可以使用 const 来声明，而不是let。\n命名规范：和变量一致\njsconst PI = 3.14\n\n\n\n\n\n\n\n\n注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）\n数据类型\n\n\n\n\n\n\n\n\n计算机世界中的万事成物都是数据。\n计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型：\n注：通过 typeof 关键字检测数据类型\njs\n    // 检测 1 是什么类型数据，结果为 number\n    document.write(typeof 1)数值类型即我们数学中学习到的数字，可以是整数、小数、正数、负数\njs\n    let score = 100 // 正整数\n    let price = 12.345 // 小数\n    let temperature = -40 // 负数\n\n    document.write(typeof score) // 结果为 number\n    document.write(typeof price) // 结果为 number\n    document.write(typeof temperature) // 结果为 numberJavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。\n字符串类型通过单引号（ &#39;&#39;） 、双引号（ &quot;&quot;）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。\n注意事项：\n\n无论单引号或是双引号必须成对使用\n单引号&#x2F;双引号可以互相嵌套，但是不以自已嵌套自已\n必要时可以使用转义符 \\，输出单引号或双引号\n\njs\n    let user_name = &#39;小明&#39; // 使用单引号\n    let gender = &quot;男&quot; // 使用双引号\n    let str = &#39;123&#39; // 看上去是数字，但是用引号包裹了就成了字符串了\n    let str1 = &#39;&#39; // 这种情况叫空字符串\n        \n    documeent.write(typeof user_name) // 结果为 string\n    documeent.write(typeof gender) // 结果为 string\n    documeent.write(typeof str) // 结果为 string布尔类型表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 true 和 false，表示肯定的数据用 true，表示否定的数据用 false。\njs\n    //  pink老师帅不帅？回答 是 或 否\n    let isCool = true // 是的，摔死了！\n    isCool = false // 不，套马杆的汉子！\n\n    document.write(typeof isCool) // 结果为 booleanundefined未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。\njs\n    // 只声明了变量，并末赋值\n    let tmp;\n    document.write(typeof tmp) // 结果为 undefined注：JavaScript 中变量的值决定了变量的数据类型。\n类型转换\n\n\n\n\n\n\n\n\n理解弱类型语言的特征，掌握显式类型转换的方法\n在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。\n隐式转换某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。\njs\n    let num = 13 // 数值\n    let num2 = &#39;2&#39; // 字符串\n\n    // 结果为 132\n    // 原因是将数值 num 转换成了字符串，相当于 &#39;13&#39;\n    // 然后 + 将两个字符串拼接到了一起\n    console.log(num + num2)\n\n    // 结果为 11\n    // 原因是将字符串 num2 转换成了数值，相当于 2\n    // 然后数值 13 减去 数值 2\n    console.log(num - num2)\n\n    let a = prompt(&#39;请输入一个数字&#39;)\n    let b = prompt(&#39;请再输入一个数字&#39;)\n\n    alert(a + b)注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。\n补充介绍模板字符串的拼接的使用\n显式转换编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。\nNumber通过 Number 显示转换成数值类型，当转换失败时结果为 NaN（Not a Number）即不是一个数字。\njs\n    let t = &#39;12&#39;\n    let f = 8\n\n    // 显式将字符串 12 转换成数值 12\n    t = Number(t)\n\n    // 检测转换后的类型\n    // console.log(typeof t);\n    console.log(t + f) // 结果为 20\n\n    // 并不是所有的值都可以被转成数值类型\n    let str = &#39;hello&#39;\n    // 将 hello 转成数值是不现实的，当无法转换成\n    // 数值时，得到的结果为 NaN （Not a Number）\n    console.log(Number(str))运算符算术运算符数字是用来计算的，比如：乘法 * 、除法 &#x2F; 、加法 + 、减法 - 等等，所以经常和算术运算符一起。\n算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等\n\n\n\n运算符\n作用\n\n\n\n+\n求和\n\n\n-\n求差\n\n\n*\n求积\n\n\n&#x2F;\n求商\n\n\n%\n取模（取余数），开发中经常用于作为某个数字是否被整除\n\n\n\n\n\n\n\n\n\n\n\n注意：在计算失败时，显示的结果是 NaN （not a number）\njs// 算术运算符\nconsole.log(1 + 2 * 3 / 2) //  4 \nlet num = 10\nconsole.log(num + 10)  // 20\nconsole.log(num + num)  // 20\n\n// 1. 取模(取余数)  使用场景：  用来判断某个数是否能够被整除\nconsole.log(4 % 2) //  0  \nconsole.log(6 % 3) //  0\nconsole.log(5 % 3) //  2\nconsole.log(3 % 5) //  3\n\n// 2. 注意事项 : 如果我们计算失败，则返回的结果是 NaN (not a number)\nconsole.log(&#39;pink老师&#39; - 2)\nconsole.log(&#39;pink老师&#39; * 2)\nconsole.log(&#39;pink老师&#39; + 2)   // pink老师2赋值运算符赋值运算符：对变量进行赋值的运算符\n &#x3D;     将等号右边的值赋予给左边, 要求左边必须是一个容器\n\n\n\n运算符\n作用\n\n\n\n+&#x3D;\n加法赋值\n\n\n-+\n减法赋值\n\n\n*&#x3D;\n乘法赋值\n\n\n&#x2F;&#x3D;\n除法赋值\n\n\n%&#x3D;\n取余赋值\n\n\njs\nlet num = 1\n// num = num + 1\n// 采取赋值运算符\n// num += 1\nnum += 3\nconsole.log(num)自增&#x2F;自减运算符\n\n\n符号\n作用\n说明\n\n\n\n++\n自增\n变量自身的值加1，例如: x++\n\n\n–\n自减\n变量自身的值减1，例如: x–\n\n\n\n++在前和++在后在单独使用时二者并没有差别，而且一般开发中我们都是独立使用\n++在后（后缀式）我们会使用更多\n\n\n\n\n\n\n\n\n\n\n注意：\n\n只有变量能够使用自增和自减运算符\n++、– 可以在变量前面也可以在变量后面，比如: x++  或者  ++x\n\njs\n    // let num = 10\n    // num = num + 1\n    // num += 1\n    // // 1. 前置自增\n    // let i = 1\n    // ++i\n    // console.log(i)\n\n    // let i = 1\n    // console.log(++i + 1)\n    // 2. 后置自增\n    // let i = 1\n    // i++\n    // console.log(i)\n    // let i = 1\n    // console.log(i++ + 1)\n\n    // 了解 \n    let i = 1\n    console.log(i++ + ++i + i)比较运算符使用场景：比较两个数据大小、是否相等，根据比较结果返回一个布尔值（true &#x2F; false）\n\n\n\n运算符\n作用\n\n\n\n&gt;\n左边是否大于右边\n\n\n&lt;\n左边是否小于右边\n\n\n&gt;&#x3D;\n左边是否大于或等于右边\n\n\n&lt;&#x3D;\n左边是否小于或等于右边\n\n\n&#x3D;&#x3D;&#x3D;\n左右两边是否类型和值都相等（重点）\n\n\n&#x3D;&#x3D;\n左右两边值是否相等\n\n\n!&#x3D;\n左右值不相等\n\n\n!&#x3D;&#x3D;\n左右两边是否不全等\n\n\njs\n  console.log(3 &gt; 5)\n  console.log(3 &gt;= 3)\n  console.log(2 == 2)\n  // 比较运算符有隐式转换 把&#39;2&#39; 转换为 2  双等号 只判断值\n  console.log(2 == &#39;2&#39;)  // true\n  // console.log(undefined === null)\n  // === 全等 判断 值 和 数据类型都一样才行\n  // 以后判断是否相等 请用 ===  \n  console.log(2 === &#39;2&#39;)\n  console.log(NaN === NaN) // NaN 不等于任何人，包括他自己\n  console.log(2 !== &#39;2&#39;)  // true  \n  console.log(2 != &#39;2&#39;) // false \n  console.log(&#39;-------------------------&#39;)\n  console.log(&#39;a&#39; &lt; &#39;b&#39;) // true\n  console.log(&#39;aa&#39; &lt; &#39;ab&#39;) // true\n  console.log(&#39;aa&#39; &lt; &#39;aac&#39;) // true\n  console.log(&#39;-------------------------&#39;)逻辑运算符使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值\n\n\n\n符号\n名称\n日常读法\n特点\n口诀\n\n\n\n&amp;&amp;\n逻辑与\n并且\n符号两边有一个假的结果为假\n一假则假\n\n\n||\n逻辑或\n或者\n符号两边有一个真的结果为真\n一真则真\n\n\n!\n逻辑非\n取反\ntrue变false  false变true\n真变假，假变真\n\n\n\n\n\nA\nB\nA &amp;&amp; B\nA || B\n!A\n\n\n\nfalse\nfalse\nfalse\nfalse\ntrue\n\n\nfalse\ntrue\nfalse\ntrue\ntrue\n\n\ntrue\nfalse\nfalse\ntrue\nfalse\n\n\ntrue\ntrue\ntrue\ntrue\nfalse\n\n\njs\n    // 逻辑与 一假则假\n    console.log(true &amp;&amp; true)\n    console.log(false &amp;&amp; true)\n    console.log(3 &lt; 5 &amp;&amp; 3 &gt; 2)\n    console.log(3 &lt; 5 &amp;&amp; 3 &lt; 2)\n    console.log(&#39;-----------------&#39;)\n    // 逻辑或 一真则真\n    console.log(true || true)\n    console.log(false || true)\n    console.log(false || false)\n    console.log(&#39;-----------------&#39;)\n    // 逻辑非  取反\n    console.log(!true)\n    console.log(!false)\n\n    console.log(&#39;-----------------&#39;)\n\n    let num = 6\n    console.log(num &gt; 5 &amp;&amp; num &lt; 10)\n    console.log(&#39;-----------------&#39;)运算符优先级\n\n\n\n\n\n\n\n\n逻辑运算符优先级： ！&gt; &amp;&amp; &gt;  ||  \n语句表达式和语句\n分支语句分支语句可以根据条件判定真假，来选择性的执行想要的代码\n分支语句包含：\n\nif分支语句（重点）\n三元运算符\nswitch语句\n\nif 分支语句语法：\njsif(条件表达式) &#123;\n  // 满足条件要执行的语句\n&#125;小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码；为false，则不执行大括号里面代码\n小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()\n如果大括号只有一个语句，大括号可以省略，但是，俺们不提倡这么做~\njs\n    // 单分支语句\n    // if (false) &#123;\n    //   console.log(&#39;执行语句&#39;)\n    // &#125;\n    // if (3 &gt; 5) &#123;\n    //   console.log(&#39;执行语句&#39;)\n    // &#125;\n    // if (2 === &#39;2&#39;) &#123;\n    //   console.log(&#39;执行语句&#39;)\n    // &#125;\n    //  1. 除了0 所有的数字都为真\n    //   if (0) &#123;\n    //     console.log(&#39;执行语句&#39;)\n    //   &#125;\n    // 2.除了 &#39;&#39; 所有的字符串都为真 true\n    // if (&#39;pink老师&#39;) &#123;\n    //   console.log(&#39;执行语句&#39;)\n    // &#125;\n    // if (&#39;&#39;) &#123;\n    //   console.log(&#39;执行语句&#39;)\n    // &#125;\n    // // if (&#39;&#39;) console.log(&#39;执行语句&#39;)\n\n    // 1. 用户输入\n    let score = +prompt(&#39;请输入成绩&#39;)\n    // 2. 进行判断输出\n    if (score &gt;= 700) &#123;\n      alert(&#39;恭喜考入黑马程序员&#39;)\n    &#125;\n    console.log(&#39;-----------------&#39;)if双分支语句如果有两个条件的时候，可以使用 if else 双分支语句\njsif (条件表达式)&#123;\n  // 满足条件要执行的语句\n&#125; else &#123;\n  // 不满足条件要执行的语句\n&#125;例如：\njs\n    // 1. 用户输入\n    let uname = prompt(&#39;请输入用户名:&#39;)\n    let pwd = prompt(&#39;请输入密码:&#39;)\n    // 2. 判断输出\n    if (uname === &#39;pink&#39; &amp;&amp; pwd === &#39;123456&#39;) &#123;\n      alert(&#39;恭喜登录成功&#39;)\n    &#125; else &#123;\n      alert(&#39;用户名或者密码错误&#39;)\n    &#125;if 多分支语句使用场景： 适合于有多个条件的时候\njs\n    // 1. 用户输入\n    let score = +prompt(&#39;请输入成绩：&#39;)\n    // 2. 判断输出\n    if (score &gt;= 90) &#123;\n      alert(&#39;成绩优秀，宝贝，你是我的骄傲&#39;)\n    &#125; else if (score &gt;= 70) &#123;\n      alert(&#39;成绩良好，宝贝，你要加油哦~~&#39;)\n    &#125; else if (score &gt;= 60) &#123;\n      alert(&#39;成绩及格，宝贝，你很危险~&#39;)\n    &#125; else &#123;\n      alert(&#39;成绩不及格，宝贝，我不想和你说话，我只想用鞭子和你说话~&#39;)\n    &#125;三元运算符（三元表达式）使用场景： 一些简单的双分支，可以使用  三元运算符（三元表达式），写起来比 if  else双分支 更简单\n符号：? 与 : 配合使用\n语法：\njs条件 ? 表达式1 ： 表达式2例如：\njs// 三元运算符（三元表达式）\n// 1. 语法格式\n// 条件 ? 表达式1 : 表达式2 \n\n// 2. 执行过程 \n// 2.1 如果条件为真，则执行表达式1\n// 2.2 如果条件为假，则执行表达式2\n\n// 3. 验证\n// 5 &gt; 3 ? &#39;真的&#39; : &#39;假的&#39;\nconsole.log(5 &lt; 3 ? &#39;真的&#39; : &#39;假的&#39;)\n\n// let age = 18 \n// age = age + 1\n//  age++\n\n// 1. 用户输入 \nlet num = prompt(&#39;请您输入一个数字:&#39;)\n// 2. 判断输出- 小于10才补0\n// num = num &lt; 10 ? 0 + num : num\nnum = num &gt;= 10 ? num : 0 + num\nalert(num)switch语句（了解）使用场景： 适合于有多个条件的时候，也属于分支语句，大部分情况下和 if多分支语句 功能相同\n注意：\n\nswitch case语句一般用于等值判断, if适合于区间判断\nswitchcase一般需要配合break关键字使用 没有break会造成case穿透\nif 多分支语句开发要比switch更重要，使用也更多\n\n例如：\njs// switch分支语句\n// 1. 语法\n// switch (表达式) &#123;\n//   case 值1:\n//     代码1\n//     break\n\n//   case 值2:\n//     代码2\n//     break\n//   ...\n//   default:\n//     代码n\n// &#125;\n\n\n  switch (2) &#123;\n    case 1:\n    console.log(&#39;您选择的是1&#39;)\n    break  // 退出switch\n    case 2:\n    console.log(&#39;您选择的是2&#39;)\n    break  // 退出switch\n    case 3:\n    console.log(&#39;您选择的是3&#39;)\n    break  // 退出switch\n    default:\n    console.log(&#39;没有符合条件的&#39;)\n  &#125;断点调试作用：学习时可以帮助更好的理解代码运行，工作时可以更快找到bug\n浏览器打开调试界面\n\n按F12打开开发者工具\n点到源代码一栏 （ sources ）\n选择代码文件\n\n断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来\n循环语句使用场景：重复执行 指定的一段代码，比如我们想要输出10次 ‘我学的很棒’\n学习路径：\n1.while循环\n2.for 循环（重点）\nwhile循环while :  在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。\n语法：\njswhile (条件表达式) &#123;\n   // 循环体    \n&#125;例如：\njs// while循环: 重复执行代码\n\n// 1. 需求: 利用循环重复打印3次 &#39;月薪过万不是梦，毕业时候见英雄&#39;\nlet i = 1\nwhile (i &lt;= 3) &#123;\n  document.write(&#39;月薪过万不是梦，毕业时候见英雄~&lt;br&gt;&#39;)\n  i++   // 这里千万不要忘了变量自增否则造成死循环\n&#125;循环三要素：\n1.初始值 （经常用变量）\n2.终止条件\n3.变量的变化量\n例如：\njs\n  // // 1. 变量的起始值\n  // let i = 1\n  // // 2. 终止条件\n  // while (i &lt;= 3) &#123;\n  //   document.write(&#39;我要循环三次 &lt;br&gt;&#39;)\n  //   // 3. 变量的变化量\n  //   i++\n  // &#125;\n  // 1. 变量的起始值\n  let end = +prompt(&#39;请输入次数:&#39;)\nlet i = 1\n// 2. 终止条件\nwhile (i &lt;= end) &#123;\n  document.write(&#39;我要循环三次 &lt;br&gt;&#39;)\n  // 3. 变量的变化量\n  i++\n&#125;中止循环break   中止整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用（提高效率）  \ncontinue  中止本次循环，一般用于排除或者跳过某一个选项的时候\njs\n    // let i = 1\n    // while (i &lt;= 5) &#123;\n    //   console.log(i)\n    //   if (i === 3) &#123;\n    //     break  // 退出循环\n    //   &#125;\n    //   i++\n\n    // &#125;\n\n\n    let i = 1\n    while (i &lt;= 5) &#123;\n      if (i === 3) &#123;\n        i++\n        continue\n      &#125;\n      console.log(i)\n      i++\n\n    &#125;无限循环1.while(true) 来构造“无限”循环，需要使用break退出循环。（常用）\n2.for(;;) 也可以来构造“无限”循环，同样需要使用break退出循环。\njs// 无限循环  \n// 需求： 页面会一直弹窗询问你爱我吗？\n// (1). 如果用户输入的是 &#39;爱&#39;，则退出弹窗\n// (2). 否则一直弹窗询问\n\n// 1. while(true) 无限循环\n// while (true) &#123;\n//   let love = prompt(&#39;你爱我吗?&#39;)\n//   if (love === &#39;爱&#39;) &#123;\n//     break\n//   &#125;\n// &#125;\n\n// 2. for(;;) 无限循环\nfor (; ;) &#123;\n  let love = prompt(&#39;你爱我吗?&#39;)\n  if (love === &#39;爱&#39;) &#123;\n    break\n  &#125;\n&#125;综合案例-ATM存取款机\n分析：\n①：提示输入框写到循环里面（无限循环）\n②：用户输入4则退出循环 break\n③：提前准备一个金额预先存储一个数额 money\n④：根据输入不同的值，做不同的操作\n​     (1)  取钱则是减法操作， 存钱则是加法操作，查看余额则是直接显示金额\n​     (2) 可以使用 if else if 多分支 来执行不同的操作\n完整代码：\njs\n  // 1. 开始循环 输入框写到 循环里面\n  // 3. 准备一个总的金额\n  let money = 100\nwhile (true) &#123;\n  let re = +prompt(`\n请您选择操作：\n1.存钱\n2.取钱\n3.查看余额\n4.退出\n`)\n  // 2. 如果用户输入的 4 则退出循环， break  写到if 里面，没有写到switch里面， 因为4需要break退出循环\n  if (re === 4) &#123;\n    break\n  &#125;\n  // 4. 根据输入做操作\n  switch (re) &#123;\n    case 1:\n      // 存钱\n      let cun = +prompt(&#39;请输入存款金额&#39;)\n      money = money + cun\n      break\n      case 2:\n      // 存钱\n      let qu = +prompt(&#39;请输入取款金额&#39;)\n      money = money - qu\n      break\n      case 3:\n      // 存钱\n      alert(`您的银行卡余额是$&#123;money&#125;`)\n      break\n  &#125;\n&#125;if 多分支语句和 switch的区别\n共同点\n\n都能实现多分支选择， 多选1 \n大部分情况下可以互换\n\n\n区别：\n\nswitch…case语句通常处理case为比较确定值的情况，而if…else…语句更加灵活，通常用于范围判断(大于，等于某个范围)。\nswitch 语句进行判断后直接执行到程序的语句，效率更高，而if…else语句有几种判断条件，就得判断多少次\nswitch 一定要注意 必须是 &#x3D;&#x3D;&#x3D;  全等，一定注意 数据类型，同时注意break否则会有穿透效果\n结论：\n当分支比较少时，if…else语句执行效率高。\n当分支比较多时，switch语句执行效率高，而且结构更清晰。\n\n\n\n\n\nfor 语句\n\n\n\n\n\n\n\n\n掌握 for 循环语句，让程序具备重复执行能力\nfor 是 JavaScript 提供的另一种循环控制的话句，它和 while 只是语法上存在差异。\nfor语句的基本使用\n实现循环的 3 要素\n\njs\n  // 1. 语法格式\n  // for(起始值; 终止条件; 变化量) &#123;\n  //   // 要重复执行的代码\n  // &#125;\n\n  // 2. 示例：在网页中输入标题标签\n  // 起始值为 1\n  // 变化量 i++\n  // 终止条件 i &lt;= 6\n  for(let i = 1; i &lt;= 6; i++) &#123;\n    document.write(`&lt;h$&#123;i&#125;&gt;循环控制，即重复执行&lt;h$&#123;i&#125;&gt;`)\n  &#125;\n变化量和死循环，for 循环和 while 一样，如果不合理设置增量和终止条件，便会产生死循环。\n\n跳出和终止循环\n\n\njs\n    // 1. continue \n    for (let i = 1; i &lt;= 5; i++) &#123;\n        if (i === 3) &#123;\n            continue  // 结束本次循环，继续下一次循环\n        &#125;\n        console.log(i)\n    &#125;\n    // 2. break\n    for (let i = 1; i &lt;= 5; i++) &#123;\n        if (i === 3) &#123;\n            break  // 退出结束整个循环\n        &#125;\n        console.log(i)\n    &#125;结论：\n\nJavaScript 提供了多种语句来实现循环控制，但无论使用哪种语句都离不开循环的3个特征，即起始值、变化量、终止条件，做为初学者应着重体会这3个特征，不必过多纠结三种语句的区别。\n起始值、变化量、终止条件，由开发者根据逻辑需要进行设计，规避死循环的发生。\n当如果明确了循环的次数的时候推荐使用for循环,当不明确循环的次数的时候推荐使用while循环\n\n\n\n\n\n\n\n\n\n\n注意：for 的语法结构更简洁，故 for 循环的使用频次会更多。\n循环嵌套利用循环的知识来对比一个简单的天文知识，我们知道地球在自转的同时也在围绕太阳公转，如果把自转和公转都看成是循环的话，就相当于是循环中又嵌套了另一个循环。\n\n实际上 JavaScript 中任何一种循环语句都支持循环的嵌套，如下代码所示：\n\njs// 1. 外面的循环 记录第n天 \nfor (let i = 1; i &lt; 4; i++) &#123;\n    document.write(`第$&#123;i&#125;天 &lt;br&gt;`)\n    // 2. 里层的循环记录 几个单词\n    for (let j = 1; j &lt; 6; j++) &#123;\n        document.write(`记住第$&#123;j&#125;个单词&lt;br&gt;`)\n    &#125;\n&#125;记住，外层循环循环一次，里层循环循环全部\n倒三角js // 外层打印几行\nfor (let i = 1; i &lt;= 5; i++) &#123;\n    // 里层打印几个星星\n    for (let j = 1; j &lt;= i; j++) &#123;\n        document.write(&#39;★&#39;)\n    &#125;\n    document.write(&#39;&lt;br&gt;&#39;)\n&#125; \n九九乘法表样式css\ncssspan &#123;\n    display: inline-block;\n    width: 100px;\n    padding: 5px 10px;\n    border: 1px solid pink;\n    margin: 2px;\n    border-radius: 5px;\n    box-shadow: 2px 2px 2px rgba(255, 192, 203, .4);\n    background-color: rgba(255, 192, 203, .1);\n    text-align: center;\n    color: hotpink;\n&#125;javascript \njs // 外层打印几行\nfor (let i = 1; i &lt;= 9; i++) &#123;\n    // 里层打印几个星星\n    for (let j = 1; j &lt;= i; j++) &#123;\n        // 只需要吧 ★ 换成  1 x 1 = 1   \n        document.write(`\n        &lt;div&gt; $&#123;j&#125; x $&#123;i&#125; = $&#123;j * i&#125; &lt;/div&gt;\n     `)\n    &#125;\n    document.write(&#39;&lt;br&gt;&#39;)\n&#125;\n数组\n\n\n\n\n\n\n\n\n知道什么是数组及其应用的场景，掌握数组声明及访问的语法。\n数组是什么？数组：(Array)是一种可以按顺序保存数据的数据类型\n使用场景：如果有多个数据可以用数组保存起来，然后放到一个变量中，管理非常方便\n数组的基本使用定义数组和数组单元html&lt;script&gt;\n  // 1. 语法，使用 [] 来定义一个空数组\n  // 定义一个空数组，然后赋值给变量 classes\n  // let classes = [];\n\n  // 2. 定义非空数组\n  let classes = [&#39;小明&#39;, &#39;小刚&#39;, &#39;小红&#39;, &#39;小丽&#39;, &#39;小米&#39;]\n&lt;/script&gt;通过 [] 定义数组，数据中可以存放真正的数据，如小明、小刚、小红等这些都是数组中的数据，我们这些数据称为数组单元，数组单元之间使用英文逗号分隔。\n访问数组和数组索引使用数组存放数据并不是最终目的，关键是能够随时的访问到数组中的数据（单元）。其实 JavaScript 为数组中的每一个数据单元都编了号，通过数据单元在数组中的编号便可以轻松访问到数组中的数据单元了。\n我们将数据单元在数组中的编号称为索引值，也有人称其为下标。\n索引值实际是按着数据单元在数组中的位置依次排列的，注意是从 0 开始的，如下图所示：\n\n观察上图可以数据单元【小明】对应的索引值为【0】，数据单元【小红】对应的索引值为【2】\njs\n  let classes = [&#39;小明&#39;, &#39;小刚&#39;, &#39;小红&#39;, &#39;小丽&#39;, &#39;小米&#39;]\n  \n  // 1. 访问数组，语法格式为：变量名[索引值]\n  document.write(classes[0]) // 结果为：小明\n  document.write(classes[1]) // 结果为：小刚\n  document.write(classes[4]) // 结果为：小米\n  \n  // 2. 通过索引值还可以为数组单重新赋值\n  document.write(classes[3]) // 结果为：小丽\n  // 重新为索引值为 3 的单元赋值\n  classes[3] = &#39;小小丽&#39;\n  document.wirte(classes[3]); // 结果为： 小小丽数据单元值类型数组做为数据的集合，它的单元值可以是任意数据类型\njs\n  // 6. 数组单值类型可以是任意数据类型\n\n  // a) 数组单元值的类型为字符类型\n  let list = [&#39;HTML&#39;, &#39;CSS&#39;, &#39;JavaScript&#39;]\n  // b) 数组单元值的类型为数值类型\n  let scores = [78, 84, 70, 62, 75]\n  // c) 混合多种类型\n  let mixin = [true, 1, false, &#39;hello&#39;]数组长度属性重申一次，数组在 JavaScript 中并不是新的数据类型，它属于对象类型。\njs\n  // 定义一个数组\n  let arr = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n  // 数组对应着一个 length 属性，它的含义是获取数组的长度\n  console.log(arr.length) // 3操作数组数组做为对象数据类型，不但有 length 属性可以使用，还提供了许多方法：\n\npush 动态向数组的尾部添加一个单元\nunshit 动态向数组头部添加一个单元\npop 删除最后一个单元\nshift 删除第一个单元\nsplice 动态删除任意单元\n\n使用以上4个方法时，都是直接在原数组上进行操作，即成功调任何一个方法，原数组都跟着发生相应的改变。并且在添加或删除单元时 length 并不会发生错乱。\njs\n  // 定义一个数组\n  let arr = [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n\n  // 1. push 动态向数组的尾部添加一个单元\n  arr.push(&#39;Nodejs&#39;)\n  console.log(arr)\n  arr.push(&#39;Vue&#39;)\n\n  // 2. unshit 动态向数组头部添加一个单元\n  arr.unshift(&#39;VS Code&#39;)\n  console.log(arr)\n\n  // 3. splice 动态删除任意单元\n  arr.splice(2, 1) // 从索引值为2的位置开始删除1个单元\n  console.log(arr)\n\n  // 4. pop 删除最后一个单元\n  arr.pop()\n  console.log(arr)\n\n  // 5. shift 删除第一个单元\n  arr.shift()\n  console.log(arr)函数\n\n\n\n\n\n\n\n\n理解函数的封装特性，掌握函数的语法规则\n声明和调用函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于精简代码方便复用。\n声明（定义）声明（定义）一个完整函数包括关键字、函数名、形式参数、函数体、返回值5个部分\n\n调用声明（定义）的函数必须调用才会真正被执行，使用 () 调用函数。\njs\n    // 声明（定义）了最简单的函数，既没有形式参数，也没有返回值\n    function sayHi() &#123;\n      console.log(&#39;嗨~&#39;)\n    &#125;\n    // 函数调用，这些函数体内的代码逻辑会被执行\n    // 函数名()\n        \n    sayHi()\n    // 可以重复被调用，多少次都可以\n    sayHi()\n\n\n\n\n\n\n\n\n注：函数名的命名规则与变量是一致的，并且尽量保证函数名的语义。\n小案例： 小星星\njs\n        // 函数声明\n        function sayHi() &#123;\n            // document.write(&#39;hai~&#39;)\n            document.write(`*&lt;br&gt;`)\n            document.write(`**&lt;br&gt;`)\n            document.write(`***&lt;br&gt;`)\n            document.write(`****&lt;br&gt;`)\n            document.write(`*****&lt;br&gt;`)\n            document.write(`******&lt;br&gt;`)\n            document.write(`*******&lt;br&gt;`)\n            document.write(`********&lt;br&gt;`)\n            document.write(`*********&lt;br&gt;`)\n        &#125;\n        // 函数调用\n        sayHi()\n        sayHi()\n        sayHi()\n        sayHi()\n        sayHi()参数通过向函数传递参数，可以让函数更加灵活多变，参数可以理解成是一个变量。\n声明（定义）一个功能为打招呼的函数\n\n传入数据列表\n声明这个函数需要传入几个数据\n多个数据用逗号隔开\n\njs\n    // 声明（定义）一个功能为打招呼的函数\n    // function sayHi() &#123;\n    //   console.log(&#39;嗨~&#39;)\n    // &#125;\n    // 调用函数\n    // sayHi()\n    \n\n    // 这个函数似乎没有什么价值，除非能够向不同的人打招呼\n    // 这就需要借助参数来实现了\n    function sayHi(name) &#123;\n      // 参数 name 可以被理解成是一个变量\n      console.log(name)\n      console.log(&#39;嗨~&#39; + name)\n    &#125;\n\n    // 调用 sayHi 函数，括号中多了 &#39;小明&#39;\n    // 这时相当于为参数 name 赋值了\n    sayHi(&#39;小明&#39;)// 结果为 小明\n\n    // 再次调用 sayHi 函数，括号中多了 &#39;小红&#39;\n    // 这时相当于为参数 name 赋值了\n    sayHi(&#39;小红&#39;) // 结果为 小红总结：\n\n声明（定义）函数时的形参没有数量限制，当有多个形参时使用 , 分隔\n调用函数传递的实参要与形参的顺序一致\n\n形参和实参形参：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）\n实参：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）\n形参可以理解为是在这个函数内声明的变量（比如 num1 &#x3D; 10）实参可以理解为是给这个变量赋值\n开发中尽量保持形参和实参个数一致\njs\n    // 声明（定义）一个计算任意两数字和的函数\n    // 形参 x 和 y 分别表示任意两个数字，它们是两个变量\n    function count(x, y) &#123;\n      console.log(x + y);\n    &#125;\n    // 调用函数，传入两个具体的数字做为实参\n    // 此时 10 赋值给了形参 x\n    // 此时 5  赋值给了形参 y\n    count(10, 5); // 结果为 15返回值函数的本质是封装（包裹），函数体内的逻辑执行完毕后，函数外部如何获得函数内部的执行结果呢？要想获得函数内部逻辑的执行结果，需要通过 return 这个关键字，将内部执行结果传递到函数外部，这个被传递到外部的结果就是返回值。\njs\n    // 定义求和函数\n    function count(a, b) &#123;\n      let s = a + b\n      // s 即为 a + b 的结果\n      // 通过 return 将 s 传递到外部\n      return s\n    &#125;\n\n    // 调用函数，如果一个函数有返回值\n    // 那么可将这个返回值赋值给外部的任意变量\n    let total = count(5, 12)总结：\n\n在函数体中使用return 关键字能将内部的执行结果交给函数外部使用\n函数内部只能出现1 次 return，并且 return 下一行代码不会再被执行，所以return 后面的数据不要换行写\nreturn会立即结束当前函数\n函数可以没有return，这种情况默认返回值为 undefined\n\n作用域通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。\n作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。\n全局作用域作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件\n处于全局作用域内的变量，称为全局变量\n局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。\n处于局部作用域内的变量称为局部变量\n\n\n\n\n\n\n\n\n\n如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐\n但是有一种情况，函数内部的形参可以看做是局部变量。\n匿名函数函数可以分为具名函数和匿名函数\n匿名函数：没有名字的函数,无法直接使用。\n函数表达式js// 声明\nlet fn = function() &#123; \n   console.log(&#39;函数表达式&#39;)\n&#125;\n// 调用\nfn()立即执行函数js(function()&#123; xxx  &#125;)();\n(function()&#123;xxxx&#125;());\n\n\n\n\n\n\n\n\n无需调用，立即执行，其实本质已经调用了\n多个立即执行函数之间用分号隔开\n​\t\t在能够访问到的情况下 先局部 局部没有在找全局\n对象\n\n\n\n\n\n\n\n\n对象是 JavaScript 数据类型的一种，之前已经学习了数值类型、字符串类型、布尔类型、undefined。对象数据类型可以被理解成是一种数据集合。它由属性和方法两部分构成。\n语法声明一个对象类型的变量与之前声明一个数值或字符串类型的变量没有本质上的区别。\njs\n    // 声明字符串类型变量\n    let str = &#39;hello world!&#39;\n    \n    // 声明数值类型变量\n    let num = 199\n\n    // 声明对象类型变量，使用一对花括号\n    // user 便是一个对象了，目前它是一个空对象\n    let user = &#123;&#125;属性和访问数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。\n\n属性都是成 对出现的，包括属性名和值，它们之间使用英文 : 分隔\n多个属性之间使用英文 , 分隔\n属性就是依附在对象上的变量\n属性名可以使用 &quot;&quot; 或 &#39;&#39;，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\n\njs\n    // 通过对象描述一个人的数据信息\n    // person 是一个对象，它包含了一个属性 name\n    // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔\n    let person = &#123;\n      name: &#39;小明&#39;, // 描述人的姓名\n      age: 18, // 描述人的年龄\n      stature: 185, // 描述人的身高\n      gender: &#39;男&#39;, // 描述人的性别\n    &#125;声明对象，并添加了若干属性后，可以使用 . 或 [] 获得对象中属性对应的值，我称之为属性访问。\njs\n    // 通过对象描述一个人的数据信息\n    // person 是一个对象，它包含了一个属性 name\n    // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔\n    let person = &#123;\n      name: &#39;小明&#39;, // 描述人的姓名\n      age: 18, // 描述人的年龄\n      stature: 185, // 描述人的身高\n      gender: &#39;男&#39;, // 描述人的性别\n    &#125;;\n    \n    // 访问人的名字\n    console.log(person.name) // 结果为 小明\n    // 访问人性别\n    console.log(person.gender) // 结果为 男\n    // 访问人的身高\n    console.log(person[&#39;stature&#39;]) // 结果为 185\n   // 或者\n    console.log(person.stature) // 结果同为 185扩展：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活。\njs\n    // 声明一个空的对象（没有任何属性）\n    let user = &#123;&#125;\n    // 动态追加属性\n    user.name = &#39;小明&#39;\n    user[&#39;age&#39;] = 18\n    \n    // 动态添加与直接定义是一样的，只是语法上更灵活方法和调用数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。\n\n方法是由方法名和函数两部分构成，它们之间使用 : 分隔\n多个属性之间使用英文 , 分隔\n方法是依附在对象中的函数\n方法名可以使用 &quot;&quot; 或 &#39;&#39;，一般情况下省略，除非名称遇到特殊符号如空格、中横线等\n\njs\n    // 方法是依附在对象上的函数\n    let person = &#123;\n      name: &#39;小红&#39;,\n      age: 18,\n      // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔\n      singing: function () &#123;\n        console.log(&#39;两只老虎，两只老虎，跑的快，跑的快...&#39;)\n      &#125;,\n      run: function () &#123;\n        console.log(&#39;我跑的非常快...&#39;)\n      &#125;\n    &#125;声明对象，并添加了若干方法后，可以使用 . 或 [] 调用对象中函数，我称之为方法调用。\njs\n    // 方法是依附在对象上的函数\n    let person = &#123;\n      name: &#39;小红&#39;,\n      age: 18,\n      // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔\n      singing: function () &#123;\n        console.log(&#39;两只老虎，两只老虎，跑的快，跑的快...&#39;)\n      &#125;,\n      run: function () &#123;\n        console.log(&#39;我跑的非常快...&#39;)\n      &#125;\n    &#125;\n    \n    // 调用对象中 singing 方法\n    person.singing()\n    // 调用对象中的 run 方法\n    person.run()扩展：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活。\njs\n    // 声明一个空的对象（没有任何属性，也没有任何方法）\n    let user = &#123;&#125;\n    // 动态追加属性\n    user.name = &#39;小明&#39;\n    user.[&#39;age&#39;] = 18\n    \n    // 动态添加方法\n    user.move = function () &#123;\n      console.log(&#39;移动一点距离...&#39;)\n    &#125;注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的。\nnullnull 也是 JavaScript 中数据类型的一种，通常只用它来表示不存在的对象。使用 typeof 检测类型它的类型时，结果为 object。\n遍历对象jslet obj = &#123;\n    uname: &#39;pink&#39;\n&#125;\nfor(let k in obj) &#123;\n    // k 属性名  字符串  带引号    obj.&#39;uname&#39;     k ===  &#39;uname&#39;\n    // obj[k]  属性值    obj[&#39;uname&#39;]   obj[k]\n&#125;for in 不提倡遍历数组 因为 k 是 字符串  \n内置对象回想一下我们曾经使用过的 console.log，console其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 log，然后调用 log 这个方法，即 console.log()。\n除了 console 对象外，JavaScritp 还有其它的内置的对象\nMathMath 是 JavaScript 中内置的对象，称为数学对象，这个对象下即包含了属性，也包含了许多的方法。\n属性\nMath.PI，获取圆周率\n\njs// 圆周率\nconsole.log(Math.PI);方法\nMath.random，生成 0 到 1 间的随机数\n\njs// 0 ~ 1 之间的随机数, 包含 0 不包含 1\nMath.random()\nMath.ceil，数字向上取整\n\njs// 舍弃小数部分，整数部分加1\nMath.ceil(3.4)\nMath.floor，数字向下取整\n\njs// 舍弃小数部分，整数部分不变\nMath.floor(4.68)\nMath.round，四舍五入取整\n\njs// 取整，四舍五入原则\nMath.round(5.46539)\nMath.round(4.849)\nMath.max，在一组数中找出最大的\n\njs// 找出最大值\nMath.max(10, 21, 7, 24, 13)\nMath.min，在一组数中找出最小的\n\njs// 找出最小值\nMath.min(24, 18, 6, 19, 21)\nMath.pow，幂方法\n\njs// 求某个数的多少次方\nMath.pow(4, 2) // 求 4 的 2 次方\nMath.pow(2, 3) // 求 2 的 3 次方\nMath.sqrt，平方根\n\njs// 求某数的平方根\nMath.sqrt(16)数学对象提供了比较多的方法，这里不要求强记，通过演示数学对象的使用，加深对对象的理解。\n","slug":"前端/JavaScript/JavaScript基础","date":"2023-08-10T02:20:00.000Z","categories_index":"计算机,前端","tags_index":"笔记,JavaScript","author_index":"Honman"},{"id":"5dce2666999480e2fb451f13cc3dbea9","title":"Web APIs笔记","content":"Web APIs笔记跟着黑马程序员pink老师学完HTML、CSS、JavaScript 基础知识后开展了Web APIs的学习。那么一个重要的问题来了！！！到底Web APIs是什么？？？\nWeb API（Application Programming Interface，应用程序编程接口）是一种允许不同软件应用程序之间进行通信和交互的技术。它定义了一组规则和协议，用于在应用程序之间传递数据和执行特定的操作。 网络应用程序接口\n\n\n\n\n\n\n\n\n\n\n学习 JavaScript 时学习 API（Application Programming Interface，应用程序编程接口）是非常重要的，原因如下：\n\n功能扩展：API 允许你扩展 JavaScript 的功能，使其能够与其他应用程序或服务进行交互。通过使用 API，你可以访问和使用其他应用程序或服务提供的功能，而无需从头开始编写所有代码。这样可以节省时间和精力，加快开发速度。\n数据获取和处理：许多 API 提供了数据访问接口，允许你从服务器或其他数据源获取数据。这对于构建 Web 应用程序或移动应用程序来说非常有用。通过使用 API，你可以获取实时数据、用户信息、产品信息等，并在你的应用程序中进行处理和展示。\n互联网服务集成：API 允许你与各种互联网服务进行集成，如社交媒体平台、支付网关、地图服务等。通过与这些服务进行交互，你可以实现用户身份验证、支付功能、地理位置信息等。这样可以提供更丰富的用户体验，并增加你的应用程序的功能和吸引力。\n前端开发：在前端开发中，API 是与后端服务进行交互的关键。通过与后端 API 进行通信，你可以获取数据、提交表单、进行用户认证等。这对于构建动态和交互式的 Web 应用程序至关重要。\n学习资源丰富：学习 API 有助于你了解不同服务和平台提供的功能和技术。许多知名的互联网公司和服务提供商都提供了丰富的 API 文档和示例代码，以帮助开发人员学习和使用他们的服务。\n\n总之，学习 API 可以帮助你扩展 JavaScript 的功能、获取和处理数据、与其他服务进行集成，并提供更丰富的用户体验。它是现代 Web 开发中不可或缺的一部分，可以使你的应用程序更强大、更灵活。\n\n复习：\nsplice() 方法用于添加或删除数组中的元素。\n注意：这种方法会改变原始数组。\n\n删除数组：\n\nsplice(起始位置， 删除的个数)\njslet arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]\narr.splice(1,1) // 删除green元素\nconsole.log(arr) // [&#39;red, &#39;blue&#39;]\n添加元素\n\nsplice(起始位置，删除个数，添加数组元素)\njslet arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]\n//arr.splice(1, 0, &#39;pink&#39;) // 在索引号是1的位置添加 pink\n//console.log(arr) // [&#39;red&#39;, &#39;pink&#39;, &#39;green&#39;, &#39;blue&#39;]\narr.splice(1, 0, &#39;pink&#39;, &#39;hotpink&#39;) // 在索引号是1的位置添加 pink  hotpink\nconsole.log(arr) // [&#39;red&#39;, &#39;pink&#39;, &#39;hotpink&#39;, &#39;green&#39;, &#39;blue&#39;]Web APIs - 第1天笔记\n\n\n\n\n\n\n\n\n了解 DOM 的结构并掌握其基本的操作，体验 DOM 的在开发中的作用\n\n知道 ECMAScript 与 JavaScript 的关系\n了解 DOM 的相关概念及DOM 的本质是一个对象\n掌握查找节点的基本方法\n掌握节点属性和文本的操作\n能够使用间歇函数创建定时任务\n\n介绍\n\n\n\n\n\n\n\n\n知道 ECMAScript 与 JavaScript 的关系，Web APIs 是浏览器扩展的功能。\n严格意义上讲，我们在 JavaScript 阶段学习的知识绝大部分属于 ECMAScript 的知识体系，ECMAScript 简称 ES 它提供了一套语言标准规范，如变量、数据类型、表达式、语句、函数等语法规则都是由 ECMAScript 规定的。浏览器将 ECMAScript 大部分的规范加以实现，并且在此基础上又扩展一些实用的功能，这些被扩展出来的内容我们称为 Web APIs。\n\nECMAScript 运行在浏览器中然后再结合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 DOM 和 BOM。\n扩展阅读：ECMAScript 规范在不断的更新中，存在多个不同的版本，早期的版本号采用数字顺序编号如 ECMAScript3、ECMAScript5，后来由于更新速度较快便采用年份做为版本号，如 ECMAScript2017、ECMAScript2018 这种格式，ECMAScript6 是 2015 年发布的，常叫做 EMCAScript2015。\n关于 JavaScript 历史的扩展阅读。\n\n\n\n\n\n\n\n\n\n知道 DOM 相关的概念，建立对 DOM 的初步认识，学习 DOM 的基本操作，体会 DOM 的作用\nDOM（Document Object Model）是将整个 HTML 文档的每一个标签元素视为一个对象，这个对象下包含了许多的属性和方法，通过操作这些属性或者调用这些方法实现对 HTML 的动态更新，为实现网页特效以及用户交互提供技术支撑。\n简言之 DOM 是用来动态修改 HTML 的，其目的是开发网页特效及用户交互。\n观察一个小例子：\n\n上述的例子中当用户分分别点击【开始】或【结束】按钮后，通过右侧调试窗口可以观察到 html 标签的内容在不断的发生改变，这便是通过 DOM 实现的。\n概念DOM 树html&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;标题&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  文本\n  &lt;a href=&quot;&quot;&gt;链接名&lt;/a&gt;\n  &lt;div id=&quot;&quot; class=&quot;&quot;&gt;文本&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;如下图所示，将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树，文档树直观的体现了标签与标签之间的关系。\n\nDOM 节点节点是文档树的组成部分，每一个节点都是一个 DOM 对象，主要分为元素节点、属性节点、文本节点等。\n\n【元素节点】其实就是 HTML 标签，如上图中 head、div、body 等都属于元素节点。\n【属性节点】是指 HTML 标签中的属性，如上图中 a 标签的 href 属性、div 标签的 class 属性。\n【文本节点】是指 HTML 标签的文字内容，如 title 标签中的文字。\n【根节点】特指 html 标签。\n其它…\n\ndocumentdocument 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，document 是学习 DOM 的核心。\njs\n  // document 是内置的对象\n  // console.log(typeof document);\n\n  // 1. 通过 document 获取根节点\n  console.log(document.documentElement); // 对应 html 标签\n\n  // 2. 通过 document 节取 body 节点\n  console.log(document.body); // 对应 body 标签\n\n  // 3. 通过 document.write 方法向网页输出内容\n  document.write(&#39;Hello World!&#39;);上述列举了 document 对象的部分属性和方法，我们先对 document 有一个整体的认识。\n获取DOM对象\nquerySelector   满足条件的第一个元素\nquerySelectorAll  满足条件的元素集合 返回伪数组\n了解其他方式\ngetElementById\ngetElementsByTagName\n\n\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;DOM - 查找节点&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h3&gt;查找元素类型节点&lt;/h3&gt;\n  &lt;p&gt;从整个 DOM 树中查找 DOM 节点是学习 DOM 的第一个步骤。&lt;/p&gt;\n  &lt;ul&gt;\n      &lt;li&gt;元素&lt;/li&gt;\n      &lt;li&gt;元素&lt;/li&gt;\n      &lt;li&gt;元素&lt;/li&gt;\n      &lt;li&gt;元素&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;script&gt;\n      const p = document.querySelector(&#39;p&#39;)  // 获取第一个p元素\n      const lis = document.querySelectorAll(&#39;li&#39;)  // 获取第一个p元素\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;总结：\n\ndocument.getElementById 专门获取元素类型节点，根据标签的 id  属性查找\n任意 DOM 对象都包含 nodeType 属性，用来检检测节点类型\n\n操作元素内容通过修改 DOM 的文本内容，动态改变网页的内容。\n\ninnerText 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签不会被解析。\n\njs\n  // innerText 将文本内容添加/更新到任意标签位置\n  const intro = document.querySelector(&#39;.intro&#39;)\n  // intro.innerText = &#39;嗨~ 我叫李雷！&#39;\n  // intro.innerText = &#39;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#39;\n\ninnerHTML 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的标签会被解析。\n\njs\n  // innerHTML 将文本内容添加/更新到任意标签位置\n  const intro = document.querySelector(&#39;.intro&#39;)\n  intro.innerHTML = &#39;嗨~ 我叫韩梅梅！&#39;\n  intro.innerHTML = &#39;&lt;h4&gt;嗨~ 我叫韩梅梅！&lt;/h4&gt;&#39;\n总结：如果文本内容中包含 html 标签时推荐使用 innerHTML，否则建议使用 innerText 属性。\n操作元素属性有3种方式可以实现对属性的修改：\n常用属性修改\n直接能过属性名修改，最简洁的语法\n\njs\n  // 1. 获取 img 对应的 DOM 元素\n  const pic = document.querySelector(&#39;.pic&#39;)\n    // 2. 修改属性\n  pic.src = &#39;./images/lion.webp&#39;\n  pic.width = 400;\n  pic.alt = &#39;图片不见了...&#39;\n控制样式属性\n应用【修改样式】，通过修改行内样式 style 属性，实现对样式的动态修改。\n\n通过元素节点获得的 style 属性本身的数据类型也是对象，如 box.style.color、box.style.width 分别用来获取元素节点 CSS 样式的 color 和 width 的值。\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;练习 - 修改样式&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt;\n  &lt;script&gt;\n    // 获取 DOM 节点\n    const box = document.querySelector(&#39;.intro&#39;)\n    box.style.color = &#39;red&#39;\n    box.style.width = &#39;300px&#39;\n    // css 属性的 - 连接符与 JavaScript 的 减运算符\n    // 冲突，所以要改成驼峰法\n    box.style.backgroundColor = &#39;pink&#39;\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;任何标签都有 style 属性，通过 style 属性可以动态更改网页标签的样式，如要遇到 css 属性中包含字符 - 时，要将 - 去掉并将其后面的字母改成大写，如 background-color 要写成 box.style.backgroundColor\n\n操作类名(className) 操作CSS\n\n如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;练习 - 修改样式&lt;/title&gt;\n    &lt;style&gt;\n        .pink &#123;\n            background: pink;\n            color: hotpink;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;box&quot;&gt;随便一些文本内容&lt;/div&gt;\n  &lt;script&gt;\n    // 获取 DOM 节点\n    const box = document.querySelector(&#39;.intro&#39;)\n    box.className = &#39;pink&#39;\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n\n\n\n\n\n\n\n注意：\n1.由于class是关键字, 所以使用className去代替\n2.className是使用新值换旧值, 如果需要添加一个类,需要保留之前的类名\n\n通过 classList 操作类控制CSS\n\n为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名\nhtml\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        &#125;\n\n        .active &#123;\n            width: 300px;\n            height: 300px;\n            background-color: hotpink;\n            margin-left: 100px;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        // 1.获取元素\n        // let box = document.querySelector(&#39;css选择器&#39;)\n        let box = document.querySelector(&#39;div&#39;)\n        // add是个方法 添加  追加\n        // box.classList.add(&#39;active&#39;)\n        // remove() 移除 类\n        // box.classList.remove(&#39;one&#39;)\n        // 切换类\n        box.classList.toggle(&#39;one&#39;)\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;操作表单元素属性表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框\n正常的有属性有取值的跟其他的标签属性没有任何区别\n获取:DOM对象.属性名\n设置:DOM对象.属性名&#x3D; 新值\nhtml\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;input type=&quot;text&quot; value=&quot;请输入&quot;&gt;\n    &lt;button disabled&gt;按钮&lt;/button&gt;\n    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt;\n    &lt;script&gt;\n        // 1. 获取元素\n        let input = document.querySelector(&#39;input&#39;)\n        // 2. 取值或者设置值  得到input里面的值可以用 value\n        // console.log(input.value)\n        input.value = &#39;小米手机&#39;\n        input.type = &#39;password&#39;\n\n        // 2. 启用按钮\n        let btn = document.querySelector(&#39;button&#39;)\n        // disabled 不可用   =  false  这样可以让按钮启用\n        btn.disabled = false\n        // 3. 勾选复选框\n        let checkbox = document.querySelector(&#39;.agree&#39;)\n        checkbox.checked = false\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;自定义属性标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected\n自定义属性：\n在html5中推出来了专门的data-自定义属性  \n在标签上一律以data-开头\n在DOM对象上一律以dataset对象方式获取\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n\n&lt;/head&gt;\n\n&lt;body&gt;\n   &lt;div data-id=&quot;1&quot;&gt; 自定义属性 &lt;/div&gt;\n    &lt;script&gt;\n        // 1. 获取元素\n        let div = document.querySelector(&#39;div&#39;)\n        // 2. 获取自定义属性值\n         console.log(div.dataset.id)\n      \n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;间歇函数\n\n\n\n\n\n\n\n\n知道间歇函数的作用，利用间歇函数创建定时任务。\nsetInterval 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数。\njs\n  // 1. 定义一个普通函数\n  function repeat() &#123;\n    console.log(&#39;不知疲倦的执行下去....&#39;)\n  &#125;\n\n  // 2. 使用 setInterval 调用 repeat 函数\n  // 间隔 1000 毫秒，重复调用 repeat\n  setInterval(repeat, 1000)Web APIs - 第2天笔记\n\n\n\n\n\n\n\n\n学会通过为DOM注册事件来实现可交互的网页特效。\n\n能够判断函数运行的环境并确字 this 所指代的对象\n理解事件的作用，知道应用事件的 3 个步骤\n\n\n\n\n\n\n\n\n\n\n学习会为 DOM 注册事件，实现简单可交互的网页特交。\n事件事件是编程语言中的术语，它是用来描述程序的行为或状态的，一旦行为或状态发生改变，便立即调用一个函数。\n例如：用户使用【鼠标点击】网页中的一个按钮、用户使用【鼠标拖拽】网页中的一张图片\n事件监听结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。\naddEventListener 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;事件监听&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h3&gt;事件监听&lt;/h3&gt;\n  &lt;p id=&quot;text&quot;&gt;为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。&lt;/p&gt;\n  &lt;button id=&quot;btn&quot;&gt;点击改变文字颜色&lt;/button&gt;\n  &lt;script&gt;\n    // 1. 获取 button 对应的 DOM 对象\n    const btn = document.querySelector(&#39;#btn&#39;)\n\n    // 2. 添加事件监听\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;等待事件被触发...&#39;)\n      // 改变 p 标签的文字颜色\n      let text = document.getElementById(&#39;text&#39;)\n      text.style.color = &#39;red&#39;\n    &#125;)\n\n    // 3. 只要用户点击了按钮，事件便触发了！！！\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;完成事件监听分成3个步骤：\n\n获取 DOM 元素\n通过 addEventListener 方法为 DOM 节点添加事件监听\n等待事件触发，如用户点击了某个按钮时便会触发 click 事件类型\n事件触发后，相对应的回调函数会被执行\n\n大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。\n事件类型click 译成中文是【点击】的意思，它的含义是监听（等着）用户鼠标的单击操作，除了【单击】还有【双击】dblclick\njs\n  // 双击事件类型\n  btn.addEventListener(&#39;dblclick&#39;, function () &#123;\n    console.log(&#39;等待事件被触发...&#39;);\n    // 改变 p 标签的文字颜色\n    const text = document.querySelector(&#39;.text&#39;)\n    text.style.color = &#39;red&#39;\n  &#125;)\n\n  // 只要用户双击击了按钮，事件便触发了！！！\n结论：【事件类型】决定了事件被触发的方式，如 click 代表鼠标单击，dblclick 代表鼠标双击。\n事件处理程序addEventListener 的第2个参数是函数，这个函数会在事件被触发时立即被调用，在这个函数中可以编写任意逻辑的代码，如改变 DOM 文本颜色、文本内容等。\njs\n  // 双击事件类型\n  btn.addEventListener(&#39;dblclick&#39;, function () &#123;\n    console.log(&#39;等待事件被触发...&#39;)\n    \n    const text = document.querySelector(&#39;.text&#39;)\n    // 改变 p 标签的文字颜色\n    text.style.color = &#39;red&#39;\n    // 改变 p 标签的文本内容\n    text.style.fontSize = &#39;20px&#39;\n  &#125;)\n结论：【事件处理程序】决定了事件触发后应该执行的逻辑。\n事件类型将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。\n鼠标事件鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。\n\n&#96;mouseenter 监听鼠标是否移入 DOM 元素\n\nhtml&lt;body&gt;\n  &lt;h3&gt;鼠标事件&lt;/h3&gt;\n  &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt;\n  &lt;hr&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 需要事件监听的 DOM 元素\n    const box = document.querySelector(&#39;.box&#39;);\n\n    // 监听鼠标是移入当前 DOM 元素\n    box.addEventListener(&#39;mouseenter&#39;, function () &#123;\n      // 修改文本内容\n      this.innerText = &#39;鼠标移入了...&#39;;\n      // 修改光标的风格\n      this.style.cursor = &#39;move&#39;;\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;\n&#96;mouseleave 监听鼠标是否移出 DOM 元素\n\nhtml&lt;body&gt;\n  &lt;h3&gt;鼠标事件&lt;/h3&gt;\n  &lt;p&gt;监听与鼠标相关的操作&lt;/p&gt;\n  &lt;hr&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 需要事件监听的 DOM 元素\n    const box = document.querySelector(&#39;.box&#39;);\n\n    // 监听鼠标是移出当前 DOM 元素\n    box.addEventListener(&#39;mouseleave&#39;, function () &#123;\n      // 修改文本内容\n      this.innerText = &#39;鼠标移出了...&#39;;\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;键盘事件keydown   键盘按下触发keyup   键盘抬起触发\n焦点事件focus  获得焦点\nblur 失去焦点\n文本框输入事件input  \n事件对象任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。\nhtml&lt;body&gt;\n  &lt;h3&gt;事件对象&lt;/h3&gt;\n  &lt;p&gt;任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。&lt;/p&gt;\n  &lt;hr&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;script&gt;\n    // 获取 .box 元素\n    const box = document.querySelector(&#39;.box&#39;)\n\n    // 添加事件监听\n    box.addEventListener(&#39;click&#39;, function (e) &#123;\n      console.log(&#39;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#39;);\n\n      // 事件回调函数的第1个参数即所谓的事件对象\n      console.log(e)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 event、ev 、ev 。\n接下来简单看一下事件对象中包含了哪些有用的信息：\n\nev.type 当前事件的类型\nev.clientX/Y 光标相对浏览器窗口的位置\nev.offsetX/Y 光标相于当前 DOM 元素的位置\n\n注：在事件回调函数内部通过 window.event 同样可以获取事件对象。\n环境对象\n\n\n\n\n\n\n\n\n能够分析判断函数运行在不同环境中 this 所指代的对象。\n环境对象指的是函数内部特殊的变量 this ，它代表着当前函数运行时所处的环境。\njs\n  // 声明函数\n  function sayHi() &#123;\n    // this 是一个变量\n    console.log(this);\n  &#125;\n\n  // 声明一个对象\n  let user = &#123;\n    name: &#39;张三&#39;,\n    sayHi: sayHi // 此处把 sayHi 函数，赋值给 sayHi 属性\n  &#125;\n  \n  let person = &#123;\n    name: &#39;李四&#39;,\n    sayHi: sayHi\n  &#125;\n\n  // 直接调用\n  sayHi() // window\n  window.sayHi() // window\n\n  // 做为对象方法调用\n  user.sayHi()// user\n    person.sayHi()// person结论：\n\nthis 本质上是一个变量，数据类型为对象\n函数的调用方式不同 this 变量的值也不同\n【谁调用 this 就是谁】是判断 this 值的粗略规则\n函数直接调用时实际上 window.sayHi() 所以 this 的值为 window\n\n回调函数如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。\njs\n  // 声明 foo 函数\n  function foo(arg) &#123;\n    console.log(arg);\n  &#125;\n\n  // 普通的值做为参数\n  foo(10);\n  foo(&#39;hello world!&#39;);\n  foo([&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]);\n\n  function bar() &#123;\n    console.log(&#39;函数也能当参数...&#39;);\n  &#125;\n  // 函数也可以做为参数！！！！\n  foo(bar);\n函数 bar 做参数传给了 foo 函数，bar 就是所谓的回调函数了！！！\n我们回顾一下间歇函数 setInterval \njs\n    function fn() &#123;\n    console.log(&#39;我是回调函数...&#39;);\n  &#125;\n  // 调用定时器\n  setInterval(fn, 1000);\nfn 函数做为参数传给了 setInterval ，这便是回调函数的实际应用了，结合刚刚学习的函数表达式上述代码还有另一种更常见写法。\njs\n  // 调用定时器，匿名函数做为参数\n  setInterval(function () &#123;\n    console.log(&#39;我是回调函数...&#39;);\n  &#125;, 1000);\n结论：\n\n回调函数本质还是函数，只不过把它当成参数使用\n使用匿名函数做为回调函数比较常见\n\nWeb APIs - 第3天笔记\n\n\n\n\n\n\n\n\n进一步学习 事件进阶，实现更多交互的网页特效，结合事件流的特征优化事件执行的效率\n\n掌握阻止事件冒泡的方法\n理解事件委托的实现原理\n\n事件流事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。\n\n如上图所示，任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。\n简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。\n捕获和冒泡了解了什么是事件流之后，我们来看事件流是如何影响事件执行的：\nhtml&lt;body&gt;\n  &lt;h3&gt;事件流&lt;/h3&gt;\n  &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt;\n  &lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n      &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n    // 获取嵌套的3个节点\n    const outer = document.querySelector(&#39;.outer&#39;);\n    const inner = document.querySelector(&#39;.inner&#39;);\n    const child = document.querySelector(&#39;.child&#39;);\n        \n    // html 元素添加事件\n    document.documentElement.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;html...&#39;)\n    &#125;)\n        \n    // body 元素添加事件\n    document.body.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;body...&#39;)\n    &#125;)\n\n    // 外层的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;)\n    \n    // 中间的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;inner...&#39;)\n    &#125;)\n    \n    // 内层的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;child...&#39;)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？\n结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。\n再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。\n如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。\n如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。\nhtml&lt;body&gt;\n  &lt;h3&gt;事件流&lt;/h3&gt;\n  &lt;p&gt;事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。&lt;/p&gt;\n  &lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n    // 获取嵌套的3个节点\n    const outer = document.querySelector(&#39;.outer&#39;)\n    const inner = document.querySelector(&#39;.inner&#39;)\n\n    // 外层的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;, true) // true 表示在捕获阶段执行事件\n    \n    // 中间的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;inner...&#39;)\n    &#125;, true)\n  &lt;/script&gt;\n&lt;/body&gt;结论：\n\naddEventListener 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发\naddEventListener 第3个参数为  true 表示捕获阶段触发，false 表示冒泡阶段触发，默认值为 false\n事件流只会在父子元素具有相同事件类型时才会产生影响\n绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获）\n\n阻止冒泡阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。\nhtml&lt;body&gt;\n  &lt;h3&gt;阻止冒泡&lt;/h3&gt;\n  &lt;p&gt;阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。&lt;/p&gt;\n  &lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n      &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script&gt;\n    // 获取嵌套的3个节点\n    const outer = document.querySelector(&#39;.outer&#39;)\n    const inner = document.querySelector(&#39;.inner&#39;)\n    const child = document.querySelector(&#39;.child&#39;)\n\n    // 外层的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;)\n\n    // 中间的盒子\n    inner.addEventListener(&#39;click&#39;, function (ev) &#123;\n      console.log(&#39;inner...&#39;)\n\n      // 阻止事件冒泡\n      ev.stopPropagation()\n    &#125;)\n\n    // 内层的盒子\n    child.addEventListener(&#39;click&#39;, function (ev) &#123;\n      console.log(&#39;child...&#39;)\n\n      // 借助事件对象，阻止事件向上冒泡\n      ev.stopPropagation()\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;结论：事件对象中的 ev.stopPropagation 方法，专门用来阻止事件冒泡。\n\n\n\n\n\n\n\n\n\n鼠标经过事件：\nmouseover 和 mouseout 会有冒泡效果\nmouseenter  和 mouseleave   没有冒泡效果 (推荐)\n事件委托事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。\n大量的事件监听是比较耗费性能的，如下代码所示\njs\n  // 假设页面中有 10000 个 button 元素\n  const buttons = document.querySelectorAll(&#39;table button&#39;);\n\n  for(let i = 0; i &lt;= buttons.length; i++) &#123;\n    // 为 10000 个 button 元素添加了事件\n    buttons.addEventListener(&#39;click&#39;, function () &#123;\n      // 省略具体执行逻辑...\n    &#125;)\n  &#125;利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示：\njs\n  // 假设页面中有 10000 个 button 元素\n  let buttons = document.querySelectorAll(&#39;table button&#39;);\n  \n  // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table\n  let parents = document.querySelector(&#39;table&#39;);\n  parents.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(&#39;点击任意子元素都会触发事件...&#39;);\n  &#125;)我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？\n\n事件对象中的属性 target 或 srcElement属性表示真正触发事件的元素，它是一个元素类型的节点。\njs\n  // 假设页面中有 10000 个 button 元素\n  const buttons = document.querySelectorAll(&#39;table button&#39;)\n  \n  // 假设上述的 10000 个 buttom 元素共同的祖先元素是 table\n  const parents = document.querySelector(&#39;table&#39;)\n  parents.addEventListener(&#39;click&#39;, function (ev) &#123;\n    // console.log(ev.target);\n    // 只有 button 元素才会真正去执行逻辑\n    if(ev.target.tagName === &#39;BUTTON&#39;) &#123;\n      // 执行的逻辑\n    &#125;\n  &#125;)\n优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！\n其他事件页面加载事件加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件\n有些时候需要等页面资源全部处理完了做一些事情\n事件名：load\n监听页面所有资源加载完毕：\njswindow.addEventListener(&#39;load&#39;, function() &#123;\n    // xxxxx\n&#125;)元素滚动事件滚动条在滚动的时候持续触发的事件\njswindow.addEventListener(&#39;scroll&#39;, function() &#123;\n    // xxxxx\n&#125;)页面尺寸事件会在窗口尺寸改变的时候触发事件：\njswindow.addEventListener(&#39;resize&#39;, function() &#123;\n    // xxxxx\n&#125;)元素尺寸与位置获取元素的自身宽高、包含元素自身设置的宽高、padding、border\noffsetWidth和offsetHeight  \n获取出来的是数值,方便计算\n注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0\nWeb APIs - 第4天笔记\n\n\n\n\n\n\n\n\n进一步学习 DOM 相关知识，实现可交互的网页特效\n\n能够插入、删除和替换元素节点\n能够依据元素节点关系查找节点\n\n日期对象掌握 Date 日期对象的使用，动态获取当前计算机的时间。\nECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。\n实例化js  // 1. 实例化\n  // const date = new Date(); // 系统默认时间\n  const date = new Date(&#39;2020-05-01&#39;) // 指定时间\n  // date 变量即所谓的时间对象\n\n  console.log(typeof date)方法js // 1. 实例化\n const date = new Date();\n // 2. 调用时间对象方法\n // 通过方法分别获取年、月、日，时、分、秒\n const year = date.getFullYear(); // 四位年份\n const month = date.getMonth(); // 0 ~ 11getFullYear 获取四位年份\ngetMonth 获取月份，取值为 0 ~ 11\ngetDate 获取月份中的每一天，不同月份取值也不相同\ngetDay 获取星期，取值为 0 ~ 6\ngetHours 获取小时，取值为 0 ~ 23\ngetMinutes 获取分钟，取值为 0 ~ 59\ngetSeconds 获取秒，取值为 0 ~ 59\n时间戳时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。\n注：ECMAScript 中时间戳是以毫秒计的。\njs  // 1. 实例化\n  const date = new Date()\n  // 2. 获取时间戳\n  console.log(date.getTime())\n    // 还有一种获取时间戳的方法\n  console.log(+new Date())\n  // 还有一种获取时间戳的方法\n  console.log(Date.now())\n获取时间戳的方法，分别为 getTime 和 Date.now 和  +new Date()\nDOM 节点\n\n\n\n\n\n\n\n\n掌握元素节点创建、复制、插入、删除等操作的方法，能够依据元素节点的结构关系查找节点\n回顾之前 DOM 的操作都是针对元素节点的属性或文本的，除此之外也有专门针对元素节点本身的操作，如插入、复制、删除、替换等。\n插入节点在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点。\n如下代码演示：\nhtml&lt;body&gt;\n  &lt;h3&gt;插入节点&lt;/h3&gt;\n  &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt;\n  &lt;hr&gt;\n  &lt;!-- 普通盒子 --&gt;\n  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n  &lt;!-- 点击按钮向 box 盒子插入节点 --&gt;\n  &lt;button class=&quot;btn&quot;&gt;插入节点&lt;/button&gt;\n  &lt;script&gt;\n    // 点击按钮，在网页中插入节点\n    const btn = document.querySelector(&#39;.btn&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      // 1. 获得一个 DOM 元素节点\n      const p = document.createElement(&#39;p&#39;)\n      p.innerText = &#39;创建的新的p标签&#39;\n      p.className = &#39;info&#39;\n      \n      // 复制原有的 DOM 节点\n      const p2 = document.querySelector(&#39;p&#39;).cloneNode(true)\n      p2.style.color = &#39;red&#39;\n\n      // 2. 插入盒子 box 盒子\n      document.querySelector(&#39;.box&#39;).appendChild(p)\n      document.querySelector(&#39;.box&#39;).appendChild(p2)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;结论：\n\ncreateElement 动态创建任意 DOM 节点\n\ncloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点\n\nappendChild 在末尾（结束标签前）插入节点\n\n\n再来看另一种情形的代码演示：\nhtml&lt;body&gt;\n  &lt;h3&gt;插入节点&lt;/h3&gt;\n  &lt;p&gt;在现有 dom 结构基础上插入新的元素节点&lt;/p&gt;\n    &lt;hr&gt;\n  &lt;button class=&quot;btn1&quot;&gt;在任意节点前插入&lt;/button&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;/li&gt;\n    &lt;li&gt;CSS&lt;/li&gt;\n    &lt;li&gt;JavaScript&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;script&gt;\n    // 点击按钮，在已有 DOM 中插入新节点\n    const btn1 = document.querySelector(&#39;.btn1&#39;)\n    btn1.addEventListener(&#39;click&#39;, function () &#123;\n\n      // 第 2 个 li 元素\n      const relative = document.querySelector(&#39;li:nth-child(2)&#39;)\n\n      // 1. 动态创建新的节点\n      const li1 = document.createElement(&#39;li&#39;)\n      li1.style.color = &#39;red&#39;\n      li1.innerText = &#39;Web APIs&#39;\n\n      // 复制现有的节点\n      const li2 = document.querySelector(&#39;li:first-child&#39;).cloneNode(true)\n      li2.style.color = &#39;blue&#39;\n\n      // 2. 在 relative 节点前插入\n      document.querySelector(&#39;ul&#39;).insertBefore(li1, relative)\n      document.querySelector(&#39;ul&#39;).insertBefore(li2, relative)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;结论：\n\ncreateElement 动态创建任意 DOM 节点\n\ncloneNode 复制现有的 DOM 节点，传入参数 true 会复制所有子节点\n\ninsertBefore 在父节点中任意子节点之前插入新节点\n\n\n删除节点删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。\nhtml&lt;body&gt;\n  &lt;!-- 点击按钮删除节点 --&gt;\n  &lt;button&gt;删除节点&lt;/button&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;/li&gt;\n    &lt;li&gt;CSS&lt;/li&gt;\n    &lt;li&gt;Web APIs&lt;/li&gt;\n  &lt;/ul&gt;\n\n  &lt;script&gt;\n    const btn = document.querySelector(&#39;button&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      // 获取 ul 父节点\n      let ul = document.querySelector(&#39;ul&#39;)\n      // 待删除的子节点\n      let lis = document.querySelectorAll(&#39;li&#39;)\n\n      // 删除节点\n      ul.removeChild(lis[0])\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;结论：removeChild 删除节点时一定是由父子关系。\n查找节点DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点。\n父子关系html&lt;body&gt;\n  &lt;button class=&quot;btn1&quot;&gt;所有的子节点&lt;/button&gt;\n  &lt;!-- 获取 ul 的子节点 --&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;/li&gt;\n    &lt;li&gt;CSS&lt;/li&gt;\n    &lt;li&gt;JavaScript 基础&lt;/li&gt;\n    &lt;li&gt;Web APIs&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;script&gt;\n    const btn1 = document.querySelector(&#39;.btn1&#39;)\n    btn1.addEventListener(&#39;click&#39;, function () &#123;\n      // 父节点\n      const ul = document.querySelector(&#39;ul&#39;)\n\n      // 所有的子节点\n      console.log(ul.childNodes)\n      // 只包含元素子节点\n      console.log(ul.children)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;结论：\n\nchildNodes 获取全部的子节点，回车换行会被认为是空白文本节点\nchildren 只获取元素类型节点\n\nhtml&lt;body&gt;\n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td width=&quot;60&quot;&gt;序号&lt;/td&gt;\n      &lt;td&gt;课程名&lt;/td&gt;\n      &lt;td&gt;难度&lt;/td&gt;\n      &lt;td width=&quot;80&quot;&gt;操作&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;1&lt;/td&gt;\n      &lt;td&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/td&gt;\n      &lt;td&gt;初级&lt;/td&gt;\n      &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;2&lt;/td&gt;\n      &lt;td&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/td&gt;\n      &lt;td&gt;初级&lt;/td&gt;\n      &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;3&lt;/td&gt;\n      &lt;td&gt;&lt;span&gt;Web APIs&lt;/span&gt;&lt;/td&gt;\n      &lt;td&gt;中级&lt;/td&gt;\n      &lt;td&gt;&lt;button&gt;变色&lt;/button&gt;&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;\n  &lt;script&gt;\n    // 获取所有 button 节点，并添加事件监听\n    const buttons = document.querySelectorAll(&#39;table button&#39;)\n    for(let i = 0; i &lt; buttons.length; i++) &#123;\n      buttons[i].addEventListener(&#39;click&#39;, function () &#123;\n        // console.log(this.parentNode); // 父节点 td\n        // console.log(this.parentNode.parentNode); // 爷爷节点 tr\n        this.parentNode.parentNode.style.color = &#39;red&#39;\n      &#125;)\n    &#125;\n  &lt;/script&gt;\n&lt;/body&gt;结论：parentNode 获取父节点，以相对位置查找节点，实际应用中非常灵活。\n兄弟关系html&lt;body&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;/li&gt;\n    &lt;li&gt;CSS&lt;/li&gt;\n    &lt;li&gt;JavaScript 基础&lt;/li&gt;\n    &lt;li&gt;Web APIs&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;script&gt;\n    // 获取所有 li 节点\n    const lis = document.querySelectorAll(&#39;ul li&#39;)\n\n    // 对所有的 li 节点添加事件监听\n    for(let i = 0; i &lt; lis.length; i++) &#123;\n      lis[i].addEventListener(&#39;click&#39;, function () &#123;\n        // 前一个节点\n        console.log(this.previousSibling)\n        // 下一下节点\n        console.log(this.nextSibling)\n      &#125;)\n    &#125;\n  &lt;/script&gt;\n&lt;/body&gt;结论：\n\npreviousSibling 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。\nnextSibling 获取后一个节点，以相对位置查找节点，实际应用中非常灵活。\n\nWeb APIs - 第5天笔记\n\n\n\n\n\n\n\n\n目标： 能够利用JS操作浏览器,具备利用本地存储实现学生就业表的能力\n\nBOM操作\n综合案例\n\njs组成JavaScript的组成\n\nECMAScript:\n\n规定了js基础语法核心知识。\n比如：变量、分支语句、循环语句、对象等等\n\n\nWeb APIs :\n\nDOM   文档对象模型， 定义了一套操作HTML文档的API\nBOM   浏览器对象模型，定义了一套操作浏览器窗口的API\n\n\n\n \nwindow对象BOM (Browser Object Model ) 是浏览器对象模型\n\nwindow对象是一个全局对象，也可以说是JavaScript中的顶级对象\n像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的\n所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法\nwindow对象下的属性和方法调用的时候可以省略window\n\n \n定时器-延迟函数JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout\n语法：\njssetTimeout(回调函数, 延迟时间)setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window\n间歇函数 setInterval : 每隔一段时间就执行一次， , 平时省略window\n清除延时函数：\njsclearTimeout(timerId)\n\n\n\n\n\n\n\n\n注意点\n\n延时函数需要等待,所以后面的代码先执行\n返回值是一个正整数，表示定时器的编号\n\nhtml&lt;body&gt;\n  &lt;script&gt;\n    // 定时器之延迟函数\n\n    // 1. 开启延迟函数\n    let timerId = setTimeout(function () &#123;\n      console.log(&#39;我只执行一次&#39;)\n    &#125;, 3000)\n\n    // 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号\n    console.log(timerId)\n\n    // 1.2 延迟函数需要等待时间，所以下面的代码优先执行\n\n    // 2. 关闭延迟函数\n    clearTimeout(timerId)\n\n  &lt;/script&gt;\n&lt;/body&gt;location对象location (地址) 它拆分并保存了 URL 地址的各个组成部分， 它是一个对象\n\n\n\n属性&#x2F;方法\n说明\n\n\n\nhref\n属性，获取完整的 URL 地址，赋值时用于地址的跳转\n\n\nsearch\n属性，获取地址中携带的参数，符号 ？后面部分\n\n\nhash\n属性，获取地址中的啥希值，符号 # 后面部分\n\n\nreload()\n方法，用来刷新当前页面，传入参数 true 时表示强制刷新\n\n\nhtml&lt;body&gt;\n  &lt;form&gt;\n    &lt;input type=&quot;text&quot; name=&quot;search&quot;&gt; &lt;button&gt;搜索&lt;/button&gt;\n  &lt;/form&gt;\n  &lt;a href=&quot;#/music&quot;&gt;音乐&lt;/a&gt;\n  &lt;a href=&quot;#/download&quot;&gt;下载&lt;/a&gt;\n\n  &lt;button class=&quot;reload&quot;&gt;刷新页面&lt;/button&gt;\n  &lt;script&gt;\n    // location 对象  \n    // 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址\n    console.log(location.href)\n    // location.href = &#39;http://www.itcast.cn&#39;\n\n    // 2. search属性  得到 ? 后面的地址 \n    console.log(location.search)  // ?search=笔记本\n\n    // 3. hash属性  得到 # 后面的地址\n    console.log(location.hash)\n\n    // 4. reload 方法  刷新页面\n    const btn = document.querySelector(&#39;.reload&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      // location.reload() // 页面刷新\n      location.reload(true) // 强制页面刷新 ctrl+f5\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;navigator对象navigator是对象，该对象下记录了浏览器自身的相关信息\n常用属性和方法：\n\n通过 userAgent 检测浏览器的版本及平台\n\njs// 检测 userAgent（浏览器信息）\n(function () &#123;\n  const userAgent = navigator.userAgent\n  // 验证是否为Android或iPhone\n  const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)\n  const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)\n  // 如果是Android或iPhone，则跳转至移动站点\n  if (android || iphone) &#123;\n    location.href = &#39;http://m.itcast.cn&#39;\n  &#125;&#125;)();histroy对象history (历史)是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退等\n使用场景\nhistory对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。\n \n常见方法：\n \nhtml&lt;body&gt;\n  &lt;button class=&quot;back&quot;&gt;←后退&lt;/button&gt;\n  &lt;button class=&quot;forward&quot;&gt;前进→&lt;/button&gt;\n  &lt;script&gt;\n    // histroy对象\n\n    // 1.前进\n    const forward = document.querySelector(&#39;.forward&#39;)\n    forward.addEventListener(&#39;click&#39;, function () &#123;\n      // history.forward() \n      history.go(1)\n    &#125;)\n    // 2.后退\n    const back = document.querySelector(&#39;.back&#39;)\n    back.addEventListener(&#39;click&#39;, function () &#123;\n      // history.back()\n      history.go(-1)\n    &#125;)\n  &lt;/script&gt;\n&lt;/body&gt;\n本地存储（今日重点）本地存储：将数据存储在本地浏览器中\n常见的使用场景：\nhttps://todomvc.com/examples/vanilla-es6/    页面刷新数据不丢失\n好处：\n1、页面刷新或者关闭不丢失数据，实现数据持久化\n2、容量较大，sessionStorage和 localStorage 约 5M 左右\nlocalStorage（重点）作用: 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失\n特性：以键值对的形式存储，并且存储的是字符串， 省略了window\n\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;本地存储-localstorage&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;script&gt;\n    // 本地存储 - localstorage 存储的是字符串 \n    // 1. 存储\n    localStorage.setItem(&#39;age&#39;, 18)\n\n    // 2. 获取\n    console.log(typeof localStorage.getItem(&#39;age&#39;))\n\n    // 3. 删除\n    localStorage.removeItem(&#39;age&#39;)\n  &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;sessionStorage（了解）特性：\n\n用法跟localStorage基本相同\n区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除\n\n存储：sessionStorage.setItem(key,value)\n获取：sessionStorage.getItem(key)\n删除：sessionStorage.removeItem(key)\nlocalStorage 存储复杂数据类型问题：本地只能存储字符串,无法存储复杂数据类型.\n解决：需要将复杂数据类型转换成 JSON字符串,在存储到本地\n语法：JSON.stringify(复杂数据类型)\nJSON字符串：\n\n首先是1个字符串\n属性名使用双引号引起来，不能单引号\n属性值如果是字符串型也必须双引号\n\nhtml&lt;body&gt;\n  &lt;script&gt;\n    // 本地存储复杂数据类型\n    const goods = &#123;\n      name: &#39;小米&#39;,\n      price: 1999\n    &#125;\n    // localStorage.setItem(&#39;goods&#39;, goods)\n    // console.log(localStorage.getItem(&#39;goods&#39;))\n\n    // 1. 把对象转换为JSON字符串  JSON.stringify\n    localStorage.setItem(&#39;goods&#39;, JSON.stringify(goods))\n    // console.log(typeof localStorage.getItem(&#39;goods&#39;))\n\n  &lt;/script&gt;\n&lt;/body&gt;问题：因为本地存储里面取出来的是字符串，不是对象，无法直接使用\n**解决： **把取出来的字符串转换为对象\n语法：JSON.parse(JSON字符串)\nhtml&lt;body&gt;\n  &lt;script&gt;\n    // 本地存储复杂数据类型\n    const goods = &#123;\n      name: &#39;小米&#39;,\n      price: 1999\n    &#125;\n    // localStorage.setItem(&#39;goods&#39;, goods)\n    // console.log(localStorage.getItem(&#39;goods&#39;))\n\n    // 1. 把对象转换为JSON字符串  JSON.stringify\n    localStorage.setItem(&#39;goods&#39;, JSON.stringify(goods))\n    // console.log(typeof localStorage.getItem(&#39;goods&#39;))\n\n    // 2. 把JSON字符串转换为对象  JSON.parse\n    console.log(JSON.parse(localStorage.getItem(&#39;goods&#39;)))\n\n  &lt;/script&gt;\n&lt;/body&gt;综合案例数组map 方法使用场景：\nmap 可以遍历数组处理数据，并且返回新的数组\n语法：\njs\n  const arr = [&#39;red&#39;, &#39;blue&#39;, &#39;pink&#39;]\n  // 1. 数组 map方法 处理数据并且 返回一个数组\n   const newArr = arr.map(function (ele, index) &#123;\n    // console.log(ele)  // 数组元素\n    // console.log(index) // 索引号\n    return ele + &#39;颜色&#39;\n    &#125;)\nconsole.log(newArr)\n\n\n\n\n\n\n\n\nmap 也称为映射。映射是个术语，指两个元素的集之间元素相互“对应”的关系。\nmap重点在于有返回值，forEach没有返回值（undefined）\n数组join方法作用：join() 方法用于把数组中的所有元素转换一个字符串\n语法：\njs\n    const arr = [&#39;red&#39;, &#39;blue&#39;, &#39;pink&#39;]\n\n    // 1. 数组 map方法 处理数据并且 返回一个数组\n    const newArr = arr.map(function (ele, index) &#123;\n      // console.log(ele)  // 数组元素\n      // console.log(index) // 索引号\n      return ele + &#39;颜色&#39;\n    &#125;)\n    console.log(newArr)\n\n    // 2. 数组join方法  把数组转换为字符串\n    // 小括号为空则逗号分割\n    console.log(newArr.join())  // red颜色,blue颜色,pink颜色\n    // 小括号是空字符串，则元素之间没有分隔符\n    console.log(newArr.join(&#39;&#39;))  //red颜色blue颜色pink颜色\n    console.log(newArr.join(&#39;|&#39;))  //red颜色|blue颜色|pink颜色Web APIs - 第6天笔记\n\n\n\n\n\n\n\n\n目标：能够利用正则表达式完成小兔鲜注册页面的表单验证，具备常见的表单验证能力\n\n正则表达式\n综合案例\n阶段案例\n\n正则表达式正则表达式（Regular Expression）是一种字符串匹配的模式（规则）\n使用场景：\n\n例如验证表单：手机号表单要求用户只能输入11位的数字 (匹配)\n过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等\n\n \n正则基本使用\n定义规则\njsconst reg =  /表达式/\n其中/   /是正则表达式字面量\n正则表达式也是对象 \n\n\n使用正则\n\ntest()方法   用来查看正则表达式与指定的字符串是否匹配\n如果正则表达式与指定的字符串匹配 ，返回true，否则false\n\n\n\njs\n    // 正则表达式的基本使用\n    const str = &#39;web前端开发&#39;\n    // 1. 定义规则\n    const reg = /web/\n\n    // 2. 使用正则  test()\n    console.log(reg.test(str))  // true  如果符合规则匹配上则返回true\n    console.log(reg.test(&#39;java开发&#39;))  // false  如果不符合规则匹配上则返回 false元字符\n普通字符:\n\n\n大多数的字符仅能够描述它们本身，这些字符称作普通字符，例如所有的字母和数字。\n普通字符只能够匹配字符串中与它们相同的字符。    \n比如，规定用户只能输入英文26个英文字母，普通字符的话  &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F;\n\n\n元字符(特殊字符）\n\n\n是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。\n比如，规定用户只能输入英文26个英文字母，换成元字符写法： &#x2F;[a-z]&#x2F;\n\n边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符\n\n\n\n\n\n\n\n\n\n\n如果 ^ 和 $ 在一起，表示必须是精确匹配\njs\n    // 元字符之边界符\n    // 1. 匹配开头的位置 ^\n    const reg = /^web/\n    console.log(reg.test(&#39;web前端&#39;))  // true\n    console.log(reg.test(&#39;前端web&#39;))  // false\n    console.log(reg.test(&#39;前端web学习&#39;))  // false\n    console.log(reg.test(&#39;we&#39;))  // false\n\n    // 2. 匹配结束的位置 $\n    const reg1 = /web$/\n    console.log(reg1.test(&#39;web前端&#39;))  //  false\n    console.log(reg1.test(&#39;前端web&#39;))  // true\n    console.log(reg1.test(&#39;前端web学习&#39;))  // false\n    console.log(reg1.test(&#39;we&#39;))  // false  \n\n    // 3. 精确匹配 ^ $\n    const reg2 = /^web$/\n    console.log(reg2.test(&#39;web前端&#39;))  //  false\n    console.log(reg2.test(&#39;前端web&#39;))  // false\n    console.log(reg2.test(&#39;前端web学习&#39;))  // false\n    console.log(reg2.test(&#39;we&#39;))  // false \n    console.log(reg2.test(&#39;web&#39;))  // true\n    console.log(reg2.test(&#39;webweb&#39;))  // flase 量词量词用来设定某个模式重复次数\n\n\n\n\n\n\n\n\n\n\n注意： 逗号左右两侧千万不要出现空格\njs\n    // 元字符之量词\n    // 1. * 重复次数 &gt;= 0 次\n    const reg1 = /^w*$/\n    console.log(reg1.test(&#39;&#39;))  // true\n    console.log(reg1.test(&#39;w&#39;))  // true\n    console.log(reg1.test(&#39;ww&#39;))  // true\n    console.log(&#39;-----------------------&#39;)\n\n    // 2. + 重复次数 &gt;= 1 次\n    const reg2 = /^w+$/\n    console.log(reg2.test(&#39;&#39;))  // false\n    console.log(reg2.test(&#39;w&#39;))  // true\n    console.log(reg2.test(&#39;ww&#39;))  // true\n    console.log(&#39;-----------------------&#39;)\n\n    // 3. ? 重复次数  0 || 1 \n    const reg3 = /^w?$/\n    console.log(reg3.test(&#39;&#39;))  // true\n    console.log(reg3.test(&#39;w&#39;))  // true\n    console.log(reg3.test(&#39;ww&#39;))  // false\n    console.log(&#39;-----------------------&#39;)\n\n\n    // 4. &#123;n&#125; 重复 n 次\n    const reg4 = /^w&#123;3&#125;$/\n    console.log(reg4.test(&#39;&#39;))  // false\n    console.log(reg4.test(&#39;w&#39;))  // flase\n    console.log(reg4.test(&#39;ww&#39;))  // false\n    console.log(reg4.test(&#39;www&#39;))  // true\n    console.log(reg4.test(&#39;wwww&#39;))  // false\n    console.log(&#39;-----------------------&#39;)\n\n    // 5. &#123;n,&#125; 重复次数 &gt;= n \n    const reg5 = /^w&#123;2,&#125;$/\n    console.log(reg5.test(&#39;&#39;))  // false\n    console.log(reg5.test(&#39;w&#39;))  // false\n    console.log(reg5.test(&#39;ww&#39;))  // true\n    console.log(reg5.test(&#39;www&#39;))  // true\n    console.log(&#39;-----------------------&#39;)\n\n    // 6. &#123;n,m&#125;   n =&lt; 重复次数 &lt;= m\n    const reg6 = /^w&#123;2,4&#125;$/\n    console.log(reg6.test(&#39;w&#39;))  // false\n    console.log(reg6.test(&#39;ww&#39;))  // true\n    console.log(reg6.test(&#39;www&#39;))  // true\n    console.log(reg6.test(&#39;wwww&#39;))  // true\n    console.log(reg6.test(&#39;wwwww&#39;))  // false\n\n    // 7. 注意事项： 逗号两侧千万不要加空格否则会匹配失败范围表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围\n \njs\n    // 元字符之范围  []  \n    // 1. [abc] 匹配包含的单个字符， 多选1\n    const reg1 = /^[abc]$/\n    console.log(reg1.test(&#39;a&#39;))  // true\n    console.log(reg1.test(&#39;b&#39;))  // true\n    console.log(reg1.test(&#39;c&#39;))  // true\n    console.log(reg1.test(&#39;d&#39;))  // false\n    console.log(reg1.test(&#39;ab&#39;))  // false\n\n    // 2. [a-z] 连字符 单个\n    const reg2 = /^[a-z]$/\n    console.log(reg2.test(&#39;a&#39;))  // true\n    console.log(reg2.test(&#39;p&#39;))  // true\n    console.log(reg2.test(&#39;0&#39;))  // false\n    console.log(reg2.test(&#39;A&#39;))  // false\n    // 想要包含小写字母，大写字母 ，数字\n    const reg3 = /^[a-zA-Z0-9]$/\n    console.log(reg3.test(&#39;B&#39;))  // true\n    console.log(reg3.test(&#39;b&#39;))  // true\n    console.log(reg3.test(9))  // true\n    console.log(reg3.test(&#39;,&#39;))  // flase\n\n    // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位\n    const reg4 = /^[a-zA-Z0-9_]&#123;6,16&#125;$/\n    console.log(reg4.test(&#39;abcd1&#39;))  // false \n    console.log(reg4.test(&#39;abcd12&#39;))  // true\n    console.log(reg4.test(&#39;ABcd12&#39;))  // true\n    console.log(reg4.test(&#39;ABcd12_&#39;))  // true\n\n    // 3. [^a-z] 取反符\n    const reg5 = /^[^a-z]$/\n    console.log(reg5.test(&#39;a&#39;))  // false \n    console.log(reg5.test(&#39;A&#39;))  // true\n    console.log(reg5.test(8))  // true\n字符类某些常见模式的简写方式，区分字母和数字\n\n \n替换和修饰符replace 替换方法，可以完成字符的替换\n \njs\n    // 替换和修饰符\n    const str = &#39;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#39;\n    // 1. 替换  replace  需求：把前端替换为 web\n    // 1.1 replace 返回值是替换完毕的字符串\n    // const strEnd = str.replace(/前端/, &#39;web&#39;) 只能替换一个\n修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等\n\ni 是单词 ignore 的缩写，正则匹配时字母不区分大小写\ng 是单词 global 的缩写，匹配所有满足正则表达式的结果\n\njs\n    // 替换和修饰符\n    const str = &#39;欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神&#39;\n    // 1. 替换  replace  需求：把前端替换为 web\n    // 1.1 replace 返回值是替换完毕的字符串\n    // const strEnd = str.replace(/前端/, &#39;web&#39;) 只能替换一个\n\n    // 2. 修饰符 g 全部替换\n    const strEnd = str.replace(/前端/g, &#39;web&#39;)\n    console.log(strEnd) \n正则插件 \nchange 事件给input注册 change 事件，值被修改并且失去焦点后触发\n判断是否有类 \n元素.classList.contains() 看看有没有包含某个类，如果有则返回true，么有则返回false\n","slug":"前端/Web-APIs/Web APIs","date":"2023-07-20T07:30:00.000Z","categories_index":"计算机,前端","tags_index":"笔记,Web APIs","author_index":"Honman"},{"id":"a2af924c2c9dc8abd52717dfa27385c7","title":"8000英语单词","content":"\n\n\n\n\n\n\n\n\n学习英语是绝大部分热爱学习的人绝不可能绕过去的一道坎。而“低配版”词汇量与“高配版”词汇量，将导致英语学习体验全方位的差别，所以背单词是一种“must-do”。\n所以，为了学英语的时候更“爽”，我们实际上是不得不背好单词的——不仅仅因为词汇的障碍，就错过英语文章里优美的遣词造句技巧，错过那些来自地球上总体上最发达的文明中的人们的思考，错过兼听则明，错过通过真正读懂一些东西来丰富自己的机会。\n基本常识Part1 时间与方位时间（1）time n. 时间\t【太母】\tWhat time will we go?\t【我们什么时候走？】\nsecond n. 秒\t【赛肯的】He’ll arrive in a second.\t【他一会儿就到。】\nminute n. 分\t【咪逆特】I’ll be there in just a minute.\t【马上我就会到那里。】\nquarter n.一刻钟\t【哭奥特额】Can we leave at a quarter to nine?\t【我们可以在八点四十五分离开吗？】\nhour n. 小时\t【奥额】I’ve been sitting for an hour.\t【我们已经坐了一个小时了。】\no’clock ad. （几）点钟\t【额可落可】It’s eleven o’clock now.\t【现在是十一点钟。】\nweek n. 星期\t【为一科】Is next week a good time to visit you?\t【下周去拜访你方便吗？】\nmonth n. 月 \t【慢si】Which month is she coming to visit us?\t【她几月份来看我们？】\nquarter n. 季度\t【哭奥特额】That was a virtue this quarter.\t【那在本季度是一大优势。】\nyear n. 年\t【叶额】We had an election last year.\ndecade n. 十年\t【爹科诶的】She is a decade older than me.\t【她比我大10岁。】\nsunrise n. 日出\t【桑如爱子】I get up as the sunrise comes.\t【我随着日出起床。】\nsunset n. 日落\t【桑塞特】Did you see the beautiful sunset last night?\t【你看到了昨晚美丽的日落吗？】\nmorning n. 早晨\t【猫宁】There’s a chill in the air this morning.\t【今天早晨寒气袭人。】\nnoon n. 中午\t【怒嗯】I’ll meet you at noon.\t【我将在中午见你。】\nafternoon n. 下午\t【啊福特怒恩】We didn’t arrive until late in the afternoon.\t【我们知道下午晚些时候才到达。】\n时间（2）am\t中午前、上午The plane arrives at 10 am.\t【飞机上午10点到达。】\npm\t中午后、下午It’s 2 pm in the afternoon here.\t【这里现在是下午两点钟】\nevening\t晚上Can you come over tomorrow evening?\t【明天晚上你能过来吗？】\nnight\t夜晚How was the movie last night?\t【昨天晚上的电影怎么样？】\nmidnight\t午夜He didn’t get home until midnight.\t【他直到午夜才到家。】\npast\t过去He worked in that factory in the past.\t【过去他在那家工厂工作。】\nnow\t现在I need you to stop right now.\t【我需要你马上停下来。】\nfuture\t将来What do you want to do in the future?\t【你将来想要做什么？】\nyesterday\t昨天Yesterday is Sunday.\t【昨天是周日】\ntoday\t今天Today is mother’s birthday.\t【今天是妈妈的生日。】\ntomorrow\t明天People will be partying tomorrow.\t【明天人们将会聚会。】\nThe day before tomorrow\t前天It snowed the day before yesterday.\t【前天下雪了。】\nThe day after tomorrow\t后天She will arrive the day after tomorrow.\t【她将在后天到达。】\nlater\t稍后I will call you later.\t【我稍后打电话给你。】\nlast month\t上个月She went back home last month.\t【她上个月回家了。】\nnext month\t下个月Do you have next month’s schedule?\t【你有下个月的计划表吗？】\n日期方向与位置","slug":"English/8000英语单词","date":"2023-03-30T03:00:00.000Z","categories_index":"英语","tags_index":"英语","author_index":"Honman"},{"id":"3316961ecf1671c6065b043220187c47","title":"Java基础","content":"Java基础\nJava对大小写敏感。\n关键字class对意思是类。Java是面向对象的语言，所有代码必须放在class里面。\n编译后的源文件，得到相应的字节码文件，编译起为每个类生成独立的字节码文件。\nmain方法是Java应用程序的入口方法 固定格式: Public static void (String[] args) { }\n一个源文件可以包含多个类。\n每个语句必须以分号结束，回车不是语句的结束标志。\n\n\nClick to see more\n建议：\n\n编程是一定要注意缩进规范\n在写括号、引号时，一定要成对敲出来后再往里面写代码\n\n\t\n\n\n创建第一个Java程序​\t在桌面创建一个java文本文件，命名为 test（test.java），然后编辑test.java文件，写入代码如下：\njavapublic class test &#123;\t//class的名字一定要和java文本文件名一致！！！\n    public static void main(String[] args) &#123;\t//开头固定搭配！！！\n        System.out.println(&quot;Chan_Honman,你好！&quot;);\n        System.out.println(&quot;this is a test!&quot;);\n        System.out.println(&quot;这是第三行代码&quot;);\n    &#125;\n&#125;\n​\t写完代码后记得保存（⌘ + s &#x2F; Ctrl + s ），然后打开终端输入命令如下：\nbash#\t将test.java文件编译成字节码文件 \njavac test.java\n#\t运行程序\njava test​\t其中 javac 命令的作用是：启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。\n​\t而 java 命令的作用是：负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行.一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数.\n​\t工作原理如下：\n\n最常用DOS命令磁盘操作系统（Disk Operating System）是早期个人电脑上的一类操作系统。\n常用命令：\n\n\n\n命令\n说明\n\n\n\ncd\n进入一个目录\n\n\ncd ..\n进入父级目录\n\n\ndir\n查看本目录下的文件和子目录列表\n\n\ncls\n清楚屏幕命令 现在是（clear）\n\n\n上下键\n查找之前敲过的命令\n\n\nTab键盘\n自动补全命令\n\n\n十进制和二进制转换1.十进制转二进制​\t十进制整数转换为二进制整数采用 “除2取余 逆序排序” 法。\n将十进制的(43)D转换为二进制的步骤如下：\n\n将商43除以2，商21余数为1；\n\n将商21除以2，商10余数为1；\n\n将商10除以2，商5余数为0；\n\n将商5除以2，商2余数为1；\n\n将商2除以2，商1余数为0； \n\n将商1除以2，商0余数为1； \n\n读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D&#x3D;(101011)B。\n\n\n2.二进制转十进制​\t采用 “权位相加” 法\n将二进制的(101011)B转换为十进制的步骤如下：\n\n第0位 1 x 2^0 &#x3D; 1；\n\n第1位 1 x 2^1 &#x3D; 2；\n\n第2位 0 x 2^2 &#x3D; 0；\n\n第3位 1 x 2^3 &#x3D; 8；\n\n第4位 0 x 2^4 &#x3D; 0；\n\n第5位 1 x 2^5 &#x3D; 32；\n\n读数，把结果值相加，1+2+0+8+0+32&#x3D;43，即(101011)B&#x3D;(43)D。\n\n\nJava注释​\t注释不会出现在字节码文件中，也就是说编译器是会跳过注释的语句。在Java中注释分为三种。\n1.单行注释javapublic class Welcome &#123;\n\n    //这是单行注释 main（）方法是程序的入口\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Chan_Honman,你好！&quot;);\n    &#125;\n&#125;\n2.多行注释javapublic class Welcome &#123;\n\n    /*\n        这是多行注释\n        这是多行注释\n        这是多行注释\n    */\n    public static void main(String[] /*行内注释： arguments的缩写是args */args) &#123;\n        System.out.println(&quot;Chan_Honman,你好！&quot;);\n    &#125;\n&#125;\n3.文档注释java\n/**\n * 这是文档注释 主要用于开发环境 IDEA、Eclipse、VScode\n * @author chan_honman\n * @version 1.0\n*/\npublic class Welcome &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(&quot;Chan_Honman,你好！&quot;);\n    &#125;\n&#125;\n标识符和关键字1.标识符​\t标识符是用来给变量、类、方法和包进行命名的。\n标识符4大规则：\n\n必须以字母、下划线_ 、美元符号$ 开头。\n其他部分可以是字母、下划线_ 、美元符号$ 和数字任意组合。\n大小写敏感，且长度无限制。\n不可用Java的关键字。\n\n\n\n\n\n\n\n提示\n表示类名的标识符：每个单词的首字母大写，如：Boy、GoodBoy\n表示方法和变量的标识符：第一个字母小写，从第二个单词开始首字母大写（驼峰原则）如：eat()、eatFood()\n​\tJava不采用ASCII字符集，而是用Unicode字符集。所以这里字母的含义不仅仅是英文，还包括汉字等等。但是不建议使用汉字来定义标识符！因为不够高级，不够酷，不够官方。\n\n\n2.关键字​\t48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。\n变量的分类和作用域变量有三种类型：\n\n局部变量\n成员变量（实例变量）\n静态变量\n\n\n\n\n类型\n声明位置\n从属于\n生命周期（作用域）\n\n\n\n局部变量\n方法或语句内部\n方法&#x2F;语句块\n从声明位置开始。知道方法或语句块执行完毕。局部变量消失\n\n\n成员变量（实例变量）\n类内部，方法外部\n对象object\n对象创建，成员变量页跟着创建。对象消失，成员变量也跟着消失\n\n\n静态变量（类变量）\n类内部，static修饰\n类class\n类被加载，静态变量就有效。类被卸载，静态变量消失\n\n\njavapublic class test &#123;\n\n    int a = 3;  //成员变量\n    static int b = 4;   //静态变量\n\n    public static void main(String[] agrs) &#123;\n        //局部变量\n        int age = 18;\n        int b;  //只是声明了变量b 还没有初始化\n        int x = 0, y = 0, z = 1;\n\n        System.out.println(age);    //输出：18\n        b = 0;  //变量使用之前必须初始化\n        System.out.println(b);  //输出：0\n        System.out.println(z);  //输出：1\n    &#125;\n&#125;\n\n\n\n\n\n\n提示\n下面代码哪个是正确的？？？\nA代码如下：\njavapublic void test()&#123;\n        int i;\n        int j = i + 5; \n    &#125;B代码如下：\njavapublic void test()&#123;\n        int i;\n        i = 5;\n        int j = i + 5; \n    &#125;\n\n\nClick to see the answer\n答案：B\n因为 A 代码中的错误如下：\njavapublic void test()&#123;\n        int i;\n        int j = i + 5;  //编译出错 变量 i 没有被初始化\n    &#125;变量 i 没有被初始化\n\n\n常量 和 final​\t在Java中，用关键字 final 来定义一个常量。常量一旦被初始化后就不能再更改。\n声明格式：final type varName &#x3D; value;\njavapublic class TestConstant &#123;\n    public static void main(String[] args) &#123;\n        final double pi = 3.14;\n        //pi = 3.1415;    //Cannot assign a value to final variable &#39;pi&#39;\n        System.out.println(pi);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n一般将1、2、3、’a’、’b’、’c’、true、false、”helloWorld”等称为字符常量，而使用final修饰的 pi 等称为符号常量。\n\n\n\n\n\n\n提示\n变量和常量的命名规范\n\n大写字母和下划线：MAX_VALUE\n类成员变量：首字母小写、驼峰原则\n类名：首字母大写、驼峰原则（ Man、GoodMan ）\n方法名：首字母小写、驼峰原则( play()、playComputer() )\n\n练习题：圆的半径r为4 π约为3.14 计算该圆的面积area和周长perimeter\n\n\n\nClick to see the answer\njava/**\n * 圆的半径r为4 π约为3.14 计算该圆的面积area和周长perimeter\n */\npublic class TestConstant &#123;\n    public static void main(String[] args) &#123;\n        final double pi = 3.14; //π\n        int r = 4;  //半径为4\n        double area = pi * r * r;\n        double perimeter = 2 * pi * r;\n        System.out.println(&quot;圆的面积：&quot; + area); //输出：圆的面积：50.24\n        System.out.println(&quot;圆的周长：&quot; + perimeter);    //输出：圆的周长：25.12\n    &#125;\n&#125;\n\n\n基本数据类型 Primitive data type\n整数类型一共有四种类型：\n\n\n\n类型\n占用存储空间\n范围\n\n\n\nbyte\n1字节\n-2^7 —  2^7 - 1\n\n\nshort\n2字节\n-2^15 —  2^15 - 1\n\n\nint\n4字节\n-2^31 —  2^31 - 1\n\n\nlong\n8字节\n-2^63 —  2^63 - 1\n\n\n\n\n\n\n\n\n\n\n\nJava语言整型常量的四种表示形式：\n\n十进制整数：如：99、-500、0\n八进制整数：要求以 0 开头，如：014\n十六进制整数：要求以 0x 开头 或 0X 开头，如：0x14\n二进制整数：要求 0b 或 0B 开头，如：0b01110011\n\njavapublic class TestInt &#123;\n    public static void main(String[] args) &#123;\n\n        int a = 100;    //十进制\n        int b = 022;    //八进制\n        int c = 0xff;    //十六进制\n        int d = 0b10;    //二进制\n\n        byte e = 50;\n        short f = 300;\n\n        long salary = 3000000000L;  //整型常量定义为long类型\n\n        System.out.println(a);  //100\n        System.out.println(b);  //18    输出自动转为十进制\n        System.out.println(c);  //255   输出自动转为十进制\n        System.out.println(d);  //2     输出自动转为十进制\n\n        System.out.println(salary); //3000000000\n\n        System.out.println(e);  //50\n        System.out.println(f);  //300\n    &#125;\n&#125;\n浮点型Floating Point Number\n一共有两种类型：\n\n\n\n类型\n占用空间\n范围\n\n\n\nfloat\n4字节\n-3.403E38 — 3.403E38\n\n\ndouble\n8字节\n-1.798E308 —  1.798E308\n\n\n\n\n\n\n\n\n\n\n\n\nfloat类型aka单精度类型 尾数可以精确到7位有效数字\n\ndouble类型aka双精度 绝大部分应程序都采用double类型\n\nJava浮点类型常量有两种表达形式： 1.十进制数形式 3.14 、314.0、 0.314 2.科学记数法形式 3.14E0、 3.14E2、 3.14E-1\n\n浮点型不精确的 不建议用来作运算比较 若精度要求非常高用于商业计算可使用BigDecimal进行运算比较\n\n浮点型常量默认是double 若改成float可以在后面加个F或f\n\n\n字符型​\t字符型在内存中占2个字节，在Java中使用单引号来表示字符常量。例如’A’是一个字符，它与”A”是不同的，”A”表示含有一个字符的字符串。\n​\tchar类型用来表示在Unicode编码表中的字符。Unicode编码被设计用来处理各种语言的文字，它占2个字节，可允许有65536个字符。\n\n\n\n转义符\n含义\nUnicode值\n\n\n\n\\b\n退格（backspace）\n\\u0008\n\n\n\\n\n换行\n\\u000a\n\n\n\\r\n回车\n\\u000d\n\n\n\\t\n制表符（tab）\n\\u0009\n\n\n\\ “\n双引号\n\\u0022\n\n\n\\ ‘\n单引号\n\\u0027\n\n\n\\\\\n反斜杠\n\\u005c\n\n\n\n\n\n\n\n\n\n\n\nString类其实是字符序列（char sequence），本质是char字符组成的数组。\njava/**\n * char类型的使用\n * @author chan_honman \n * @version 1.0\n */\npublic class TestChar &#123;\n    public static void main(String[] args) &#123;\n        char c1 = &#39;a&#39;;  //a\n        char c2 = &#39;中&#39;;  //中\n        char c3 = &#39;\\u0061&#39;; //a\n\n        System.out.println(c1);\n        System.out.println(c2);\n        System.out.println(c3);\n\n        String str = &quot;My name is Chan_Honman!&quot;;\n        System.out.println(str);\n\n        char c5 = &#39;\\n&#39;;\n        System.out.println(&quot;a\\nb\\nc\\nd\\ne\\nf\\ng&quot;);  //没输出一个字母就换一次行\n    &#125;\n&#125;\n布尔型 boolean\nboolean类型只有两个常量值 true 和 false。\n内存中占用一个字节或4个字节 不可以使用0或非0的整数代替 ture 和 false。（与c语言不同）\n\njava/**\n * @author chan_honman \n * @version 1.0\n */\n\npublic class TestBoolean &#123;\n    public static void main(String[] args) &#123;\n        boolean b1 = true;\n        boolean b2 = false;\n\n        if (b1)&#123;\n            System.out.println(&quot;b1是true！&quot;);\n        &#125;else&#123;\n            System.out.println(&quot;b1是false！&quot;);\n        &#125;\n    &#125;\n&#125;\n运算符 operator计算机的基本用途就是执行数学运算，Java提供了一套丰富的运算符来操作变量。\n算数运算符\n＋, －, , &#x2F;, % 属于二元运算符。*%是取模运算符，就是我们常说的求余数操作。**\n算数运算符中**++（自增），–（自减**）属于一元运算符。\n\njava/**\n * @author chan_honman\n * @version 1.0\n */\n\npublic class TestOperator01 &#123;\n    public static void main(String[] args) &#123;\n        int a = 3;\n        long b = 4;\n        long c = a + b;\n\n        double d = 3 + 3.14;\n        int d2 = 32 / 3;    //两个整数相除 直接保留结果的整数部分 没有四舍五入\n        System.out.println(d2); //输出10\n\n        //取余数\n        int e = 10 % 3;\n        System.out.println(e);  //输出1\n\n        //自增 自减\n        int g = 30;\n        g++;    //相当于 g = g + 1\n        g--;    //相当于 g = g - 1\n\n        g = 10;\n        int h = g++;    //g++先赋值给h 后g自增\n        System.out.println(&quot;这时候的g = &quot; + g); //输出11\n        g = 10;\n        int i = ++g;    //++g先自增后 赋值给i\n\n        System.out.println(h);  //输出10\n        System.out.println(i);  //输出11\n    &#125;\n&#125;\n二元运算符的运算规则整数运算：\n\n如果两个操作数有一个为long类型，则结果也为long类型。\n没有long类型时，结果为int类型。就算操作数全为short、byte类型，结果也是int类型。\n\n浮点运算：\n\n如果两个操作数有一个为double类型，则结果也是double类型。\n只有两个操作数都是float类型，则结果才为float类型。\n\n取模运算：\n其余作数可以为浮点数，一般使用整数，结果是”余数“，”余数“符号和左边操作数相同，如：7 % 3 &#x3D; 1， -7 % 3 &#x3D; -1， 7 % -1 &#x3D; 1。\n赋值及其扩展赋值运算符\n\n\n运算符\n用法举例\n等效表达式\n\n\n\n+&#x3D;\na +&#x3D; b\na &#x3D; a + b\n\n\n-&#x3D;\na -&#x3D; b\na &#x3D; a - b\n\n\n*&#x3D;\na *&#x3D; b\na &#x3D; a * b\n\n\n&#x2F;&#x3D;\na &#x2F;&#x3D; b\na &#x3D; a &#x2F; b\n\n\n%&#x3D;\na %&#x3D; b\na &#x3D; a % b\n\n\njava/**\n * @author chan_honman\n * @version 2.0\n */\n\npublic class TestOperator02 &#123;\n    public static void main(String[] args) &#123;\n        int a = 3;\n        int b = 4;\n        a += b;     //相当于 a = a + b\n        System.out.println(a);  //输出7\n\n        a = 3;\n        a *= b + 3;   //相当于 a = a * (b + 3)\n        System.out.println(a);  //输出21\n    &#125;\n&#125;\n关系运算符关系运算符用来进行比较运算。关系运算的结果是布尔值：true 或者 false。\n\n\n\n运算符\n含义\n示例\n\n\n\n&#x3D;&#x3D;\n等于\na &#x3D;&#x3D; b\n\n\n!&#x3D;\n不等于\na !&#x3D; b\n\n\n&gt;\n大于\na &gt; b\n\n\n&lt;\n小于\na &lt; b\n\n\n&gt;&#x3D;\n大于或等于\na &gt;&#x3D; b\n\n\n&lt;&#x3D;\n小于或等于\na &lt;&#x3D; b\n\n\n\n\n\n\n\n\n提示\n注意事项\n\n&#x3D; 是赋值运算符 而真正的判断两个操作数是否相等的运算符是 &#x3D;&#x3D;。\n&#x3D;&#x3D; 、 !&#x3D; 、 是所有（基本和引用）数据类型都可以使用。\n（&gt; 、 &gt;&#x3D;、 &lt;、 &lt;&#x3D;）仅针对数值类型（byte short int long float double char）。\n\n\n\njava/**\n * @author chan_honman\n * @version 3.0\n */\n\npublic class TestOperator03 &#123;\n    public static void main(String[] args) &#123;\n        int a = 3;\n        int b = 4;\n        boolean c = a &gt; b;\n        System.out.println(c);  //输出false\n\n        char d = &#39;h&#39;;\n        //char值位于0-65536之间 可以通过（int）强转成数字\n        System.out.println(d);  //输出h\n        System.out.println((int) d);    //输出104 h对应的十进制数是104\n        boolean e = d &gt; 100;\n        System.out.println(e);\n    &#125;\n&#125;\n逻辑运算符\n\n\n名称\n符号\n说明\n\n\n\n与\n&amp;\n只要有一个为false 则为false\n\n\n短路与\n&amp;&amp;\n只要有一个为false 则为false\n\n\n或\n|\n只要有一个为true 则为true\n\n\n短路或\n||\n只要有一个为true 则为true\n\n\n非\n!\n取反\n\n\n异或\n^\n相同为false 不同为true\n\n\n\n\n\n\n\n\n提示\n短路与和短路或采用短路的方式。从左到右计算，如果通过运算左边的操作数就能够确定逻辑表达式的值，则不会继续计算运算符右边的操作数，提高效率。\n\n\njava/**\n * @author chan_honman\n * @version 4.0\n */\n\npublic class TestOperator04 &#123;\n    public static void main(String[] args) &#123;\n        boolean b1 = true;\n        boolean b2 = false;\n        System.out.println(b1 &amp; b2);    //与 有一个false 输出false\n        System.out.println(b1 | b2);    //或 有一个true 输出true\n        System.out.println(!b2);        //取反\n        System.out.println(b1 ^ b2);    //异或 相同false 不同所以输出 true\n\n        //短路与 短路或\n        //int b3 = 3/0 会报错 不能除以0\n        boolean b3 = 1 &gt; 2 &amp;&amp; (4 &lt; 3 / 0);  //短路只要前面符合要求 后面就不会判断了\n        System.out.println(b3); //输出false\n    &#125;\n&#125;\n位运算符位运算指的是进行二进制的运算。\n\n\n\n位运算符\n说明\n\n\n\n~\n取反\n\n\n&amp;\n按位与\n\n\n|\n按位或\n\n\n^\n按位异或\n\n\n&lt;&lt;\n左移运算符 左移动1位相当于乘2\n\n\n&gt;&gt;\n右移运算符 右移动1位相当于除2取商\n\n\njava/**\n * @author chan_honman\n * @version 4.0\n */\n\npublic class TestOperator04 &#123;\n    public static void main(String[] args) &#123;\n        int a = 7;  //0 1 1 1\n        int b = 8;  //1 0 0 0\n        System.out.println(a &amp; b);    //按位或 0\n        System.out.println(a | b);    //按位与 15\n        System.out.println(a ^ b);    //按位异或 15\n        System.out.println(~b);       //取反  -9\n\n//      位移 乘以2 除以2 使用位移操作 最快！！！！\n        int c = 5 &lt;&lt; 2;   //5*2*2\n        System.out.println(c);\n        int d = 40 &gt;&gt; 3;    //40/8\n\n    &#125;\n&#125;\n乘除2 使用位移操作 最快！！！！\n字符串连接符java/**\n * 测试字符串连接符的用法\n */\n\npublic class TestOperator05 &#123;\n\n    public static void main(String[] args) &#123;\n        String a = &quot;3&quot;;\n        int b = 4;\n        System.out.println(a + b);  //34\n\n//      条件是String 不是char 若是char 则仍然是加法\n        char c1 = &#39;h&#39;;\n        char c2 = &#39;i&#39;;\n        System.out.println(c1 + c2);    //209\n        System.out.println(&quot;&quot; + c1 + c2);   //hi\n    &#125;\n&#125;\n条件运算符\njava/**\n * 测试条件（三元）运算符的用法\n */\n\npublic class TestOperator06 &#123;\n\n    public static void main(String[] args) &#123;\n        int score = 90;\n        String a = score &lt; 60 ? &quot;不及格&quot; : &quot;及格&quot;;\n        System.out.println(a);  //及格\n\n        if (score &lt; 60) &#123;\n            a = &quot;不及格&quot;;\n        &#125; else &#123;\n            a = &quot;及格&quot;;\n        &#125;\n        System.out.println(a);  //及格\n\n        int x = -100;\n        int flag = x &gt; 0 ? 1 : (x == 0 ? 0 : 1);    //x是否大于0 不是的话执行冒号后的 判断x是否等于0 不是的话 执行冒号后面赋值\n        System.out.println(flag);   //1\n\n    &#125;\n&#125;\n运算符优先级问题\n逻辑与&amp;&amp; &gt; 逻辑或|| &gt; 逻辑非\ta || b &amp;&amp; c 的运行结果是 a || ( b &amp;&amp; c )\n括号运算符 &gt; 算术运算符 &gt; 关系运算符 &gt; 位运算符 &gt; 逻辑运算符\n\n数据类型的转换自动类型转换指的是容量小的数据类型可以自动转为容量大的数据类型 如下图所示：\n\n\n\n\n\n\n\n\n\n\n红色线条表示转换无数据丢失 虚线表示在转换时可能会丢失精度\n数据强制转换强制转换类型 又称为造型（cast） 用于强制转换数值的类型 可能会损失精度\n语法格式如下：\n（type）var\njava/**\n * 测试类型强制转换\n */\n\npublic class TestTypeCast &#123;\n\n    public static void main(String[] args) &#123;\n        double a = 3.94152;\n        int b = (int) a;\n        System.out.println(b);  //3 浮点数强转为整数 直接丢失小数部分\n\n        int c = 97;\n        char d = (char) c;\n        System.out.println(c);  //97\n\n        //强制转换超过了表数范围会丢失精度（完全不同的值）\n        byte e = (byte) 300;\n        System.out.println(e);  //44\n    &#125;\n&#125;\n基本类型转化时常见错误和问题\n操作比较大的数时 要留意是否溢出 尤其是整数操作时\nL 和 l 的问题：（1）不要命名为 l 的变量 字母 l 容易和数字 1 混淆 （2）long类型使用大写L 不要用小写 l\n\nScanner处理键盘输入Scanner让程序和用户通过键盘交互\njavaimport java.util.Scanner;\n\n/**\n * 测试键盘输入：Scanner用法\n */\n\npublic class TestScanner &#123;\n\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(&quot;请输入用户名：&quot;);\n        String uname = sc.nextLine();\n        System.out.println(&quot;你好，&quot; + uname);\n    &#125;\n&#125;\n请输入用户名：Chan_Honman\t(键盘输入)你好，Chan_Honman\nProcess finished with exit code 0\n控制语句\n顺序结构：先执行a，再执行b的逻辑\n条件判断结构：如果。。。则。。。的逻辑\n循环结构：如果。。。则重复执行。。。的逻辑\n\n条件判断结构（选择结构）\nif单分支结构\n\n语法结构：\njavaif(布尔表达式)&#123;\n    语句块\n&#125;\n\n【示例】掷色子🎲游戏 \nMath类的使用\nMath.random()该方法用于产生 0 到 1 区间 double 类型的随机数，但是不包括1。\njavaint i = (int) (6 * Math.random()); //产生【0,5】之间的随机数\njava/**\n * 写个掷色子游戏\n * 1.如果三次加起来一共大于15        不错\n * 2.如果三次加起来在 10-15 之间     一般\n * 3.如果三次加起来在 10-3之间       不好\n */\n\npublic class TestIf01 &#123;\n\n    public static void main(String[] args) &#123;\n        int i = (int) (Math.random() * 6) + 1;\n        int j = (int) (Math.random() * 6) + 1;\n        int k = (int) (Math.random() * 6) + 1;\n\n        int count = i + j + k;\n\n        if (count &gt; 15) &#123;\n            System.out.println(&quot;运气不错！&quot;);\n        &#125;\n\n        if (count &lt; 10) &#123;\n            System.out.println(&quot;运气不好！&quot;);\n        &#125;\n\n        if (10 &lt;= count &amp;&amp; count &lt;= 15) &#123;\n            System.out.println(&quot;运气一般！&quot;);\n        &#125;\n\n    &#125;\n&#125;\nif-else双分支结构\n\n语法结构：\njavaif (布尔表达式) &#123;\n    语句块1\n&#125; else &#123;\n    语句块2\n&#125;\n小练习：\njava/**\n * 测试if-else双分支结构\n */\n\npublic class TestIf02 &#123;\n\n    public static void main(String[] args) &#123;\n        double r = 4 * Math.random();\n        double area = Math.PI * r * r;\n        double circle = 2 * r * Math.PI;\n        System.out.println(&quot;半径=&quot; + r + &quot; 面积=&quot; + area + &quot;， 周长=&quot; + circle);\n        if (area &gt;= circle) &#123;\n            System.out.println(&quot;面积的数值大于周长&quot;);\n        &#125;else &#123;\n            System.out.println(&quot;面积的数值小于周长&quot;);\n        &#125;\n    &#125;\n&#125;\nIf-elseif-else多分支结构\n\n语法结构\njavaif (布尔表达式1) &#123;\n   语句块1;\n&#125; else if (布尔表达式2) &#123;\n   语句块2;\n    &#125;.....\n小练习：\njava/**\n * 测试多分支结构\n */\n\npublic class TestIf03 &#123;\n\n    public static void main(String[] args) &#123;\n        int age = (int) (120 * Math.random());\n        System.out.println(&quot;年龄是： &quot; + age);\n\n        //15以下儿童 15-24青年 25-44中年 45-64中老年 65-84老年 85-99老寿星\n        //100-109百岁老人 110以上申请国家纪录\n        if (age &lt; 15) &#123;\n            System.out.println(&quot;儿童&quot;);\n        &#125; else if (age &lt; 25) &#123;\n            System.out.println(&quot;青年&quot;);\n        &#125; else if (age &lt; 45) &#123;\n            System.out.println(&quot;中年&quot;);\n        &#125; else if (age &lt; 65) &#123;\n            System.out.println(&quot;中老年&quot;);\n        &#125; else if (age &lt; 85) &#123;\n            System.out.println(&quot;老年&quot;);\n        &#125; else if (age &lt; 100) &#123;\n            System.out.println(&quot;老寿星&quot;);\n        &#125; else if (age &lt; 110) &#123;\n\n        &#125; else &#123;\n            System.out.println(&quot;百岁老人&quot;);\n        &#125;\n    &#125;\n\n&#125;\nswitch语句\nswitch会根据表达式的值从相匹配的case标签处开始执行，一直执行到break处或者是switch的末尾。如果表达式的值与任一case值不匹配，则进入default语句。\nswitch中表达式的值是int（byte、short、char也可。但是long不行）、枚举、字符串。\n\n\n练习题：\njavapublic class TestSwitch01 &#123;\n\n    public static void main(String[] args) &#123;\n        int grade = (int) (Math.random() * 4) + 1;   //大学年级\n\n        switch (grade) &#123;\n            case 1:\n                System.out.println(&quot;大一新生&quot;);\n                break;\n            case 2:\n                System.out.println(&quot;大二&quot;);\n                break;\n            case 3:\n                System.out.println(&quot;大三&quot;);\n                break;\n            default:\n                System.out.println(&quot;大四&quot;);\n                break;\n        &#125;\n    &#125;\n&#125;\n循环结构循环结构 分两大类，一类是当型，一类是直到型。\n\n当型：\n当布尔表达式条件位true时，反复执行某语句，当布尔表达式的值为false时才停止循环，比如while与for循环。\n\n直到型：\n先执行某语句，再判断布尔表达式，如果true再执行语句，如此反复，直到布尔表达式条件为false时才停止循环，比如do-while循环。\n\n\nwhile循环♻️\n\n语法结构：\njavawhile (布尔表达式)\t&#123;\n        循环体;\n&#125;\n练习题：\njavapublic class TestWhile &#123;\n\n    public static void main(String[] args) &#123;\n        int a = 0;\n        while (a &lt; 3) &#123;\n            System.out.println(&quot;I love U! &quot; + a);\n            a++;\n        &#125;\n    &#125;\n&#125;\nfor循环♻️\n\n语法结构：\njavafor (初始表达式;布尔表达式;迭代因子) &#123;\n    循环体；\n&#125;\n\n初始化部分设置：循环变量的初值\n条件判断部分为：布尔表达式\n迭代因子：控制循环变量的增减\n\n练习题：\n累加 0+1+2+3+4+…+100\njavapublic class TestFor &#123;\n\n    public static void main(String[] args) &#123;\n        int sum = 0;\n        for (int i = 0; i &lt;= 100; i++) &#123;\n            sum += i;\n        &#125;\n        System.out.println(sum);    //5050\n    &#125;\n&#125;\n输出90-1之间能被3整除的数\njavapublic class TestFor &#123;\n\n    public static void main(String[] args) &#123;\n        for (int i = 90; i &gt;= 1; i--) &#123;\n            if (i % 3 == 0) &#123;\n                System.out.println(i + &quot;\\t&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\ndo-while循环♻️\n\n语法结构：\njavado&#123;\n    循环体;\n&#125;while(布尔表达式);\n嵌套循环♻️1⃣️执行结果如下所示：\njava1 1 1 1 1\n2 2 2 2 2\n3 3 3 3 3\n4 4 4 4 4\n5 5 5 5 5javapublic class TestLoop2 &#123;\n\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 5; i++) &#123;\n            for (int j = 1; j &lt;= 5; j++) &#123;\n                System.out.print(i + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\n2⃣️输出9*9乘法口诀表:\njava1 * 1 = 1\t\n1 * 2 = 2\t2 * 2 = 4\t\n1 * 3 = 3\t2 * 3 = 6\t3 * 3 = 9\t\n1 * 4 = 4\t2 * 4 = 8\t3 * 4 = 12\t4 * 4 = 16\t\n1 * 5 = 5\t2 * 5 = 10\t3 * 5 = 15\t4 * 5 = 20\t5 * 5 = 25\t\n1 * 6 = 6\t2 * 6 = 12\t3 * 6 = 18\t4 * 6 = 24\t5 * 6 = 30\t6 * 6 = 36\t\n1 * 7 = 7\t2 * 7 = 14\t3 * 7 = 21\t4 * 7 = 28\t5 * 7 = 35\t6 * 7 = 42\t7 * 7 = 49\t\n1 * 8 = 8\t2 * 8 = 16\t3 * 8 = 24\t4 * 8 = 32\t5 * 8 = 40\t6 * 8 = 48\t7 * 8 = 56\t8 * 8 = 64\t\n...javapublic class TestLoop2 &#123;\n\n    public static void main(String[] args) &#123;\n        for (int i = 1; i &lt;= 9; i++) &#123;\n            for (int j = 1; j &lt;= i; j++) &#123;\n                System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + i * j + &quot;\\t&quot;);\n            &#125;\n            System.out.println();\n        &#125;\n    &#125;\n&#125;\nbreak语句和continue语句\nbreak语句用于强行退出整个循环♻️\ncontinue语句用于结束本次循环，继续下一次循环\n\n\n\n练习题：\njava/**\n * 测试breal语句\n * 产生100以内的随机数 知道随机数为88 终止循环\n */\n\npublic class TestBreak &#123;\n\n    public static void main(String[] args) &#123;\n        int total = 0;\n        while (true) &#123;\n            total++;\n            int i = (int) (Math.random() * 100);\n            System.out.println(i);\n            if (i == 88) &#123;\n                break;\n            &#125;\n        &#125;\n        System.out.println(&quot;循环次数：&quot; + total);\n    &#125;\n&#125;\njava/**\n * 测试continue语句\n * 把100-150之间不能被3整除的数输出，并且每行输出5个\n */\n\npublic class TestContinue &#123;\n\n    public static void main(String[] args) &#123;\n        int count = 0;\n\n        for (int i = 100; i &lt;= 150; i++) &#123;\n            if (i % 3 == 0) &#123;\n                continue;\n            &#125;\n            System.out.print(i + &quot;\\t&quot;);\n            count++;\n            if (count == 5) &#123;\n                System.out.println();\n                count = 0;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n带标签的continue“标签”是指后面跟一个冒号的标识符 例如 label 。 对Java来说唯一用到标签的地方是循环语句之前。\n“go to 有害”论中，最多有问题的就是变迁，而非 to go。随着标签在一个程序里数量的增多，产生错误的机会也越来越多。但Java标签不会造成这方面的问题，因为它们的活动产所已被限制死，不可通过特别的方式到处传递程序的控制权。\njava/**\n * 打印101-150之间的所有质数\n */\n\npublic class TestCountinue02 &#123;\n\n    public static void main(String[] args) &#123;\n        outer:\n        for (int i = 101; i &lt; 150; i++) &#123;\n            for (int j = 2; j &lt; i / 2; j++) &#123;\n                if (i % j == 0) &#123;\n                    continue outer; //符合条件跳到外部循环继续\n                &#125;\n            &#125;\n            System.out.print(i + &quot; &quot;);\n        &#125;\n    &#125;\n&#125;\n❓年薪计算器程序\n通过键盘输入用户的月薪，每年是几个月薪水。\n输出用户的年薪。\n如果年薪超过10万则恭喜超过90%的国人，如果年薪超过20万则恭喜超过98%的国人。\n直到键盘输入数字88，则退出程序（使用break退出循环）。\n键盘输入66，则这个用户退出计算不显示恭喜…，直接显示“重新开始计算…”，然后计算下一个用户的年薪。\n\njavaimport java.util.Scanner;\n\n/**\n * 年薪计算器程序\n *\n * @author chan_honman\n * @version 1.0\n */\n\npublic class SalaryCalculator &#123;\n\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n\n\n        outer:\n        while (true) &#123;\n\n            System.out.println(&quot;请输入您的月薪：&quot;);\n            int monthlySalary = sc.nextInt();\n            if (monthlySalary == 88) &#123;\n                break;\n            &#125;\n\n            System.out.println(&quot;请输入您每年是有几个月薪水：&quot;);\n            int month = sc.nextInt();\n            if (month == 66) &#123;\n                System.out.println(&quot;重新开始计算...\\n&quot;);\n                continue outer;\n            &#125;\n\n            int annualSalary = monthlySalary * month;\n            System.out.println(&quot;您的年薪为：&quot; + annualSalary + &quot;元&quot;);\n\n            if (annualSalary &gt; 200000) &#123;\n                System.out.println(&quot;恭喜您的年薪超过98%的国人！！！\\n&quot;);\n            &#125; else if (annualSalary &gt; 100000) &#123;\n                System.out.println(&quot;恭喜您的年薪超过90%的国人！！！\\n&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;继续加油争取年薪过10万吧！！！\\n&quot;);\n            &#125;\n        &#125;\n\n\n    &#125;\n&#125;\nupdating……….\n","slug":"后端/Java/Java基础","date":"2022-10-26T08:32:00.000Z","categories_index":"计算机,后端","tags_index":"笔记,Java","author_index":"Honman"},{"id":"7525935f3d7857db9f6e83da3969ebe0","title":"《乔布斯激情演讲》","content":"《乔布斯激情演讲》江涛Stay Hungry, Stay Foolish求知若饥，虚心若愚——史蒂夫·乔布斯2005年在斯坦福大学演讲\n​\t2005年6月，未能读完大学就半途退学，但后来功成名就的乔布斯被邀请到斯坦福大学的毕业典礼上发表演说。那时，他刚完成胰腺癌手术。\n​\t在这次演说上，乔布斯面对那些马上就要离开校园的学生们，用真诚的语气叙述了他到今天为止的人生历程。这个演讲在斯坦福大学的网站公布以后，收到了很多人的关注，广为流传。在这次演说中，乔布斯提到一下三点：\n​\t关于人生的转折点（Connecting the dots）\n​\t“所以你必须相信，现在你所做的点点滴滴都在将来会以某种方式联系起来。你必须相信一些东西——无论是你的勇气、命运、人生，还是因果循环，等等——因为只有相信这些点点滴滴将会窗帘一起，你猜才有信心跟随自己的内心走下去……”\n​\t爱和损失（Love and loss）\n​\t“你的工作将会占据你人生的一大部分，唯一能够让你真正感到满足的方法，就是从事自己认为很伟大的事业，而唯一能够让你成就伟大的事业的方法就是热爱你所做的工作……”\n​\t关于死亡（Death）\n​\t“如果今天是我人生中最后一天，我想做今天将要做的事吗？只要连续几天回答都是‘不’的时候，我就知道，我需要改变一些东西…….”\n​\t乔布斯还特别强调了自己是多么热爱自己的事业，激励斯坦福的毕业生们去寻找他们最喜欢的事业，并鼓励他们“求知若饥，虚心若愚“。\n\n\n\n\n\n\n\n\n\nAgain,you can’t connect the dots looking forward.You can only connect them looking backwards ,so you have to trust that dots will somehow connect in your future.\n我再重复一遍，你无法预先将人生中的点点滴滴联系在一起。只有在将来，当你回首时，才会发现它们之间是有联系的。所以你必须相信，现在你所做的点点滴滴在将来会以某种方式联系起来。\n\n\n\n\n\n\n\n\n\nYou have to trust in something—your gut, destiny, life, karma , whatever—because beliveing that the dots will connect down the road will give you the the confidence to follow your heart, even when it leads you off the well-worn path, and that will make all the difference.\n 你必须相信一些东西—无论是你的勇气、命运、人生，还是 因果循环，等等—因为只有相信这些点点滴滴将会串联在一起，你才有信心跟随自己的内心走下去，即使它引导你走上一条无人踏足的道路，也会起到至关重要的作用。\n\n\n\n\n\n\n\n\n\n Your work is going to fll a large part of your life ,and the only way to be truly satisfied is to do what you believe is great work, and the only way to do great work is to love what you do.\n 你的工作将会占据你人生的一大部分，唯一能够让你真正感到满足的方法，就是从事自己认为很伟大的事业，而唯一能够让你成就伟大事业的方法就是热爱你所做的工作。\n\n\n\n\n\n\n\n\n\n Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma, which is living with the result of other people’s thinking. Don’t let the noise of other’s opinions drown out your own inner voice, heart and intuition.\n 你们的时间有限，所以不要浪费时间追随别人追随的生活。不要被教条所束缚，不要活在别人的想法里。不要让别人喧闹的观点淹没了自己的心声、心灵和直觉。\nTo Make Apple Healthy Again(Part 1)重振苹果雄风（一）——史蒂夫·乔布斯1997年8月6日在苹果年度大会上的演讲\n\n\n\n\n\n\n\n\n\nApple is executing wonderfully on many of the wrong things. The ability of the organization to execute is really high, though.\n苹果在很多错误的决策上都执行得非常好，但这也反映出这个机构的执行力还是很高的。\n\n\n\n\n\n\n\n\n\nWe would like to do a lot more in terms of software, and we thought having some software industry expertise on the Board would be a good idea.\n苹果也想在软件上大显身手，所以我们认为，邀请一些软件行业的专家参与董事会是个不错的注意。\n\n\n\n\n\n\n\n\n\nI think we habe a really exciting task ahead of us: to help the management team and guide Apple back to health and prosperity.\n摆在我们面前的是一个非常令人振奋的任务，那就是帮助管理团队，使苹果重整旗鼓，重振雄风。\n\n\n\n\n\n\n\n\n\nApple’s greatest core assets are you all. It’s the group of 20-25 million active users that believe that Apple products and Macintosh is still the best in the world.\n苹果最伟大的核心资产就是在座的各位，就是2000万到2500万的苹果用户——他们相信苹果产品和麦金塔电脑在世界 上仍旧首屈一指。\nTo Make Apple Healthy Again(Part 2)重振苹果雄风（二）——史蒂夫·乔布斯1997年8月6日在苹果年度大会上的演讲\n\n\n\n\n\n\n\n\n\nApple lives in an ecosystem,and it needs help from other partners. It needs to help other partners. And relationships that are destructive don’t help anybody in this industry as it is today.\n苹果生存在一个产业生态系统中，它需要其他合作伙伴的帮助，同时也要给其他伙伴提供帮助。在现今这个行业你，无益的伙伴关系对任何人都毫无用处。\n\n\n\n\n\n\n\n\n\nAnd if we want to move forward, and see Apple healthy and prospering again, we have to let go of a few things here. We have to let go oof this notion that for Apple to win Microsoft has to lose.\n如果我们要前进，要看到苹果繁荣复兴，就必须放弃一些东西。我们要摒弃这样一种观念，即苹果和微软之间是一场你生我死的较量。\n\n\n\n\n\n\n\n\n\nThe last perspective I’d like to leave with you on this is sometimes points of vieew can really make you look at things differently.\n我想跟你们分享的最后一个观点是，有时候看事物的角度不同，看到的事情也会不一样。\n\n\n\n\n\n\n\n\n\nBecause a lot of times people think that they’re crazy. But in that craziness, we see genius, and those are the people we’re making tools for.\n很多时候，人们觉得这些人太疯狂了。但就是在那种狂热中，我们看到了天才，我们制造工具就是为了他们。\nInnovation and Creativity改革创新——史蒂夫乔布斯于1982年6月在美国学术成就大会上的演讲\n​\t1982年6月，乔不是受邀出席美国学术成就大会，并发表演讲。当时他只有27岁，当年他自己一夜之间身价暴涨，并于这一年首次登上《时代》周刊封面。\n​\t在这篇演讲中，他围绕改革创新这个老话题表达他自己的理解和看法。其实主要就是说要环保\n\n\n\n\n\n\n\n\n\nOne of the things that tends to run through some of the things that people here have talked about is innovation and creativity.\n人们常常谈论和关注的话题之一就是创新和创造。\n\n\n\n\n\n\n\n\n\nSo, what you’re got to do is get different experiences than the normal course of events.\n所以，你要做的就是体验不同的人生经历，而不是按部就班地生活。\n\n\n\n\n\n\n\n\n\nThe people actually making these decisions everyday, that are sort of running the world, are not really very much different than you. And they might have a little more judgment in some areas, but basically they’re the same.\n每天都在做决定的这些人，这些掌控世界的人与你相比并没有很大的区别。或许他们在某些领域拥有更强的判断力，但根本上讲，大家都是一样的。\n\n\n\n\n\n\n\n\n\nYou as a human being in herit the responsibility of being a guardian of the Earth for future generations—of which you are all a member to inherit.\n作为人类，你们传承啦为后世当担地球卫士的责任——你们每个人都传承啦这一职责。\nA Fledgling’s Great Wisdom初生牛犊的大智慧——乔布斯1983年在苹果公司浮动大会上的讲话\n​\t1983年，才成立五年的苹果，凭借其研发的世界第一台个人电脑 Apple II 迅速打入市场，与IBM成为当时行业内最强的两个竞争对手。这段话是苹果年度股东大会上，乔布斯对公司近几年的发展历程与成果所作的总结。\n​\t在讲话中，乔布斯对苹果充满自信，诙谐（言谈幽默风趣，引人发笑。）地讽刺了蓝色巨人IBM的自傲，展示了苹果公司强劲的发展势头，并认为苹果才是未来计算机行业的领跑者。\n​\t在演讲中，乔布斯讲了以下几点：\n\n“IBM对此不屑一顾，认为微型电脑太小，不能做大型运算，所以对其业务来说微不足道……IBM仍旧不屑一顾，认为个人电脑太小，不能做大型运算，对其业务来说不值一提…….”\n“1981年，Apple II 成为全球最受欢迎的电脑，苹果公司市值也增长到三亿美元，成为美国商业历史上发展最迅猛的一家企业……”\n“行业调整正愈演愈烈——第一家大公司破产了，其他许多公司也在破产的边缘挣扎。1983年，整个计算机行业的损失比苹果和IBM个人电脑的盈利总和还多…….” 乔布斯用极其自信的口吻描绘出一副苹果光明的未来图景，尤其是最后播放的一段广告，将苹果的野性充分表现出来，昭示着苹果的最终胜利。\n\n\n\n\n\n\n\n\n\n\nIn 1977, Apple, a young fledgling company on the West Coast, invents the Apple II, the first personal computer as know it today.\n1977年，苹果公司，一家位于西海岸的年轻的羽翼未丰的公司，发明了Apple II，即今天所知的第一台个人电脑。\n\n\n\n\n\n\n\n\n\nIt appears IBM wants it all. Apple is perceived to be the only hope to offer IBM a run for its money.\nIBM似乎想要这一切。苹果被认为是与IBM竞争的唯一希望。\n\n\n\n\n\n\n\n\n\nDealers, initially welcoming IBM with open arms, now fear an IBM-dominated and controlled future. They are increasingly and desperately turning back to Apple as the only force that can ensure their future freedom.\n经销商最初张开双臂欢迎IBM，现在却担心未来由IBM主导和控制。他们越来越绝望地转向苹果，认为苹果是确保他们未来自由的唯一力量。\n\n\n\n\n\n\n\n\n\nOn January 24th Apple Computer will introduce Macintosh. And you’ll see why 1984 won’t be like 1984.\n1月24日，苹果电脑公司将推出麦金塔（Macintosh）。你会明白为什么《1984》的梦魇不会在1984年出现。\nMother Ship Will Land Here in Cupertino苹果飞船即将着陆库比蒂诺——乔布斯在2011年辞职前在库比蒂诺的公开演讲\n​\t2011年6月，在刚刚发布了“云服务”（iCould）后，苹果首席执行官（CEO）乔布斯又发布了一个“新产品”——建造飞船形状的苹果公司新总部。这就是他在库比蒂诺市区的演讲，也是辞职前最后一次公开演讲。\n​\t在这次演讲上，他向大家报告了苹果公司的发展规模和近期的规划。打算在加利福尼亚州库比蒂诺市区新建一个飞船一样的Apple总部大楼，占地150英亩的“全球最佳办公大楼”，当时预计在2015年完工，据说能容纳12000名苹果员工。在这次演说中，乔布斯讲到了三点：\n​\t扩大办公区域 Expansion of space\n​\t很显然，我们需要建造新的园区，于是就扩大面积。但不意味着我们要废弃现在用的办公区，我们仍然需要它，只是还需要另外一片地来扩大总部办公区域而已。\n​\t办公楼蓝图 Blueprint of the building\n​\t他就像一个着陆的太空飞船，没错，这栋楼中间还有一个漂亮的庭院，但是远远不止这些。我们再仔细看看：整栋楼的外观呈原形，每一处都是弧线设计。如果要建造什么，这绝对不是最廉洁的方式。这栋楼里的玻璃，没有一块是水平的，全都是弧形设计。如今，我们将这些经验用在建造世界各地的苹果零售店中，我们懂得如何将世界最大的玻璃用于建筑中。\n​\t期待最终的胜利 Expectation of final success\n​\t整栋楼必须设计有严格要求的安全设备。然而我们要做的远不止这些。把苹果建在库比蒂诺的难题并不是交通。我们担心的是运营效果不够好。如果我们都相信会成功，那当然最好了。\n​\t乔布斯对关于建筑总部新办公楼的计划非常有信心，特别是在讲到大楼的“飞船”外观时显得尤为兴奋，可见设计图耗费了多少心血。这是他在辞职前的最后一次公开演讲，对即将建成的苹果新总部充满期待。\n","slug":"Reading Book/《乔布斯激情演讲》江涛","date":"2022-09-21T09:30:00.000Z","categories_index":"Reading Book","tags_index":"Reading Book","author_index":"Honman"},{"id":"3f5d3d267589901b817d54b9b16a9af3","title":"《西西弗神话》Albert Camus","content":"《西西弗神话》Albert Camus荒诞与自杀真正严肃的哲学问题只有一个，那就是自杀。\n\n\n\n\n\n\n\n\n\n我发现有很多人死去，是因为他们认为生命不值得继续。更奇怪的是，还有些人，却是为了支持他们活下去的想法和幻想慷慨赴死。\n\n\n\n\n\n\n\n\n\n自杀，在某种程度上，就像在情节剧中一般，是一种承认。承认我们被生活超越，或者承认我们没有理解生活。\n\n\n\n\n\n\n\n\n\n一个能用种种歪理来解释的世界毕竟还是我们熟悉的世界。但是，在一个突然被剥夺了幻觉和光的宇宙你，人会感到身处局外。\n\n\n\n\n\n\n\n\n\n我们早在学会思想之前就已经习惯于活着。在这让我们每天都离死亡要再近一点的生命进程中，身体始终前往，不可能回头。\n","slug":"Reading Book/《西西弗神话》Albert Camus","date":"2022-09-19T02:23:00.000Z","categories_index":"Reading Book","tags_index":"Reading Book","author_index":"Honman"},{"id":"9392181fceba07d9349f73eda58d6a50","title":"升本英语","content":"英语句子成分\n\n\n\n\n\n\n\n\n​\t英语中的句子成分主要包括：主语、谓语、宾语、定语、状语、标语、补足语、同位语。\neg：I(主) noticed（谓） my（定语） friend（宾语） Jack（同位语） walking（宾语补足语） in the garden（状语）.\n1.主语\n\n\n\n\n\n\n\n\n主语通常由名次、代词、数词、不定式、动名词、从句等来充当。\n2.谓语\n\n\n\n\n\n\n\n\n其实就是动词。\n​\t谓语表示主语的欣慰动作或所处状态，有时态、语态、和语气的变化。谓语一般谓语主语后面，要注意人称和数方面与主语保持一致。\n​\t谓语动词有5种形式，原形、第三人称单数、-ing、过去式、过去分词。\n1.动词的第三人称单数（三单）1.一般情况下，直接在动词后面加-s。\n\n\n\n\n\n\n\n\n\nrun - runs\ttake - takes\ttreat（对待） - treats\n2.以-s,-x,-sh,-ch，-o结尾的动词，在后面+es。\n\n\n\n\n\n\n\n\n\nmiss - misses\tfix - fixes\tfinish - finishes\n3.以辅音字母+y结尾的动词，要把y改 ’i‘ + ‘es’。\n\n\n\n\n\n\n\n\n\ncarry（扛、提、支撑） + carries\n4.以元音字母+y结尾的动词，直接+ ‘s’。\n\n\n\n\n\n\n\n\n\nplay - plays\n5.有个别动词不规则变三单的。\n\n\n\n\n\n\n\n\n\nhave - has\tbe - is&#x2F;was\n2.动词的-ing形式1.一般情况下直接加ing。\n2.以e结尾的去掉e，再+ing。以ee结尾的直接+ing。\n3.以辅音+元音+辅音字母结尾的，先双写最后一个辅音字母再+ing。\n\n\n\n\n\n\n\n\n\nstop - stopping\tchat （聊天）- chatting\tdrop（丢） - dropping\tnod（打盹、点头） - nodding\tbegin（开始） - beginning\tforget - forgetting\n3.过去式和过去分词形式1.一般直接+ed。\n2.以不发音的e结尾的，只加d。\n3.以辅音字母+y结尾的，把y改‘i’+‘ed’。元音字母+y结尾的直接+ed\n4.以一个辅音字母结尾的重读闭音节，先算写词尾的辅音字母再+ed。\n5.还有一些是不规则变化的。\n3.宾语1.直接宾语主要表示动作的直接对象或结果。\n\n\n\n\n\n\n\n\n\nYou will understand me better.你会对我更了解。\n2.间接宾语简介宾语表示动作的间接对象，即动作是“对谁做的”或“为谁做的”。间接宾语一般指人，不单独使用。且一般谓语直接宾语之前。\n\n\n\n\n\n\n\n\n\nThe teacher will send me a letter.那位老师会寄给我一封信。\n3.复合宾语由宾语+宾语补足语构成。\n\n\n\n\n\n\n\n\n\nWe have to keep the classroom（宾语） clean（宾补足）.我们得保持教室干净。\n4.定语修饰名词或代词，说明其性质、品质、特征等。\n\n\n\n\n\n\n\n\n\nShe had a happy holiday.\n5.状语修饰动词、形容词、副词、整个句子，表示时间、地点、原因、结果、成都、条件等。\n\n\n\n\n\n\n\n\n\nDon’t step on the grass.\n6.表语说明主语的特征、属性、状态、状态等。\n\n\n\n\n\n\n\n\n\nMy father is a teacher.\n7.补足语说明主语或宾语等性质、状态等。\n\n\n\n\n\n\n\n\n\nWe all find him funny.\n8.同位语对句子某一成分的说明或解释。\n\n\n\n\n\n\n\n\n\nThey all wanted to visit him.\n句子种类\n\n\n\n\n\n\n\n\n句子可分为四类：陈述句、疑问句、祈使句、感叹句。\n1.陈述句\n\n\n\n\n\n\n\n\n陈述句有两种：肯定句、否定句。\n陈述句用用来陈述一个事实或表达看法等，句末用句号。\n肯定句\n\n\n\n\n\n\n\n\nI cooked fish soup the day before yesterday.\n我前天煮了鱼汤。\n否定句\n谓语部分是实义动词或含有情态动词have、has、had to时，在谓语动词前加don’t、doesn’、didn’t。\n谓语部分含有be动词、助动词或情态动词时，否定形式通常是在这些动词之后加not。\n一些否否定词或否定短语也可以构成否定式，如nothing、too…to…、hardly、seldom、no、never、not…at all、not…any more、longer。\n\n2.疑问句\n\n\n\n\n\n\n\n\n疑问句有四种：一般疑问句、特殊疑问句、选择疑问句、反意疑问句。\n一般疑问句常用结构：\nbe动词+主语+表语…?\n助动词&#x2F;情态动词+主语+动词….?\n\n回答\nYes or No\n\n一般疑问句还可以用certainly, of course,I think so,never,I’m afraid not来回答。\n\n\n特殊疑问句特俗疑问句由疑问代词（what、which、who、whom、whose）和疑问副词（how、when、where、why）来引导。\n选择疑问句结构：\n一般疑问句（包括第一选项）+or+第二选项？\n特殊疑问句+第一选项+or+第二选项？\n\n\n\n\n\n\n\n\n\n\nAre you from Canada or England?\nI’m from Canada.\n\n\n\n\n\n\n\n\n\nWhat is your father,a teacher or a doctor?\nHe is a doctor.\n反意疑问句在陈述句后面附上一个简短问句，表示对前述事实或观点的质疑、强调求证。\n\n\n\n\n\n\n\n\n\nYou often go shopping,don’t you?\n3.祈使句\n\n\n\n\n\n\n\n\n祈使句分为两种：肯定形式、否定形式。\n肯定形式\n\n\n\n\n\n\n\n\nRead the sentence again,Please.\n否定形式\n\n\n\n\n\n\n\n\nDon’t do that.\n4.感叹句\n\n\n\n\n\n\n\n\n定义： 用来表示喜怒哀乐等强烈感情，常由what或how引出。\nHow sad she is!\n句子结构\n\n\n\n\n\n\n\n\n句子结构可以分为三类：简单句、并列句、复合句。\n\n\n\n英\n汉\n\n\n\nSubject\n主语\n\n\nVerb\n动词\n\n\nObject\n宾语\n\n\nObject Complement\n宾语补足语\n\n\nIndirect Object\n间接宾语\n\n\nDirect Object\n直接宾语\n\n\nPredicative\n表语\n\n\n简单句\n\n\n\n\n\n\n\n\n一个主谓结构的句子叫做简单句\n\n\n\n五种句型\n例句\n\n\n\nSubject+Verb\nThe baby cries.\n\n\nSubject+Verb+Object\nI read the news.\n\n\nSubject+Verb+Object+Object Complement\nWe make the room comfortable.\n\n\nSubject+Verb+Indirect Object+Direct Object\nThis book brings me a lot of fun.\n\n\nSubject+Linking Verb+Predicative\nHe is an actor.\n\n\n1.Subject + Verb这种结构的谓语通常是不及物动词（后面不能直接+宾语）。\n\n\n\n\n\n\n\n\n\nMy head  aches. 我头痛。    主语\t  宾语\nThe children are sleeping. 孩子们正在睡觉。                              宾语\n2.Subject + Verb + Object这种结构的谓语通常是及物动词，其后面能直接跟宾语。\n\n\n\n\n\n\n\n\n\nNobody  could answer  the question. 没有人能回答这个问题。主语\t\t\t  谓语\t\t\t\t 宾语\n3.Subject + Verb + Object + Object Complement\n\n\n\n\n\n\n\n\nWorkers  painted  the wall     blue. 工人们把墙漆成了蓝色。主语 \t  谓语\t\t 宾语     宾语补足语\n4.Subject + Verb + Indirect Object + Direct Object\n\n\n\n\n\n\n\n\nDavid    shows       me        the way. 大卫为我指了路。主语      谓语      间接宾语   直接宾语\n5.Subject + Linking Verb + Predicative这种句型中的动词为连系动词，谓语有连系动词和表语组成。\n\n\n\n\n\n\n\n\n\nThat   car         is           mine. 那辆车是我的。 主语        连系动词     表语\nAll the tourists   seem   happy. 所有游客看起来都挺开心。\n并列句由两个或两个以上相互之间没有依从关系的简单句合在一起构成。\n\n\n\n\n\n\n\n\n\nWe study hard and our teacher often praises us. 我们努力学习，老师经常表扬我们。\n复合句复合句由一个主句和一个或一个以上的从句构成。 主句是全句的主体。\n从句充当某种成分，不能独立存在。复合句包括名词性从句、定语从句、状语从句。\n\n\n\n\n\n\n\n\n\nThat English is ver important is an undoubted fact.（That引导主语从句）\nThis is my friend who is good at playing the violin.（who引导定语从句）\nIt began to rain as soon sa I arrived at school.（as soon sa引导时间状语从句）\n时态与语法动词时态必须掌握的12种时态如下表所示：\n\n\n\n\n现在\n过去\n将来\n过去将来\n\n\n\n一般\n动词原形、第三人称单数\n动词过去式\nshall、will+动词原形\nshould、would+动词原形\n\n\n进行\nam、is、are+现在分词\nwas、were+现在分词\nshall、whill be+现在分词\nshould、would be+现在分词\n\n\n完成\nhave、has+过去分词\nhad+过去分词\nshall、will have+过去分词\nshould、would have been+现在分词\n\n\n完成进行\nhave、has been+现在分词\nhad been+现在分词\nshall、will have been+现在分词\nshould、would have been+现在分词\n\n\n一般时一般现在时1.表示经常性或习惯性的动作或存在的状态。\n常于表示频率的时间状语连用。如：always总是、often常常、usually、sometimes、rarely很少、once a week一周一次、every day、now and then偶尔、from time to time不时、有时。\n\n\n\n\n\n\n\n\n\nI always ravel by underground.\n我总是乘坐地铁出行。\n2.表示特征、能力或现在的情况、状态。\n\n\n\n\n\n\n\n\n\nThe foregin man standing in the doorway speaks Chinese.\n站在门口的那位外国男士会讲中文。\n3.表示格言、客观事实或普遍真理。\n\n\n\n\n\n\n\n\n\nIn fact, contradictions exist everywhere.\n事实上，矛盾无处不在。\n4.表示安排或计划好的将要发生的动作，或表示按时间表将要发生的动作，这种安排不可更改或随意变动，句中常有一个表示将来的时间状语。\n常用这类动词有：be、arrive、come、go、start、begin、leave、return、end、stop、require。\n\n\n\n\n\n\n\n\n\nThe concert begins at 7:00 p.m. and ends at 9:30 p.m.\n音乐会将于晚上7点开始，9点30分结束。 \n5.在含有时间或条件状语从句的主从复合句中，若主句用一般将来时，从句常用一般现在时表将来，即“主将从现”的原则。\n\n\n\n\n\n\n\n\n\nWe will discuss the matter when we meet tomorrow.\n我们明天见面是将会讨论这件事。\n一般过去时1.表示在过去某个特定时间内发生的动作或存在的状态。\n常于表示过去的时间状语连用如：a moment、last night、Friday、week、month、year、yesterday、the other day、in the past、in 1995。但是有时候没有过去的时间状语，要通过上下文去推断出来。\n\n\n\n\n\n\n\n\n\nHe and his friends visted the Great Wall last year.\n去年他和他的朋友们参加了长城。\n2.表示过去一段时间见内经常性或习惯性的动作或存在的状态。常于时间状语从句连用：often、usually、seldom。\n一般将来时一般将来时常于笑死将来的时间状语连用：the day aften、tomorrow、next week、month、year、in two minutes、soon、some day。\n1.“shall&#x2F;will+动词原形”表示将要发生的动作或存在的状态。shall用于第一人称，will可用于各个人称。\n\n\n\n\n\n\n\n\n\nThe teacher will praise you four progress.\n老师会因为你的进步而表扬你。\n2.“am,is,are going to + 动词原形”表示主观打算做某事或有迹象表明即将发生某事。\n\n\n\n\n\n\n\n\n\nIt is cloudy. I think it is going to rain soon.\n天空乌云密布，我感觉很快就要下雨了。\n3.am,is,are+不定式 表示安排、计划、约定、意图、职责、义务、命令或要求必须做的事或即将发生的动作。\n\n\n\n\n\n\n\n\n\nThe Prime Minister is to visit China tomorrow.\n首相将于明天访问中国。\n4.am,is,are about+不定式 表示真要或即将发生的动作，不能与表示将来的时间状语连用。\n\n\n\n\n\n\n\n\n\nThe new school year is about to begin.\n新学年就要开始了。\n5.am,is,are + 现在分词（位移动词）表示在不久的将来要做的事、按计划、安排将要发生某事。这类的动词有go、come、leave、start、begin、arrive、stay、take off。\n\n\n\n\n\n\n\n\n\nI’m going to John’s house next Sunday.\n下周日我要去约翰家。\n6.在祈使句+and&#x2F;or+陈述句结构中，前面的祈使句部分表示条件，而and&#x2F;or后面的句子应用一般将来时。\n\n\n\n\n\n\n\n\n\nGive me one more hour,and I’ll finish the work.\n再多给我一个小时，我就会完成这项工作。\n进行时现在进行时1.表示现在、目前或现阶段正在进行的动作或发生的事情。与之连用的时间状语：now、at the moment、right now、these days、this week、today、nowadays、at present。\n\n\n\n\n\n\n\n\n\nGeorge is making a list of books to read now.\n乔治正在列要读的书籍清单。\n2.与always、forever、constantly副词连用，表达感情。\n\n\n\n\n\n\n\n\n\nThe little boy is always thinking of others.\n那个小男孩总是为别人着想。\n过去进行时表示在过去某一时刻、某段时间内或某个动作发生时正在进行的动作。与之连用的时间状语：at that time、this time yesterday、the whole morning。此外当句中有when、while引导的时间状语从句是，主语也可用过去进行时。\n\n\n\n\n\n\n\n\n\nWe were talking about the new book at that time.\n那时候我们正在谈论那本新书。\n将来进行时表示在将来某一时刻、时间段内、某个动作发生时正在进行的动作、按计划在将来某一时刻、某段时间内或某个动作发生时将要进行的动作。与之连用的时间状语this time tomorrow、next week、next month、at 8 a.m. tomorrow、in the next three weeks、tomorrow。\n\n\n\n\n\n\n\n\n\nThis time tomorrow we shall&#x2F;will be working in that factory.\n明天这个时候，我们将正在那个工厂干活。\n完成时现在完成时1.表示已经做过的事，强调过去发生的动作或事情，对现在的影响或产生的结果。与之连用的时间状语有，不确定的过去时间状语如already,yet,just,before,lately,recently.表示频度的时间状语，如ever,never,once,twice。\n\n\n\n\n\n\n\n\n\nThe company has already laid off 10000 employees.\n该公司已经裁员一万名员工了。\n2.表示过去的某一动作或行为一直持续到现在，而且还有可能延续下去。与之连用的时间状语：since,since+时间点,so far, up to now, until now, for +时间段, these days&#x2F;weeks&#x2F;months&#x2F;years。\n\n\n\n\n\n\n\n\n\nI have worked in this company since 2011.\n自从2011年以来，我一直在这家公司工作。\n过去完成时主语 + had + 过去分词。\n将来完成时主语 + shall&#x2F;will have + 过去分词。\n完成进行时现在完成进行时主语+have&#x2F;has been + 现在分词。\n过去完成进行时主语+had+ been + 现在分词。\n过去完成将来时主语 + should&#x2F;would + 动词原形。\n被动语态被动语态的用法1.当不知道或没有必要指出动作的执行者时。\n\n\n\n\n\n\n\n\n\nPrinting was introduced into Europe from China.\n2.强调或突出动作的承受者时。\n\n\n\n\n\n\n\n\n\n The three-year plan was very successfully carried out.\n常用的十种被动语态\n\n\n常用被动语态\n构成\n常用被动语态\n构成\n\n\n\n一般现在时\nam&#x2F;is&#x2F;are + 过去分词\n现在完成时\nhave&#x2F;has been + 过去分词\n\n\n一般过去时\nwas&#x2F;were + 过去分词\n过去完成时\nhad been + 过去分词\n\n\n一般将来时\nshall&#x2F;will be + 过去分词\n将来完成时\nshall&#x2F;will have been + 过去分词\n\n\n现在进行时\nam&#x2F;is&#x2F;are being + 过去分词\n过去将来完成时\nshould&#x2F;would have been + 过去分词\n\n\n过去进行时\nwas&#x2F;were being + 过去分词\n过去将来时\nshould&#x2F;would be + 过去分词\n\n\n主动表被动的情况1.某些表示主语品质或者特性的动词如read，write，draw，wash清洗，clean，bake烤，burn燃烧，open，lock锁，cut，shut关闭，sell出售，wear穿戴，move，常于well，easily，smoothly顺利地 等副词连用，用主动形式表示被动意义，主语通常是“物”。此时这些动词用作不及物动词。\n\n\n\n\n\n\n\n\n\nThe new ballpoint writes very smoothly.\n那支新圆珠笔写起来很流畅。\n2.一些连系动词的主动形式可以表示被动意义，如feel，look，seem，appear，taste，sound，smell，prove等。主语通常是“物”。\n\n\n\n\n\n\n\n\n\nThis shirt feels much softer than that one.\n这件衬衫比那件摸起来要柔软得多。\n虚拟语气虚拟语气在非真实条件句及主句中的用法\n\n\n区别\n从句的谓语动词\n主句的谓语动词\n\n\n\n假设过去情况\nhad+过去分词\nshould、would、could、might have + 过去分词\n\n\n假设现在情况\n动词的过去式（be动词用were）\nshould、would、could、might + 动词原形\n\n\n假设将来情况\n1. 动词的过去式（be动词用were）、2. should+动词原形、3. were to + 动词原形\nshould、would、could、might + 动词原形\n\n\n虚拟语气在名词性从句中的用法\n\n\n从句类型\n句型\n从句谓语动词的形式\n\n\n\n主语从句\nIt is &#x2F; was +形容词+主语从句、It is &#x2F; was +名词+主语从句、It is &#x2F; was +过去分词+主语从句\nshould+动词原形，shoulde可以省略。\n\n\n宾语从句\n表示建议、命令、要求、等含义的动词+宾语从句。consider &#x2F; deem &#x2F; think…+it+形容词+宾语从句、wish+宾语从句。would rather &#x2F; would sooner &#x2F; would (just) as soon &#x2F; would prefer… + 宾语从句。\nshould+动词原形，shoulde可以省略。用过去式（be动词用were）表示现在情况的假设，用had+过去分词的形式表示对过去情况的假设，用would &#x2F; could &#x2F; might +动词原形的形式表示对将来情况的假设。用过去式（be动词用were）表示现在情况的假设，用had+过去分词的形式表示对过去情况的假设。\n\n\n表语从句和同位语从句\n表示建议、命令、要求、主张、计划、愿望等含义的名词后的表语从句和同位语从句。as if &#x2F; as though引导的表语从句\n用过去式（be动词用were）表示对现在情况的假设。用had+过去分词的形式表示对过去情况的假设。用would &#x2F; could &#x2F; might + 动词原形的形式表示对将来情况的假设。\n\n\n虚拟语气在状语从句中的用法\n\n\n从句类型\n引导词\n从句谓语动词的形式\n\n\n\n方式状语从句\nas if、as thought\n用过去式（be动词用were）表示对现在情况的假设。用had+过去分词的形式表示对过去情况的假设。用would&#x2F;could&#x2F;might+动词原形的形式表示对将来情况的假设。\n\n\n目的状语从句\nso that、in order thatlest（以免）、for fear（that）（以防万一，以免）、in case（万一）\ncan&#x2F;may&#x2F;should&#x2F;will&#x2F;could&#x2F;might&#x2F;would+动词原形should+动词原形\n\n\n虚拟语气在含蓄条件句中的用法\n\n\n含蓄条件句的两种表达方式\n谓语动词的形式\n\n\n\nbut for,without,with,under（在…下面）等介词引出的短语表示虚拟条件\n用should&#x2F;would&#x2F;could&#x2F;might+动词原形的形式表示对现在或将来情况的假设。用should&#x2F;would&#x2F;could&#x2F;might have +过去分词的形式表示对过去情况的假设。\n\n\nor,otherwise（否则）,but,but that等连词表示虚拟条件\n用should&#x2F;would&#x2F;could&#x2F;might+动词原形的形式表示对现在或将来情况的假设。用should&#x2F;would&#x2F;could&#x2F;might have +过去分词的形式表示对过去情况的假设。\n\n\n虚拟语气在其他句型中的用法\n\n\n句型\n谓语动词的形式\n\n\n\nIt is （hight&#x2F;about）time（that）…\n从谓语动词用过去式或should+动词原形的形式，should不可以省略。\n\n\nif only 引起的句子\n用过去式（be动词用were）表示现在还没有实现的愿望。用had+过去分词的形式表示过去没有实现的愿望。用would&#x2F;could&#x2F;might+动词原形的形式表示将来没有可能实现的愿望。\n\n\n","slug":"升本/英语/升本英语","date":"2022-09-02T14:01:00.000Z","categories_index":"升本","tags_index":"英语,笔记,升本","author_index":"Honman"},{"id":"3a13b25df3ae48dbca78c649405861eb","title":"Vue基础入门","content":"Vue.js基础入门1.什么是Vue​\tVue读音类似View，是一套用于构建用户界面的渐进式框架与其他大型框架（Angular、React…）相比,Vue被设计为可以自底向上逐层应用。而其他大型框架需要一开始就对项目的技术方案进行强制性的要求，Vue则更灵活，我们既可以选择Vue来开发一个全新项目，也可以将Vue引入到一个现有的项目中。\n​\tVue的数据驱动是通过MVVM（Model-View-ViewModel）的模式来实现的，基本工作原理如下图所示：\n\n2.Vue的优势\n\n\n\n\n\n\n\n\n前端主流的框架有Angular、React、Vue。\n\n轻量级\n数据绑定（数据双向绑定。）\n指令 （v-for列表渲染、v-if条件渲染、v-bind动态绑定指令。）\n插件 （对框架的功能进行扩展，通过MyPlugin.install完成插件的编写，简单配置后就可以全局使用。）\n\n3.Vue开发环境\nVS Code编辑器\ngit-bash命令工具\nNode.js环境\nnpm包管理工具 （npm的服务器在国外，使用npm下载软件包的速度犹如龟速，所以解决办法要么换国内镜像，要么用vpn。）\nChrome浏览器和vue-devtools扩展\n\n4.webpack 打包工具1.安装webpack命令行执行下面命令：\nbashnpm install webpack@4.27.x webpack-cli@3.x -g这里其实我也不知道为什么课本一定要这个版本？？？\nwebpack-cli是脚手架工具 “-g”表示全局安装。\n\n\n\n\n\n\n\n\n\n\n我安装的时候就遇到了权限问题，只需要在终端输入如下命令就可以了。\n\nbashsudo s2.webpack简单使用1.创建一个vue\\chapter\\demo01\\demo02目录。\n2.在demo02目录中创建example.js文件，文件内编辑如下代码：\njsfunction add(a,b)&#123;\n    return a + b\n&#125;\nconsole.log(add(1,2)) //a=1,b=2上面的代码是计算显示a b两个数字之和，会在控制台中输出计算的结果。\n3.用终端在demo02目录下执行下面的命令（打包操作）：\ncmdwebpack example.js -o app.js上面的命令执行后会编译example.js文件，将编译好的结果保存为app.js文件。\n\n\n\n\n\n\n\n\n\n\n但是我非常不幸运，我的node.js版本是17.9.0，回车之后抛出了异常（error:03000086:digital envelope routines::initialization error）。\n原因：node.js V17版本中最近发布的OpenSSL3.0，而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响。\n在node.js V17以前一些可以正常运行的的应用程序，在 V17 版本就可能会抛出异常。\n我的解决办法：\n使用npm安装n (node版本管理n)来达到降级的目的。命令如下：\nbashnpm install -g n #安装nbashn stable #安装稳定版本拓展：\nbash# 升级到稳定版\nsudo n stable\n# 升级到最新版\nsudo n lastest\n# 查看所有node版本\nsudo n ls\n# 切换使用node版本\nsudo n 12.13.0\n# 切换node 版本（输入上下键盘选择确认）：\nsudo n\n# 删除某个node版本\nsudo n rm 12.13.0\n# 用指定版本执行脚本\nsudo n use 12.13.0  xxx.js\n4.创建example.html文件，引入app.js文件。html代码如下：\nhtml&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;5.在浏览器中打开example.html，按F12查看控制台即可看到a+b的结果(3)。\n","slug":"前端/Vue/Vue基础入门","date":"2022-09-01T13:30:00.000Z","categories_index":"计算机,前端","tags_index":"笔记,Vue","author_index":"Honman"},{"id":"33e145189cb2c9be32b78fb749fd41d4","title":"Python爬虫","content":"Python爬虫什么是爬虫通过编写程序，模拟浏览器上网，然后让其去互联网上抓取数据的过程。\n\n\n\n\n\n\n\n\n\n是一种自动获取网页数据信息的爬虫程序，是网站搜索引擎的重要组成部分。一般人能访问到的网页，爬虫也都能抓取。所谓的爬虫抓取，就是模拟人类访问目标网站。但和普通人访问方式不同，爬虫是可以按照一定的规则，自动的采集数据新。\n爬虫的价值在互联网中，数据是无价之宝，一切皆为数据，谁拥有大量有用 的数据，谁就拥有了决策的主动权。网络爬虫的应用领域很多，eg：爬取需要的数据进行统计、出行类软件可以利用爬虫抢票、整理聚合手机平台信息进行比较，数据分析、爬取个人信用信息。企业或政府利用爬取的数据，采用数据挖掘的相关方法，发掘用户讨论的内容、实行事件监测、舆情引导等。\n爬虫的原理爬虫在使用场景中的分类分为以下4种。\n\n通用网络爬虫\n\n\n\n\n\n\n\n\n\n又称全网爬虫，爬取对象由一批种子URL扩充到整个Web，主要由搜索引擎或大型Web服务提供使商用。\n抓取系统重要组成部分，抓取的是一整张页面的数据。\n\n聚焦网络爬虫\n\n\n\n\n\n\n\n\n\n又称主题网络爬虫，其最大的特点是只选择性地爬取与预设的主题相关的页面。\n是建立在通用网络爬虫的基础之上的，抓取的是页面中特定的局部内容。\n\n增量式网络爬虫\n\n\n\n\n\n\n\n\n\n只对已经下载玩野采取增量式更新，或只怕去新产生的及已经发生变化的网页，这种机制能够在某种程度上保证爬取的页面尽可能的新。\n检测网站中有数据更新的情况，只会抓取网站中最新更新出来的数据。\n\n深层网络爬虫\n\n\n\n\n\n\n\n\n\n指大部分内容无法通过静态链接获取，隐藏在表单后的，需要用户提交关键词后才能获得Web页面，如一些登录才可见的网页。\n\n\n反爬机制门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的被爬取。\n爬取策略爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而获取数据。\nrobots.txt协议该协议不是一份规范，只是一个约定俗成的协议。爬虫应当遵守这份协议，否则很可能会被万丈所有者封禁IP，甚至网站所有者会采取进一步法律行动。\n\n\n\n\n\n\n\n\n\n著名的360的爬虫之争为案例\nhttp协议就是服务器和客户端进行数据交互的一种形式。\n常用的请求偷头信息：\n\nUser-Agent：请求载体身份标识。\nConnection：请求完毕后，是断开连接还是保持连接。\n\n常用响应头信息：\n\nContent-Type：服务器响应回客户端的数据类型。\n\nhttps协议：\n\n安全的超文本传输协议\n\n加密方式：\n\n对称秘钥加密\n非对称秘钥加密\n证书秘钥加密\n\nrequests模块request模块是什么？python中原生的一款基于网络请求的模块\n\n\n\n\n\n\n\n\n\n在python内置模块的基础上进行了高度的封装，从而使得python进行网络请求时，变得人性化，使用Requests可以轻而易举的完成浏览器可有的任何操作。\n作用：模拟浏览器向服务器发请求。\nrequests的安装bashpip install requestshttp请求类型有4种请求类型：\n\nPUT\nDELETE\nHEAD\nOPTIONS\n\npythonrequests.get(‘https://github.com/timeline.json’)                                # GET请求\nrequests.post(“http://httpbin.org/post”)                                        # POST请求\nrequests.put(“http://httpbin.org/put”，data = &#123;&#39;key&#39;:&#39;value&#39;&#125;)                  # PUT请求\nrequests.delete(“http://httpbin.org/delete”)                                    # DELETE请求\nrequests.head(“http://httpbin.org/get”)                                         # HEAD请求\nrequests.options(“http://httpbin.org/get” )                                     # OPTIONS请求使用流程&#x2F;编码流程\n指定URL\n基于requests模块发送请求\n获取响应对象中的数据值\n持久化存储\n\n第一个简单的爬虫程序使用request模块实现一个简单的网页采集。\n步骤指定url如下的问号其实可以保留也可以不保留。\npython#指定url\nurl = &#39;https://www.sogou.com/web?&#39;User-Agent伪装这一步需要用浏览器在开发者工具中查看自己本机的User-Agent。\npython#UA伪装\nheaders = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/x.x (Macintosh; Intel Mac OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x Safari/xxx.xx&#39;\n&#125;响应发起请求get请求返回的是一个response响应对象。\npython#获取请求响应\nresponse = requests.get(url = url,params = param,headers = headers) #get返回一个响应对象获取响应数据获取字符串形式的响应数据，也就是获取text的格式的响应数据。\npythonpage_text = response.text #获取字符串形式的响应数据持久化储存这一步就是最后的操作了，把采集到的网页页面元素保存下来。\npythonwith open(fileName,&#39;w&#39;,encoding = &#39;utf-8&#39;) as fp:\n    fp.write(page_text)完整代码pythonimport requests\n\n#指定url\nurl = &#39;https://www.sogou.com/web?&#39;\n#UA伪装\nheaders = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/x.x (Macintosh; Intel Mac OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x Safari/xxx.xx&#39;\n&#125;\n\nkw = input(&quot;请输入一个关键词: &quot;)\nparam = &#123;\n    &#39;query&#39;:kw\n&#125;\nfileName = kw+&#39;.html&#39;\n#获取请求响应\nresponse = requests.get(url = url,params = param,headers = headers) #get放回一个响应对象\npage_text = response.text #获取字符串形式的响应数据\nwith open(fileName,&#39;w&#39;,encoding = &#39;utf-8&#39;) as fp:\n    fp.write(page_text)\n\nprint(fileName,&#39;save successfully&#39;)\n某度翻译破解在pycharm中实现直接输入要翻译的英语单词，终获得翻译结果并且保存下来。\n指定url利用浏览器的开发工具进行数据抓包，在XHP页面获取Ajax实际请求地址。\n切换到Headers找到请求，可以看到请求的url、请求方式和返回的数据类型都有了。\npython# 指定url\nurl = &#39;https://fanyi.baidu.com/sug&#39;UA伪装让爬虫对应的请求载体身份标识伪装成某一款浏览器。方法：将对应的User-Agent封装到一个字典中。\npython# UA伪装\nheaders = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/x.x (Macintosh; Intel Mac OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x Safari/xxx.xx&#39;\n&#125;POST请求参数处理在XHP页面获取Ajax实际相关参数。\npython# post请求参数处理（同get请求一致）\ndata = &#123;\n    &#39;kw&#39;: words\n&#125;请求发送基于requests发送请求，通过前面抓包得到的信息我们得到了，它的请求方式为post请求，这里我们使用requests模块中post()方法来发送请求\npython# 请求发送\nresponce = requests.post(url=url, data=data, headers=headers)获取响应数据python# 获取响应数据：json()方法放回的是obj（确认了响应数据是json类型才可以用json()方法）\nresult = responce.json()  # 返回一个obj进行持久化存储默认使用的编码是ASCII（不包含中文），而中文是Unicode编码。\npython# 进行持久化存储\nfp = open(fileName, &#39;w&#39;, encoding=&#39;UTF-8&#39;)\njson.dump(result, fp=fp, ensure_ascii=False)  # json()返回的obj中有中文 所以不能用ASCII解码完整代码pythonimport requests\nimport json\n\n# 指定url\nurl = &#39;https://fanyi.baidu.com/sug&#39;\n\n# UA伪装\nheaders = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/x.x (Macintosh; Intel Mac OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x Safari/xxx.xx&#39;\n&#125;\n\n# 输入翻译的词\nwords = input(&#39;请输入要翻译的英语单词: &#39;)\n# post请求参数处理（同get请求一致）\ndata = &#123;\n    &#39;kw&#39;: words\n&#125;\n# 请求发送\nresponce = requests.post(url=url, data=data, headers=headers)\n\nfileName = words + &#39;.json&#39;\n\n# 获取响应数据：json()方法放回的是obj（确认了响应数据是json类型才可以用json()方法）\nresult = responce.json()  # 返回一个obj\nprint(&#39;翻译结果如下:&#39;)\nprint(result)  # 打印返回的obj结果\n\n# 进行持久化存储\nfp = open(fileName, &#39;w&#39;, encoding=&#39;UTF-8&#39;)\njson.dump(result, fp=fp, ensure_ascii=False)  # json()返回的obj中有中文 所以不能用ASCII解码\nprint(&#39;save over！&#39;)\n正则表达式模块Python通过自带的re模块来支持正则表达式\n\n\n\n\n\n\n\n\n\n\n先将正则表达式的String编译为“Pattern”实例\n使用Pattern实例处理结文本并且获得匹配结果（一个Match实例）\n使用Match实例获得信息\n\nre模块常用的方法\n\n\n方法名\n说明\n\n\n\ncompile\n将正则表达式String转化为Pattern匹配对象。\n\n\nmatch\n将输入的String从头开始对输入的正则表达式进行匹配，如果遇到无法匹配的字符或到达String的末尾，则立即放回None，否则获取匹配结果。\n\n\nsearch\n将输入的整个String进行扫描，对输入的正则表达式进行匹配，并获取匹配结果，如果没有匹配结果，则返回None。\n\n\nsplit\n以能够匹配的String作为分隔符，将String分割后返回一个列表。\n\n\nfindall\n搜索整个String，返回一个包含全部能匹配子串的列表。\n\n\nfinditer\n与findall方法的作用类似，以迭代器的形式返回结果。\n\n\nsub\n使用指定内容替换字符串中匹配的每一个子串内容。\n\n\ncompile方法将正则表达式的字符串转化为Pattern匹配对象\npythonre.compile(pattern,flags=0)\n\n\n参数\n说明\n\n\n\nPattern\n接收str，表示需要转换的正则表达式的字符串。无默认值。\n\n\nflags\n接收str，表示匹配的模式，取值为运算符”|”时表示同时生效，如re.I|re.M。默认为0。\n\n\nsearch方法该方法将输入的整个字符串进行扫描，并对输入的正则表达式进行匹配，若无匹配的字符，则立即返回None，否则获取匹配结果。\npythonre.search(pattern,string,flags=0)\n\n\n参数\n说明\n\n\n\nPattern\n接收Pattern实例，表示转换后的正则表达式。无默认值。\n\n\nstring\n接收str，表示输入的需要匹配的字符串。无默认值。\n\n\nflags\n接收str，表示匹配的模式，取值为运算符”|”时表示同时生效。\n\n\nfinall方法该方法搜索整个string，并放回一个包含所有能匹配的子串的列表\npythonre.finall(pattern,string,flags=0)\n\n\n参数\n说明\n\n\n\nPattern\n接收Pattern实例，表示转换后的正则表达式。无默认值。\n\n\nstring\n接收str，表示输入的需要匹配的字符串。无默认值。\n\n\nflags\n接收str，表示匹配的模式，取值为运算符”|”时表示同时生效，意思为“or”。\n\n\n使用finall方法找出字符串中的所有数字\n若 str &#x3D; a1b2c3d4e5f6g7 找出其中的所有数字：\npythonimport re\n\npat = re.compile(r&#39;\\d+&#39;)\nstr = &#39;a1b2c3d4e5f6g7&#39;\t#设定：str = a1b2c3d4e5f6g7\nresult = re.findall(pat, str)\nprint(result)   #输出：[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;]获取网页中的标题内容pythonimport re\nimport requests\n\nurl = &#39;http://www.tipdm.com/tipdm/index.html&#39;\n\nheader = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel xxx OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x xxxxx/xxx.xx&#39;,\n    &#39;Cookie&#39;: &#39;_site_id_cookie=xx; _site_id_cookie=xx.x; JSESSIONID=abcdefg123456abcd1234; clientlanguage=zh_CN&#39;\n&#125;\nrequests_get = requests.get(url, header)\nrequests_get.encoding = &#39;utf-8&#39;\nhtml_text = requests_get.text\n\n# &lt;title&gt;泰迪科技-专注于大数据技术研发及知识传播&lt;/title&gt;\npattern = r&#39;(?&lt;=&lt;title&gt;).*?(?=&lt;/title&gt;)&#39;\nresult_com = re.compile(pattern)\nresult_search = re.search(result_com, html_text)\n# &lt;re.Match object; span=(178, 198), match=&#39;泰迪科技-专注于大数据技术研发及知识传播&#39;&gt;\nprint(result_search)\n# 泰迪科技-专注于大数据技术研发及知识传播\nprint(result_search.group())一步到位\npythonimport re\nimport requests\n\nurl = &#39;http://www.tipdm.com/tipdm/index.html&#39;\nheader = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel xxx OS X xx_xx_x) AppleWebKit/xxx.xx (KHTML, like Gecko) Chrome/xxx.x.x.x xxxxx/xxx.xx&#39;,\n    &#39;Cookie&#39;: &#39;_site_id_cookie=xx; _site_id_cookie=xx.x; JSESSIONID=abcdefg123456abcd1234; clientlanguage=zh_CN&#39;\n&#125;\nrequests_get = requests.get(url, header)\n# requests_get.encoding = &#39;utf-8&#39;\nhtml_text = requests_get.text\n# &lt;title&gt;泰迪科技-专注于大数据技术研发及知识传播&lt;/title&gt;\nprint(re.findall(r&#39;(?&lt;=&lt;title&gt;).*?(?=&lt;/title&gt;)&#39;, html_text))\n\n\n\n\n\n\n\n\n其实不推荐使用正则表达式去定位特定节点来获得其中想要的内容的。\n✅推荐使用：Xpath、BeautifulSoup。\n使用Xpath解析网页XML路径语言（XML Path Language，Xpath）是一门文档中查找信息的语言。\n基础语法使用Xpath需要从lxml库中导入etree模块，还需要使用HTML类对需要匹配的HTML对象进行初始化。HTML类对基本语法格式如下：\npythonlxml.etree.HTML(text, parser=None, *, base_url=None)HTML类对常用参数及说明如下：\n\n\n\n参数名称\n说明\n\n\n\ntext\n接收str 表示需要转换为HTML的字符串。无默认值\n\n\nparser\n接收str 表示选择的HTML解析器。无默认值\n\n\nbase_url\n接收str 表示文档的原始URL 用于查找外部实体的相对路径。默认为None\n\n\nXpath可以使用类似正则的表达式来匹配HTML文件中的内容，常用的表达式如下：\n\n\n\n表达式\n说明\n\n\n\nnodename\n选取nodename节点的所有子节点\n\n\n&#x2F;\n从当前节点选取直接子节点\n\n\n&#x2F;&#x2F;\n从当前节点选取所有子孙节点\n\n\n.\n选取当前节点\n\n\n..\n选取当前节点的父节点\n\n\n@\n选取属性\n\n\n谓语Xpath中的谓语可用来查找某个特定的节点或包含某个指定的值的节点，谓语呗嵌套在路径后面的方括号中，如下：\n\n\n\n表达式\n说明\n\n\n\n&#x2F;html&#x2F;boby&#x2F;div[1]\n选取属于body子节点的第一个的div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[last()]\n选取属于body子节点的最后一个div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[last()-1]\n选取属于body子节点的倒数第二个div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[postion()&lt;3]\n选取属于body子节点的前两个div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[@id]\n选取属于body子节点的带有id属性的div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[@id&#x3D;”content”]\n选取属于body子节点的的id属性值为content的div节点\n\n\n&#x2F;html&#x2F;boby&#x2F;div[xx&gt;10.00]\n选取属于body子节点的body子节点的xx元素值大于10的节点\n\n\n完整代码请运用所学Xpath方法，试着爬取微博的热搜关键词。\npythonimport re\nimport requests\nfrom lxml import etree\npython# 指定url\nurl = &#39;https://s.weibo.com/top/summary&#39;\n\n# user-agent伪装\nheader = &#123;\n    &#39;user-agent&#39;:&#39;xxxxxxxxxxxxxx&#39;,\n    &#39;cookie&#39;:&#39;xxxxxxxxxxx&#39;\n&#125;pythonrequests_get = requests.get(url=url,headers=header)\nhtml = requests_get.content.decode(&#39;utf-8&#39;)\n\nhtml = etree.HTML(html,parser=etree.HTMLParser(encoding=&#39;utf-8&#39;))\nhtml&lt;Element html at 0x7fd20ac93f00&gt;\npythonresult = html.xpath(&#39;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr[1]/td[2]/a/text()&#39;)\nresult[‘新闻发布会’]\npython# divs = html.xpath(&#39;/html/body/div[1]/div[2]/div/div[2]/div[1]/table/tbody/&#39;)\n# dics = html.xpath(&#39;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr/td/a&#39;)\ndivs = html.xpath(&#39;/html/body/div/div/div/div/div/table/tbody/tr/td/a&#39;)\ni = 1\nfor div in divs:\n    print(&quot;第&#123;&#125;条&quot;.format(i),div.text)\n    i+=1第1条 新闻发布会…第19条 LGD第20条 将盆栽越坐越歪的猫咪第21条 活得还没10后小朋友明白第22条 林志颖车祸后首次露面第23条 哄睡师包月套餐标价1.8万第24条 内娱国风氛围感大赏第25条 王一博骑摩托艇把街舞导演甩水里了**\n使用Beautiful Soup库解析网页Beautiful Soup 是一个可以从HTML 或 XML 文件中提取数据的python库\n完整代码pythonimport requests\nfrom bs4 import BeautifulSoup\nfrom lxml import etreepythonheader = &#123;\n    &#39;User-Agent&#39;: &#39;Mozilla/x.0 (Windows NT 10.0; Win64; x64) AppleWebKit/xxxxxx (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/xxx.36 Edg/9x.0.xxxx.x6&#39;,\n    &#39;Cookie&#39;: &quot;SUB=_2AkMUH_xxxxxxxxx-yT9jqm8GtRB6P5_ZTJnjeloNEw4vOcUYn5Ft-q_jepMk; SUBP=0033WrSXqPxfM72-Ws9jqgMF5xxxxxxxxoQ4SDwJCdCGAo7QWv7g; _s_tentry=passport.weibo.com; Apache=9820xxxxxxxxx9.3xx.166xxxxxxx5834; SINAGLOBAL=9820789867589.398.1xxxxxx5834; ULV=166xxxxxx835:1:1:1:98207xxxxx589.398.1665366xxxxx4:&quot;&#125;\nres = requests.get(&quot;https://s.weibo.com/top/summary&quot;, headers=header)pythonsoup = BeautifulSoup(res.text)pythondom = etree.HTML(str(soup))\nhot_titles = dom.xpath(&#39;//*[@id=&quot;pl_top_realtimehot&quot;]/table/tbody/tr/td/a&#39;)\nfor i, v in enumerate(hot_titles):\n    print(i, v.text)0 xxxx大会1 商场回应影院不让带蜜雪冰城2 PDD已起诉多人侵犯名誉权3 中国人的书信有多美4 韩剧继承者们首播9周年5 iPhone14车祸检测坐过山车会报警6 教育局回应中学收20元树叶费7 抑郁症不是简单的坏心情8 普京称克里米亚大桥爆炸是恐怖主义行为9 男孩得胃病竟因妈妈染幽门螺杆菌10 未来三个月17.1%受访居民打算购房11 RNG对战CFO12 爱的二八定律出品方没有嘉行13 内蒙古增本土确诊119例无症状559例14 苏炳添再次起诉新东方子公司侵权15 女子吐槽丈夫脑袋掉色枕头焦黄16 女子路边发现80年代供销社17 RNG战胜CFO\n使用post请求方法实现登录post请求方法能够保障用户端提交数据的安全性，因此被一般需要登录的完整所采用。requests库的post函数能够以post请求方法向服务器发送请求，返回一个Response对象\n完整代码pythonimport requests\nimport matplotlib.pyplot as pltpython# requests.post(url,data=,json=,**kwargs)\nurl = &#39;http://www.ptpress.com.cn/login&#39;\n# username: xxxxxxxxxx\n# password: xxxxxxxxxx\n# verifyCode: \ncode_url = &#39;https://www.ptpress.com.cn/kaptcha.jpg&#39; #验证码python#Session会话\nsess = requests.Session()\nrq_code = sess.get(code_url)    #对验证码的页面进行请求发送\nwith open(&#39;./captcha.jpg&#39;,&#39;wb&#39;) as fp:\n    fp.write(rq_code.content)pythondef get_code(): \n    pic = plt.imread(&#39;./captcha.jpg&#39;)\n    plt.imshow(pic)\n    plt.show()\n    return input(&#39;请输入验证码&gt;&gt;&gt;&#39;)pythoncode = get_code()pythonlogin_data = &#123;&#39;username&#39;:&#39;xxxxxxxxxxx&#39;,&#39;password&#39;:&#39;xxxxxxxxxxx&#39;,&#39;verifyCode&#39;:code&#125;\nlogin_datapythonrq = sess.post(url,data=login_data)最后一步验证是否成功：https://www.ptpress.com.cn/login：\npythonprint(rq.url)","slug":"后端/Python/Python爬虫","date":"2022-08-30T03:30:00.000Z","categories_index":"计算机,后端","tags_index":"笔记,Python","author_index":"Honman"},{"id":"88e8bb0bfdbc895aed5ccb8b7148e21d","title":"MarkDown语法📖","content":"MarkDown语法📖✅标题一级标题：\nmarkdown# 一级标题二级标题：\nmarkdown## 二级标题\n\n\n\n\n\n\n\n\n从一级标题（快捷键command⌘ + 1）到六级标题（快捷键command⌘ + 6）\n✅字体粗体：\nmarkdown**粗体**粗体效果\n斜体：\nmarkdown*斜体*斜体效果\n✅列表有序列表：\nmarkdown1. 有序列表\n2. 有序列表\n3. 有序列表\n有序列表\n\n有序列表\n\n有序列表\n\n\n📢注意\n这里只需要键盘输入数字1️⃣ + 一个点 + 一个空格 + 输入第一列内容 之后回车 后面就会自动补 \n无序列表：\nmarkdown* 无序列表\n* 无序列表\n* 无序列表\n无序列表\n无序列表\n无序列表\n\n📢注意\n**这里只需要键盘输入一个星号  *  + 一个空格 + 输入第一列内容 之后回车 后面就会自动补全 **\n✅引用引用：\nmarkdown&gt; 引用一个典故\n\n\n\n\n\n\n\n\n引用一个典故\n引用嵌套：\nmarkdown&gt;&gt; 引用嵌套一句话\n\n\n\n\n\n\n\n\n\n引用嵌套一句话\n\n✅超链接markdown[超链接](https://www.baidu.com)超链接\n📢注意\n需要按住 ⌘ + 鼠标左键点击 才能打开\n✅代码块**&#96;&#96;&#96; **\n代码\n**&#96;&#96;&#96; **\njavaSystem.out.println(&quot;hello world&quot;);✅博客的开头文markdown---\ntitle: JavaScript-进阶笔记\ntags:\n  - JavaScript\n  - 笔记\ncategories:\n  - 计算机\n  - 前端\ncover: &#39;/images/cover/4.jpg&#39;\nabstracts: JavaScript进阶的重要性在于深入理解语言的高级概念和技术，如闭包、原型链、异步编程等。这将使开发者能够编写更高效、可维护和可扩展的代码，解决复杂的问题，并应对日益增长的Web应用需求。进阶的JavaScript知识将提升开发者的技术能力和职业竞争力。\ndate: 2023-08-24 8:30:00\n---","slug":"语法篇/MarkDown语法","date":"2022-08-14T18:28:00.000Z","categories_index":"计算机","tags_index":"笔记,语法","author_index":"Honman"},{"id":"5a94284bad0b90df36c14e6069e7b100","title":"英语语法","content":"\n\n总览\n数词（num.）基数词个位数（0-9）\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nzero\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\n\n\n十到十九（10-19）\n\n\n十\n十一\n十二\n十三\n十四\n\n\n\nten\neleven\ntwelve\nthirteen\nfourteen\n\n\n十五\n十六\n十七\n十八\n十九\n\n\nfifteen\nsixteen\nseventeen\neighteen\nnineteen\n\n\n十位数，二十到九十（20-90）\n\n\n二十\n三十\n四十\n五十\n\n\n\ntwenty\nthirty\nforty\nfifty\n\n\n六十\n七十\n八十\n九十\n\n\nsixty\nseventy\neighty\nninety\n\n\n二十以上，几十几（21-99）例如：二十一 &#x3D;&gt; twenty one九十九 &#x3D;&gt; ninety nine十位用几十，个位用个位\n数字表达规律\n从右往左，每三位一个逗号，倒数第一个逗号之前是thousand，倒数第二个逗号之前是million，倒数第三个逗号之前是billion，倒数第四个逗号之前是trillion\n逗号之间的百位和十位都要加and，数字隔0要加and\n\n一百到九百九十九（100-999）一百（100）&#x3D;&gt; one hundred一百零一（101）&#x3D;&gt; one hundred and one九百九十九（999）&#x3D;&gt; nine hundred and ninety-nine\n一千到九千九千九百九十九（1000-9999）一千（1,000） &#x3D;&gt; one thousand一千零一（1,001） &#x3D;&gt; one thousand and one一千零二十（1,020） &#x3D;&gt; one thousand and twenty九千九百九十九（9,999） &#x3D;&gt; nine thousand nine hundred and ninety-nine\n一万到一万零九百九十九（10000-10999）一万（10,000）&#x3D;&gt; ten thousand一万零一（10,001）&#x3D;&gt; ten thousand and one一万零二十（10,020）&#x3D;&gt; ten thousand and twenty一万零两百（10200）&#x3D;&gt; ten thousand and two hundred一万零九百九十九（10,999）&#x3D;&gt; ten thousand nine hundred and ninety-nine\n一万一千到九万九千九百九十九（11,000-99,999）一万一千（11*1000&#x3D;11,000）&#x3D;&gt; eleven thousand一万一千零一（11,001）&#x3D;&gt; eleven thousand and one一万一千零二十（11020）&#x3D;&gt; eleven thousand and twenty一万一千零二百（11200）&#x3D;&gt; eleven thousand two hundred九万九千九百九十九（99999）&#x3D;&gt; ninety nine thousand nine hundred and ninety-nine\n十万到九十九万九千九百九十九（100000-999999）十万（100,000）&#x3D;&gt; one hundred thousand十万零一（100,001）&#x3D;&gt; one hundred thousand and one十万零二十（100,020）&#x3D;&gt; one hundred thousand十万零二百（100,200）&#x3D;&gt; one hundred thousand and two hundred十万零二千零一（102,001）&#x3D;&gt; one hundred thousang and two thousand and one九十九万九千九百九十九（999,999）&#x3D;&gt; nine hundred and ninety-nine thousand nine hundred and ninety-nine\n一百万到九千九百九十九万九千九百九十九（1,000,000-99,999,999）一百万（1,000,000）&#x3D;&gt; one million一百万零一（1,000,001）&#x3D;&gt; one million and one一百万零一千（1,001,000）&#x3D;&gt; one million and one thousand一百零一万（1,010,000）&#x3D;&gt; one million and ten thousand九千九百九十九万九千九百九十九（99,999,999）Ninety-nine million nine hundred and ninety-nine thousand and ninety-nine\n一亿到十亿以及更多（100,000,000-1,000,000,000-∞）一亿（100,000,000）&#x3D;&gt; one hundred million一亿零一（100,000,001）&#x3D;&gt; one hundred million and one一亿零一千（100,001,000）&#x3D;&gt; one hundred million and one thousand一亿零一百万（101,000,000）&#x3D;&gt;one hundred and one million十亿（1,000,000,000）&#x3D;&gt; one billion三百一十亿零二千九百万零八百八十八（31,020,900,888） &#x3D;&gt; thirty-one billion and twenty million nine hundred thousand and eighty-eight\n使用特点\n作数词时候，前面可以加数词，后面不能加s，比如：two thousand，three thoudsand(❌)\n如果数词用作名词时候，意思是好几…的时候，前面可以加some&#x2F;many&#x2F;several这种词或者加数词，后面可以加of。例如：hundreds of（好几百），five hundreds of（五百左右），many millions of（数百万）\n表示年龄 &#x3D;&gt; I’m twenty（我20岁）\n表示编号 &#x3D;&gt; Room 101 &#x3D; Room one 0 one\n表示年代 &#x3D;&gt; 1940’s &#x3D; nineteen forty’s(20世纪40年代)\n表示年份\n2008 &#x3D; two thousand and eight\n1949 &#x3D; nineteen forty-nine\n2019.9.10 &#x3D; Sep.10th, 2019 &#x3D; September , tenth, twenty nineteen\n\n\n\n序数词第几（第零到第九）\n\n\n第零\n第一\n第二\n第三\n第四\n第五\n第六\n第七\n第八\n第九\n\n\n\nzeroth\nfirst\nsecond\nthird\nfourth\nfifth\nsixth\nseventh\neighth\nninth\n\n\n第十到第十九\n\n\n第十\n第十一\n第十二\n第十三\n第十四\n\n\n\ntenth\neleventh\ntwelfth\nthirtheeth\nfourteenth\n\n\n第十五\n第十六\n第十七\n第十八\n第十九\n\n\nfifteenth\nsixteenth\nseventeenth\neighteenth\nnineteenth\n\n\n第几十（第二十到第九十）\n\n\n第二十\n第三十\n第四十\n第五十\n\n\n\ntwentieth\nthirhieth\nfortieth\nfiftieth\n\n\n第六十\n第七十\n第八十\n第九十\n\n\nsixieth\nseventieth\neightieth\nninetieth\n\n\n把基数词结尾的y变成i再加eth\n第二十以上，第几十几十位用基数词，个位用序数词第二十一 &#x3D;&gt; twenty first第九十九 &#x3D;&gt; ninety ninth\n第一百以上第整数的后面加th，如果不是整数，保留基数词只变个位数\n\n\n\n第一百\n第一千\n第一百万\n第十亿\n\n\n\none hundredth\none thousandth\none millionth\none billionth\n\n\n使用特点\n使用序数词时，一般前面要加定冠词the\nI’m in the second room(我在第二个房间)\n\n\n表示时间日期\nThe first of September&#x3D;Sep 1st(九月一日)\n\n\n表示楼层\nThe first floor(一楼)\n\n\n表示几分之几，分子大于一，分母有复数形式\none third &#x3D; 1 &#x2F; 3\ntwo thirds &#x3D; 2 &#x2F; 3\n\n\n序数词前面加a&#x2F;an表示再一，序数词前面加the表示顺序\nWe read the book a third times(我们读了三遍这本书)\nThe second door of the room is closed（房间的第二扇门是关的）\n\n\n\n冠词（art.）\n1. 定冠词表示这个，特指某个名词，后面跟单数&#x2F;复数名词，不可数名词例如：\n\n表示上文提过的人和物-This car is popular, but the car isn’t cheap\n表示地理位置用-We are based in the Beijing\n表示江河湖海用-The Yellow River\n唯一存在的事物用-The earth\n最高级前用-This is the best cup of coffee\n表示强调时候用-Beijing is the capital of China\n乐器（西洋古典乐器）之前用\nI like to play the piano\n\n\n在形容词前用 the，会将形容词变成名词\nThe rich should help the poor.\n\n\n固定表达\nall the time 一直；总是\nby the way 顺便\nout of the question 不可能；没门\n\n\n\n2. 不定冠词泛指人和物，表示一个，后面加单数可数名词辅音发音前面加a，元音发音前面加an\n\n第一次提到的人和物-It’s a cat\n如果是对唯一事物具体情况说明-Their dream is to go on a world tour(他们的梦想是去全世界巡回演出)\n和名词连用作表语或者同位语，代表职业-I am an engineer\n表示价格&#x2F;速度&#x2F;频率 - 80miles an hour\n固定短语会用 - have a good time\n\n3. 零冠词有情况下可以不需要加任何冠词\n\n很广泛的概念\n复数泛指\nComputers have changed our way of life.\nWater is important.\nWe breathe air.\n\n\n书名&#x2F;人名\n某些城市&#x2F;国家\n某些山河湖海洲\n星球\n语言&#x2F;球类&#x2F;学科&#x2F;棋牌\nI want to play football.\n\n\n三餐&#x2F;日期&#x2F;季节（一般不加冠词，如果要特指可以加the）\nSummer is hot. Winter is cold.\non Monday\n\n\n固定表达\nfrom time to time 不时地\nface to face 面对面地\nout of question 毫无疑问\n\n\n\n名词（n.）名词分类专有名词、普通名词专有名词（大多数不可数）：人名、地名、国家、组织、单位、大型活动、著名事件（首字母大写，如果缩写全部字母大写）普通名词：专有名词以外的名词\n可数名词、不可数名词\n\n\n&#x2F;\n可数名词\n不可数名词\n\n\n\n能否 【计数】\n✅\n❌\n\n\n能否【加不定冠词（a&#x2F;an）和数词（one、two）】\n✅\n❌\n\n\n能否【加定冠词（the）】\n✅\n✅\n\n\n可数名词（单数复数都可以，可以加数词计算）：\n\napple\negg\nboy\n\n不可数名词（只能单数，不可以加数词计算）：\n\nwater\nfire\ntime\n\n具体名词、抽象名词具体名词（看得见摸得着、可数不可数都有）：\n\nman\nBeijing\nbook\nfire\n\n抽象名词（无形的各种事物，大多数不可数）：\n\ntime\nhope\nlove\n\n单复数变化规则变化\n直接 + s：coats、jobs、hats\n以 o，s，x，ch，sh 结尾，+ es：dresses, boxes, watches\n辅音（除去A、E、I、O、U的 21 个字母） + y，变 y 为 i 加 es：cities\n以 f 或 fe 结尾，变 f 为 v 加 es：half &#x3D;&gt; halves; wife &#x3D;&gt; wives\n以 o 结尾\n有生命 + es：patato &#x3D;&gt; patatoes; tomato &#x3D;&gt; tomatoes\n无生命 + s：photo &#x3D;&gt; photos; zoo &#x3D;&gt; zoos\n\n\n\n不规则变化\nman &#x3D;&gt; men\nwoman &#x3D;&gt; women\ngoose &#x3D;&gt; geese\nfoot &#x3D;&gt; feet\ntooth &#x3D;&gt; teeth\nchild &#x3D;&gt; children\nmouse &#x3D;&gt; mice\nfish &#x3D;&gt; fish\nsheep &#x3D;&gt; sheep\ndeer &#x3D;&gt; deer\n\n一直是复数的名词\nglasses 眼镜\nclothes 衣服\nscissors 剪刀\ntweezers 镊子\ncongratulations 祝贺\ntrousers 裤子\namends 赔偿\ncahoots 同伙\nshenanigans 恶作剧\nsmithereens 碎片\n\n复合名词的变化\nman 或 woman 做前缀，前后都要复数：man actor &#x3D;&gt; men actors\n两个名词，后面变复数：boy friend &#x3D;&gt; boy friends\n可数名词 + 介词（短语），前面名词复数：sister in law &#x3D;&gt; sisters in law\n动词&#x2F;过去分词 + 副词，加 s：stand by &#x3D;&gt; stand bys\n\n名词所有格TODO\n名词主谓一致TODO\n代词（pron.）\n\n\n\n\n\n\n\n\n代词的种类繁多，最重要的是要掌握用法，不用太拘泥于他们的分类以及语法术语\n代词就是用来代替名词的词。可以在句子中做主语、直接宾语、间接宾语、介词宾语\n人称代词指代人、地点、事物、想法，例如：\n\nI\nme\nshe\nwe\nus\nit\nyou\nthey\n\n物主代词表示名词的所有权关系，例如：\n\nMy\nour\nyour\nhis\nher\nits\ntheir\n\n反身代词反身代词用于指代句子的主语，以“-self”（单数）或“-selves”（复数结尾），例如：\n\nmyself\nyourself\nyourselves\nourselves\nhimself\nherself\nitself\nthemself\n\n指示代词指代已经提到的名词，如：\n\nthis\nthat\nthese\nthose\nsuch\nnone\nneither\n\n不定代词many; muchmany: 代替可数名词的复数\nmuch：代替、修饰不可数名词\n后接可数名词复数：a few（肯定意义）一些; few（否定意义）几乎没有\n后接不可数名词：a little（肯定意义）一些; little（否定意义）几乎没有\n例如：\n\na few carrots 一些胡萝卜\nfew carrots 很少（几个）胡萝卜\na little water 一点水\nlittle water 很少水\n\nsome; anysome：一些（一般用在肯定句中）\nany：一些（一般用在否定句、疑问句中）\n例如：\n\nThe rabbit needs some carrots.\nDoes the rabbit need any carrots?\nThe rabbit doesn’t need any carrots.\n\n如果需要对方正面肯定的回答时也会用 some，例如：\n\nWould you like some coffee?\n\n当 any 表示“任何一个”的时候，可以用在肯定句中，例如：\n\nThe rabbit can eat any carrot.\n兔子可以吃任何一个胡萝卜\n\neach; everyeach 和 every是“每”的意思，后接单数，例如：\n\neach carrot &#x2F; every carrot\n\neach 可以作代词，单独作主语，而每不可以单独作主语，需要后面 + 名词，例如：\n\nThere are many carrots. Each （✅） is big.\nThere are many carrots.Every（❌） is big.\n\neach 表示 2 个或 2 个以上，every 表示 3 个或 3 个以上，例如\n\nThere are many carrots on each side of the street.（✅）\nThere are many carrots on every side of the street.(❌)\n街道两旁有胡萝卜\n\neither; neithereither、neither做主语时：\neither: 两者中的每一个（谓语用单数）\nneither: 两者中每一个都不（谓语用单数）\n例如：\n\nGive the rabbit this or that carrot. Either is good.\n\n给兔子这个或那根胡萝卜，（两者中）哪一个都很好\n\nDon’t give the rabbit this or that carrot. Neither is good.\n\n不要给兔子这根或那根胡萝卜。（两者中）哪一个都不好\n\nEither of the carrots is good.\n\n（两个）胡萝卜哪一个都很好\n\n\nboth; allboth: 都；全部。both 是指两者都，例如：\n\nBoth of the two rabbits are cute.\n两只兔子都很可爱\n\nall: 都；全部。all 是指“三者及以上都”，例如：\n\nAll of the rabbits are cute.\n全部兔子都很可爱\n\nother; the other; anotherother: 另外的；其他的（+名词），例如：\n\nI like this carrot. I don’t like other carrot.\n\nthe other： 特指两者中的一个，例如：\n\nThis carrot is bigger than the other carrot.\n\nanother: 泛指 3 个或 3 个以上另一个，例如：\n\nThe rabbit doesn’t like this carrot. Give him another carrot.\n\none; it\nThe rabbit doesn’t like this carrot. Give him another one.\n\n复合不定代词\n\n\npron\n人\n物\n\n\n\nevery\neveryone&#x2F;everybody 每人；人人\neverything 每件事；一切事\n\n\nsome\nsomeone&#x2F;somebody 某人\nsomething 某事\n\n\nany\nanyone&#x2F;anybody 任何人\nanything 任何事\n\n\nno\nno one&#x2F;nobody 没人\nnothing 没有事\n\n\n形容词在修饰复合不定代词时要后缀，例如：\n\nThe rabbit has something important to do.\nThe rabbit has nothing important to do.\n\n疑问代词疑问代词用于发起提问，如：\n\nwho\nwhat\nwhich\nwhose\n\n例句：\n\nWhich video did you like the best?\nWhose bag is this?\n\n连接代词\n\n\n\n\n\n\n\n\n要理解连接代词必须先理解从句\n连接代词引导主语从句，宾语从句和表语从句\n连接代词有：\n\nwho\nwhom\nwhose\nwhat\nwhich\nwhoever\nwhomever\nwhatever\nwhichever\n\n“-ever”表示“任何，一切”的意思，起强调作用\n例句：\n\nI don’t know who you are.（who 引导宾语从句）\n\n我不知道你是谁\n\nWhat he said isn’t true.（what 引导主语从句，what 在此表示说话的内容）\n\n他说的话不是真的\n\nThe important thing is which rabbit is smarter.（which 引导表语从句）\n\n重要的是哪只兔子更聪明\n\nThe rabbit wants to eat whatever he likes.\n\n兔子想吃他喜欢的任何东西。\n\n\n关系代词关系代词专用于定语从句，共有六个：\n\nwho\nwhom\nwhose\nwhich\nthat\nas\n\n例句：\n\nThe rabbit who became hungry ate a carrot.\n饿了的兔子吃了根胡萝卜\nThe rabbit whom I saw ate a carrot.\n我看见的那只兔子吃了根胡萝卜\nThe rabbit whose ears are long ate a carrot.\n那只耳朵长的兔子吃了根胡萝卜\nThe rabbit ate the carrrot which &#x2F; that I bought.\n兔子吃了我买的胡萝卜\nThe rabbit ate the carrot, as was expected.\n兔子如预料的那样吃了胡萝卜\n\n介词（prep.）介词用法定语\nThe method of success.\n成功的方法\n\n状语\nShe lives in Vancouver.\n她住在温哥华\n\n表语\nIt is in the right screw.\n它是一个正确的螺丝\n\n宾补\nHe put the cellphone on the desk.\n他把手机放在桌子上\n\n同位语\nAs a doctor, he is responisble for his patient.\n他作为医生，他对他病人负责\n\n介词分类按结构分\n单个介词\nat\nin\nof\nafter\n\n\n合成介词\ninto\ninside\noutside\n\n\n分词介词\nincludeing\nconsidering\n\n\n短语介词\nin front of\nby way of\nat the end of\naccord of\n\n\n\n按词义分\n地点\n方向\n时间\n方式\n涉及\n目地\n原因\n比较\n伴随\n\n介词易混地点on、in、at\nat 某个具体位置、加小地点\nAt bus station\nAt No.12 avenue\n\n\nin 后面跟大地点\nIn Beijing.\n\n\non 表示在上面，后面加楼层\nOn the 1st floor.\n\n\n\n时间 on、in、at\nat 后面跟具体时刻，一天中的具体时间点，具体的周和节日\nAt midnight\n\n\non 后面跟具体的时间，某年某月某日星期几\nOn Monday September 2nd 2019.\n\n\nin 后面跟年、月、早晚、季节，一段时间，将来时中表示一段时间之后\nIn Spring.\nWe will meet in a few days.\n\n\n\n方位 on、in、to\nin 是 a 在 b 里面\nKunming lies in the southwest of China.\n\n\non 是 a 和 b 连着\nCanada lies on the north of American.\n\n\nto 是 a 和 b 不连着\nJapan lies to the east of China.\n\n\nto 表示方向\nto the south.\n\n\non 表示左右\non the left.\n\n\n\n时间 after、in\nafter + 具体时刻或者从句：表示在什么时刻之后，跟一般时态\nI was always playing football after school.\n我放学后总是踢足球\n\n\nin + 一段时间：表示在多久之后，跟将来时态\nWe will study math in a new semester.\n我们将在新学期学习数学\n\n\n\n时间 since、for\nsince + 具体时刻或者从句：自从什么时候起，一直到现在\nSince Ford died, that’s all changed.\n自从福特死了，这一切都变了\n\n\nfor + 一段时间：总共有多长之久\nThe school history for two hundred years.\n这学校历史长达 200 年\n\n\n\nin the front of、in front of\nin front of 表示在某物范围外的前面\nThere is a tree in front of the school.\n学校前面有一棵树\n\n\nin the front of 表示在某物范围内的前面\nWe sit in the front of the bus.\n我们坐在公交车的前面\n\n\n\nby、in、with\nby 乘坐交通工具、以什么方式\nI have to go by bus.\n我不得不坐公交车去\n\n\nin 使用某种语言文字\nHe has a speech in English today.\n他今天发表了一篇英文演讲\n\n\nwith 使用某种工具方法\nBlending with Light\n光合作用\n\n\n\nthrough、across、over\nthrough穿过、通过森林、人群、门等等\nIt passes through the Alataw Pass inhto Kazakhstan.\n它通过阿拉山口进入哈萨克斯坦\n\n\nacross和 over 跨越、跨越过河流、街道、围墙\nI run across the street.\n我跑过马路\nI climbed over the fence\n我翻阅围墙\n\n\n\nunder、below、beneath\nunder在…之下，表示某物接触或覆盖某物时\nWe finished the project in under a year.\n\n\nbelow 某物低于某物、或者表示温度用\nBelow freezing.\n冰点以下\n\n\nbeneath 在…之下（抽象概念），能力、地位、期望低\nThe game is beneath my expectations.\n这游戏低于我的预期\n\n\n\nin、into\nin 在…里面\nI walk in the school.\n我在学校里走\n\n\ninto 朝着…里面去\nI walked into the school.\n我走进了学校\n\n\n\n介词搭配\n介词+名词\nfor your car\n\n\n介词 + 代词\nwith her\n\n\n介词 + 动名词\nfor coming here\n\n\n介词 + 形容词\nfrom young to old\n\n\n介词 + 副词\nsince then\n\n\n介词 + 动词\nof winning\n\n\n介词 + 不定式\nto make him angry\n\n\n介词 + 从句\nat which I fell asleep was very boring.\n\n\n介词 + 数词\nover 100 people\n\n\n介词 + 介词\njust before us\n\n\n\n动词（v.）动词分类能做谓语实意动词vi.、vt.\n\n及物动词(vt.)，后面加宾语\nI hate you.\n\n\n不及物动词(vi.)，后面不加宾语\nI fly.\n\n\n及物+不及物动词（根据情况加宾语）\nI stop.(我停下)\nI stop working.(我停下工作)\n\n\n不及物动词没有被动句，因为它后面不能加宾语\n\n系动词引导表语或表语从句\n\nbe 动词\nam\nis\nare\n\n\n感官动词\nfeel\nlook\nsmell\nsound\nseem\n\n\n变化动词\nget\nbacome\nturn\ngrow\n\n\n保持动词\nkeep\nstay\nremain\nrest\n\n\n\n静态动词表示拥有、情感、思想的动词\n\n拥有\nhave\nown\nwant\ncontain\n\n\n情感\nlove\nhate\nwant\nneed\n\n\n思想\nknow\nthink\nunderstand\nbelieve\n\n\n\n动词短语TODO\n不能做谓语助动词协助主要动词构成谓语的词，没有实际意思，不能单独使用，构成时态、语态、否定句、强调句、疑问句\n\nhave 做助动词，构成完成时：\nI have turned off the light.\n我已经把灯关了\n\n\ndo 做助动词，构成疑问句、否定句、强调句\nDo you have kids?\n你有孩子吗？\nI do not know.\n我不知道\nDo come with you.\n一定要跟你去\n\n\nbe 动词做助动词，构成进行时或被动语态\nI am watching this video.\n我正在看这个视频\n\n\n\n情态动词情态动词有含义，和动词原型一起构成谓语\n\ncan&#x2F;could 表示推测、允许、能力\nYou can imagine the story is bad.\n你可以想象这个故事不好\nYou could have been hurt.\n你可能会受伤\n\n\nmay&#x2F;might 表示推测、允许、请求、祝愿\nIt may rain today.\n今天可能下雨\nI might be the next lucky dog.\n我可能是下一个幸运儿\n\n\nmust 表示肯定推测、命令\nIt must be her.\n这一定是她\nYou must choose.\n你必须选择\n\n\nshould&#x2F;shall&#x2F;ought to 表示推测、需要、征求意见\nYou should be careful.\n你要当心\nShall we regain the shore alive?\n我们能活着回到岸上吗？\n\n\nWould&#x2F;will 表示将要、请求、意愿\nWould you like to come with me?\n你要跟我一起来吗？\n\n\nbe able to 能够\nhave to 必须\nhad better 最好\n\n动词形式动词形式决定时态\n原形\n与助动词与情态动词一起构成谓语，要用原形\nDo you like English?\n你喜欢英语吗？\n\n\n祈使句的谓语动词，要用原形\nDon‘t move.\n别动\n\n\n感官动词的宾语与宾补构成逻辑上的主谓关系，表示动作的最后结果或全过程时，作宾补的动词要用原形\nI heard a coin drop.\n我听到一个硬币掉了下\n\n\n使役动词后的宾语与作宾补的动词构成逻辑上的主谓关系时，动词要用原形\nHe let Jack lead the way.\n他让杰克在前面带路\n\n\n两个以上的并列不定式用 and 或 or 连接起来，动词要用原形\nLet’s go and play football.\n我们去踢球\n\n\n在 why not…和 why…句型中，not 和 why 直接跟动词原形，构成反问，表示“建议、劝告、责备或提醒”等。\nWhy not use my bicycle?\n为什么不用我的自行车呢？\n\n\n动词 help 后是宾+宾补，其宾补由动词充当时，动词用原形\nI was helped to clean the room by her.\n她帮我打扫房间\n\n\n**do, does, did **与动词原形连用\nDo be careful!\n一定要当心！\n\n\n不定式作介词 but 和 except 的宾语，前面有实意动词 do 时，后面的动词不定式要省略 to\nJack had nothing to do but&#x2F;except watch TV.\n杰克除了看电视外无事可做\n\n\n固定的句型中，用原形\nhad better（最好）\nYou had better have a good rest.\n你最好好好休息一下\n\n\nwould rather(宁愿)\nI would rather study at home\n我宁愿在家学习\n\n\nwould rather … that … (宁愿…而不)\n\n\n\n第三人称单数一般现在时，主语是第三人称单数时，谓语要用第三人称单数第三人称单数：\n\n人称代词：he she it\n单个人名\n地名\n单数可数名词\n不可数名词\n\n例句：\n\nIt looks like a cat\nBeijing is in China\nThe cat is Lucy’s.\nThe water is very cold.\n\n动词变第三人称单数：\n\n直接在动词结尾加 s\n以 s、x、ch、sh、o 结尾加 es\n辅音字母加 y 结尾，y 变成 i 加 es\n不规则变化\nhave &#x3D;&gt; has\nbe &#x3D;&gt; is\n\n\n\n动名词和现在分词\n动名词起着名词的功能，常在句子中充当主语、定语、表语等成分\n现在分词来构成进行时态，与助动词 be 搭配构成句子的谓语，现在分词在句子中还可以充当定语、表语和状语\n\n\n词尾加 ing\nplay -&gt; playing\nworking\n\n\n词尾是 e 去掉 e 加 ing\nride -&gt; riding\n\n\n词尾是 ie 把 ie 变成 y 加 ing\ntie -&gt; tying\n\n\n辅音加元音加辅音双写辅音加 ing\nbeg -&gt; begging\n\n\n\n过去式和过去分词过去式单独做谓语，表示过去某个时间发生动作\n\n加 ed\nplay -&gt; played\n\n\ne 结尾加 d\nlove -&gt; loved\n\n\n\n过去分词是动词的非谓语形式，表示被动或完成\n\n\n\n动词\n过去式\n过去分词\n\n\n\narise\narose\narisen\n\n\nbe\nwas\nbeen\n\n\n\nwere\n\n\n\nbabysit\nbabysat\nbabysat\n\n\nbeat\nbeat\nbeaten\n\n\nbecome\nbacame\nbecome\n\n\nbend\nbent\nbent\n\n\n动词时态\n\n\n\n\n\n\n\n\n动词时态 &#x3D; 动作的时间 + 动作的状态\n使役动词副词（adv.）副词的主要目的就是更精确地描述，补充，修饰各类词性\n副词的用法副词修饰哪些词性\n修饰动词\nThis rabiit runs fast\n\n\n修饰形容词和副词\nThis is a very fast rabbit\nThis rabbit runs very fast.\n\n\n修饰名词\nThis rabiit here runs very fast.\n\n\n修饰句子\nObviously, this rabibit here runs very fast.\n\n\n\n副词在句子中作什么成分\n状语，定语\n表语(主语补语)\nThe worf is broad.\n\n\n宾语补语\nLet me in!\n\n\n\n副词的形式\n同拼写，同义、近义\nfast（快）\n\n\n同拼写，异义\npretty(漂亮，相当)\n\n\n副词 &#x3D; 形容词 + ly，同义、近义\nquick, quickly(快)\n\n\n副词 &#x3D; 形容词 + ly，异义\nlarge (大)\nlargely (基本上)\n\n\n\n副词的种类方式副词方式副词可以位于句首，句中，句尾，但不是所有方式副词都可以\n\nSuddenly, the driver turned left.\nThe driver suddenly turned left.\nThe driver turned left suddenly.\n\n程度副词程度副词一般位于它修饰的形容词或副词之前。\n\nThis is a very fast rabbit.\nThis cat runs very fast.\n\n地点副词地点副词一般出现在句尾；表强调时也可以位于句首\n\nThe rabbit eats carrots indoors &#x2F; outdoors.\n\n这兔子在室内、室外吃胡萝卜\n\nThe rabbit eats carrots upstairs &#x2F; downstairs.\n\n这兔子在楼上、楼下吃胡萝卜\n\nHere you can relax and forget about all your troubles.\n\n在这里你可以放松并忘记所有烦恼\n\n\n时间副词一般位于句尾：\n\nThe rabbit ate some carrots yesterday.\nThe rabbit is eating some carrots now.\nThe rabbit will eat some carrots later.\n\n也可放句首、或居中：\n\nThe rabbit has already eaten some  carrots.\n兔子已经吃了些胡萝卜\n\n频率副词大多数位于行为动词之前，be 动词、助动词、情态动词 之后\n\nThe rabbit eats carrots every day.\nSometimes, the …\nThe rabbit usually …\nThe rabbit eats carrots three times a day.\nI will always love you.\n\n疑问副词疑问副词是用来构成特殊疑问句的副词\n\n对方式提问\nHow does the rabbit eat carrots?\n\n\n对地点提问\nWhere does the rabbit eat carrots?\n\n\n对时间提问\nWhen does the rabbits eat carrots?\n\n\n对原因提问\nWhy does the rabbit eat carrots?\n\n\n\n连接副词引导名词性从句的副词\n\nHow the rabbit eats carrots is interesting.(How主语从句)\nI dont’s know where the rabbit eats carrots.（where引导宾语从句）\nThat is why the rabbit eats carrots.（why引导表语从句）\n\n关系副词引导形容词性从句（定语从句）\n\nThis was the place where the rabbit ate the carrot.\nThis is the reason why the rabbit ate the carrot.\nThat was the day when the rabbit ate the carrot for the first time.\n\n句子副词一般在句子的开头，用逗号和主句分开\n\nObviously, this rabbit here runs very fast.\n\n形容词（adj.）形容词的用法定语前置定语\na hungry rabbit\na little white rabbit\n\n顺序：限定词 + （主观）特征 + 尺寸 + 形状 + 新旧 + 颜色 + 来源 + 材料 + 用途例如：a beautiful big round new black Chinese wooden table中文：一张崭新的漂亮的黑色中式木质大圆桌\n后置定语比如，形容词修饰符合不定代词\n\nsomebody\nsomebody nice\n某个好人\n\n\nanybody\nanybody absent\n不在场的人\n\n\neverything\neverything possible\n所有可能的事儿\n\n\nnothing\nnothing wrong\n没不对的事儿\n\n\n\n形容词短语作定语一般，形容词短语会放在描述的对象之后，比如：\n\ncarrots good for the rabbit\n对兔子有好处的胡萝卜\nthe rabbit eager to eat carrots &#x3D;&gt; the rabbit tat is eager to eat carrots\n急于吃胡萝卜的兔子\nthe rabbit busy eating carrots &#x3D;&gt; the rabbit that is busy eating carrots\n忙着吃胡萝卜的兔子\n\n表语\nThe rabbit is alive &#x2F; asleep &#x2F; alone.\n兔子是活的&#x2F;睡着的&#x2F;孤单的\nthe only rabbit alive\n唯一一只活着的兔子\n\n补语\nCarrots make rabbits happy.\n胡萝卜让兔子开心。\n形容词 happy 补充说明了宾语 rabbit的状态，作宾语补语\n\n状语\nThe rabbit came home, tired and hungry.\n兔子回到家，又累又饿\ntired and hungry 表示兔子回到家时的状态，作状语\n\n形容词的构成简单形容词例如：\n\nhungry\nlittle\nwhite\n\n复合形容词现在分词和过去分词也可以做形容词形容词 + 形容词&#x2F;现在分词&#x2F;过去分词：\n\na red-hot coal\na good-looking rabbit\na new-born baby\n\n副词可以放在形容词前修饰形容词，副词 + 形容词&#x2F;现在分词&#x2F;过去分词：\n\nall-round\nhard-working\nrecently-built\n\n形容词&#x2F;数词 + 名词（需要+ed，与过去式无关）：\n\nwhite-haired &#x3D; … whose hair is white\n\n白发的\n\nkind-hearted &#x3D; … whose heart is kind\n\n好心的\n\na long-distance call\n\na one-way street\n\n\n名词 + 形容词&#x2F;现在分词&#x2F;过去分词：\n\na snow-white rabbit &#x3D; a rabbit that is white like snow\n\n一只雪白的兔子\n\na carrot-eating rabbit &#x3D; a rabbit that eats carrots.\n\n一只吃胡萝卜的兔子\n\na heart-broken rabbit &#x3D; a rabbit that heart is broken.\n\n一只心碎的兔子\n\n\n比较级&amp;最高级构成音节少的词，一般构成是形容词+er, est，有些需修改拼写以防误读音节多的词，一般构成是more, most + 形容词\n表达意义比较级通常表达“更….”、“越…越…”最高级一般表达“最”，但也可能是“非常”\n连词（conj.）并列连词连接有着“并列的，同等语法地位的”单词，词组或句子。\n并列关系\nThe cat is small and cute.\n\nBoth the rabbit and the wolf like carrots.\n\nThe rabbit not only teaches English but also makes videos.\n\nThe rabbit likes neither apples nor pears.\n\n兔子既不喜欢苹果也不喜欢梨子\n\nNeither the rabbit nor the wolf likes apples.\n\n兔子和狼都不喜欢苹果\n\n\n选择关系\nWhat does the rabbit like? Apples or carrots?\n\n兔子喜欢什么？苹果还是胡萝卜？\n\nEither the rabbit or the wolf is going to the party this evening.\n\n不是兔子就是狼会去要参加今晚的聚会\n\n\n表否定：\n\nThe rabbit neither ate nor slept yesterday.\n兔子昨天既没吃也没睡\nHurry up, or &#x2F; or else &#x2F; otherwise you’ll be late.\n快点，否则你要迟到了\nEither the rabbit or I am going to the party this evening. \n不是兔子就是我将要参加今晚的聚会\n\n转折关系\nThe rabbit cooked some carrots, but he didn’t eat any.\nThe rabbit cooked some carrots, yet he didn’t eat any.\nI haven’t eaten yet(adv.), yet(conj.) I’m not hungry\n\n因果关系\nThe rabbit is busy, so he won’t go to the party tonight.\n\n兔子很忙，所以今晚他不能参加聚会了（前因后果）\n\nThe rabbit is busy. Therefore, he won’t go to the party tonight.\n\n兔子很忙，所以今晚他不能参加聚会了（前因后果）\n\nThe rabbit will skip lunch, for he is busy making a video.\n\n兔子不吃午餐了，因为他在忙着做视频（前果后因）\n\n\n从属连词引导名词性从句that 当引导主语从句、宾语从句、表语从句和同位语从句时：\n\n只起连接作用\n在句子中没有实际的意义\n在宾语从句中可以省略。\n\n例句：\n\nThat the rabbit ate the carrot was obvious.\n\n兔子吃了胡萝卜，这很明显（主语从句）\n\nI saw (that) the rabbit ate the carrot.\n\n我看见兔子吃了胡萝卜（宾语从句）\n\nI don’t know if the rabbit ate the carrot.\n\n我不知道兔子是否吃了胡萝卜（宾语从句）\n\nThe fact is that the rabbit ate the carrot.\n\n事实是兔子吃了胡萝卜（表语从句）\n\nThe question whether the rabbit will eat the carrot is on all our minds.\n\n兔子是否会吃胡萝卜这个问题萦绕在我们心中（同位语从句）\n\n\n引导状语从句引导时间状语从句的连词：\n\nwhen 当…时候\nwhile 当…时候\nas 当…时候\nbefore 在…之前\nafter 在…之后\nuntil 直到…为止\nsince 自…以来\n\n引导地点状语从句的连词：\n\nwhere 在…地方\nwherever 无论在…地方\n\n引导比较状语从句的连词：\n\nthan 比\nas 与…一样…(出现在as…as…结构中)\n\n引导条件状语从句的连词：\n\nif 如果\nunless 除非\n\n引导让步状语从句的连词：\n\nalthough 虽然；尽管（不与并列连词but连用）\nthough 虽然；尽管（不与并列连词but连用）\neven though 即使\neven if 即使\nwhile 虽然；尽管\n\n引导方式状语从句的连词：\n\nas 像…；与…一样\nas if 好像\nas though 好像\n\n引导原因状语从句的连词：\n\nbecause 因为（从属连词；不与并列连词so连用）\nsince 因为（表示间接、附带原因，语气弱于 because）\nas 因为（语气最弱）\n\n引导目的状语从句的连词：\n\nin order that 目的是…;为了 …\nso that 以便\nso 以便\n\n引导结果状语从句的连词：\n\nso…that… 太…以至于…（注意与 so that 区分）\nsuch..that… 太…以至于…\nso 因此；所以\n\n感叹词（int.）\n\n\n\n\n\n\n\n\n负责表达情感的声音，单词，词组\n具体可见视频：https://www.bilibili.com/video/BV1XY411J7aG?p=20&vd_source&#x3D;0102e1b36cb805c77386e59559a89b2c\n从句名词性从句主语从句用一个句子代替句子里的一个名词，做句子主语\n宾语从句表语从句同位语从句定语从句（形容词从句）思维方式The rabbit is eating a carrot.\n构成限定性和非限定性翻译技巧https://www.bilibili.com/video/BV1ov411r7L6Q：什么是定语？A：中文翻译为 xxx 的词（定语就是形容词）\nQ：什么是定语从句？A：连词+句子，作形容词修饰名词\n定语从句的位置问题中文里面，定语在名词前面（eg.漂亮的女孩）英语里面，定语：\n\n单个词的，一般放名词前，除了：\n不形：不定代词+形容词\na 形：something important a boy asleep. \n过去分词（前后都行）\n\n\n从句，后置\n\n翻译题做题步骤先拆分句子！\n\n连词处（从句）\n介词处（作定语或状语）\n非谓语（作定语或状语）\n标点符号\n\n练习例句：\n\nWe are obliged to them because some of these languages have since vanished, as the peoples who spoke them died out or became assimilated and lost their native languages.\nThere will be television chat shows hosted by robots, and cars with pollution monitors that will disable them when they offend.\n\n连词前是动词、介词 -&gt; 宾语从句连词前是名词 -&gt; 定语从句\n! 如果英文中有被动，翻译成中文要变成主动\n状语从句(副词从句)参考资料\nhttps://www.bilibili.com/video/BV1Z4411C7jG\nhttps://www.bilibili.com/video/BV1XY411J7aG\nhttps://wordvice.cn/topic/category/language-rules\n\n","slug":"English/英语语法","date":"2022-07-15T11:33:06.000Z","categories_index":"英语","tags_index":"英语,笔记","author_index":"Honman"},{"id":"377acfb2c7ae144090a23e072d60353b","title":"CET4笔记","content":"作文模板 Acknowledgements: Joshlee议论文（essay）\n\n\n\n\n\n\n\n\n三个段落（ 10-11 句）\n第一段（2-3 句）\n前 1-2 句提出你的问题（你对这个问题的看法是什么，好还是不好，应不应该这样做）\n第 3 句过渡句\n\n现象解释\n\n\n\n\n\n\n\n\nKeyword: Why, what\n第一句：With the rapid development of ( society &#x2F; economy &#x2F; education &#x2F; technology &#x2F; culture &#x2F; medical service ), it is of great necessity for （youngsters &#x2F; students &#x2F; residents &#x2F; citizens） to _____.\n第二句（提出问题）：\n\nIt’s quite natural for us to ponder over the question ( of &#x2F; that ) _____.\n我们很自然地会想到___ 这一问题\n\n观点选择\n\n\n\n\n\n\n\n\nKeyword: option choice\nNowadays (youngsters &#x2F; students) have different options upon graduation. Some thinks that (  ) is beneficial, while others think (  ) is a better choice. (列举选择) Personally, I prefer the ( former &#x2F; latter ). The following reasons can account for my preference.\n问题解决\n\n\n\n\n\n\n\n\nKeyword: How to, solution, measure\nIn contemporary world, (  ) （现象）. I am convinced that it is of great necessity for ( 某人 ) to ( do sth ) . (观点) How to address this problem? The following solutions can account for this issue. (过渡句)\n图画\n\n\n\n\n\n\n\n\nkeyword: image, cartoon , diagram , chart\nAs is starkly mirrored ( reflected ) in the image &#x2F; chart that （一句话描述图片）it is revealed that ___ (图片内涵) . The following reasons can account for this issue. (过渡句)\n谚语As an old saying goes: _____ . For us college students, it has an increasingly important significance: ( )解释含义___ . The following reasons can account for this issue. \n第二段（6 句）通用\n3 个论点\n3 个论据\n\n第一句（论点 1）：First and formost, there is no doubt that __________ .\n首先毫无疑问的是，__________.\n第二句（论据 1）：Based on big data, a majority of ( successful social elites ) admitted that they have spent 2&#x2F;3 of their time in (doing sth).\n基于大数据，大部分成功的社会精英承认，他们花了三分之二的时间做某件事\n例：基于大数据，大部分成功的学生们花了三分之二的时间练习口语\n第三句（论点 2）：Furthermore, it is obvious that  ____.\n其次，很明显的是_______.\n例：Furthermore, it is obvious that it is beneficial for students to make foreign friends.\n第四句（论据 2）Where these is&#x2F;are _____ ,  there is&#x2F;are _____ .\n有____ ，就有_____\n例：\n\nWhere there is a will, there is a way. 有志者，事竟成\nWhere there are foreign fridends, there is communication, therefore our speaking ability can be improved. 有外国朋友，就有交流\n\n第五句（论点 3）Last but not least, no one can deny that ____.\n最后，没有人可以否定 _____.\n第六句（论据 3）Although ____ , ____.\n尽管 ____ ，但是 ____ ,\n第三段（2 句）通用\n第一句：重申观点\n万能结尾（提出期望）\n\nIn a word, the whole society should pay close attention to the problem of (    ) . Only in this way can we have a bright and promising future.\n总之，全社会都应该关注（ ）问题，只有这样，我们才能有一个光明和充满希望的未来。\n应用文信件（Letter）通知（notice）报道（report）广告（advertisement）练习观点选择练习：2016 年下半年题目：Suppose you have two options upon graduation: one is to find a job somewhere and the other is to start a business of your own, you are to make a choice, write an essay to explain the reason.\n现象解释问题解决图片图表练习：2021 下半年四级作文题目：\nDirections：For this part，you are allowed 30 minutes to write a short essay .You should start your essay with a brief (简短) description of the picture and then express your views on protecting the forests.You should write at least 120 words but no more than 180 words\n练习：\nAt is starkly reflected in the image, a hunter was holding a gun towards a bear. it is revealed that we should protect wild animals. The following solutions can account for this issue.\nFirst and formost, there is no doubt that animals are our friends. Based on big data, a majority of successful social elites have admitted they share a harmonious relationships with animals.Further more, it is obvious that killing is cruel. where there is no buying, there is no killing. Last but not least, no one can deny that there are benefits on genes of wild life.  Though we can’t take advantage of them all for now, the potentials will buried if we kill them all.\nIn a word, the whole society should pay close attention to the problem of animal protection. Only in this way can we have a bright and promising future.\n高频单词\n\n\n\n\n\n\n\n\n以下高频词出自 https://www.bilibili.com/video/BV17w411Z7Wz ，配合浏览器插件 Relingo 食用。每天快速地把所有单词过 2-3 遍。\n\nconsumer\nsocial\nproduct\nlikely\nsystem\nactivity\nreward\nstress*\nexpert*\nconcern*\nuniversity\nindividual*\nview\nopportunity*\nhunt\nchallenge\nprocess\nproject\namount\nability\nrate\nradiation*\nfeature\nenvironment\ncreate\ncrash\nadvertise*\ntend*\nstatus\nreader\nper\nlocal\nhighway\nbrand*\nassume*\nphysical*\ninstant*\nfocus\nfashion\nexpand\neffective\ndeclare\nbenefit*\nadult*\naffect\ncompete\nglobal\npolicy\naccount\nfoundation*\ninvolve*\ntechnology\ncompetition\nbehavior\ncommunity\nrange\nmaintain\naction\nobvious*\nprimarily\nappeal*\ndetail\ndecade\npollution\nadvantage*\nculture*\nautobiography*\nleader\naccordingly*\nplastic*\napprove*\nperformance\nrecognize*\nfactor*\nenormous*\navoid*\nshift\nsource\nfulfill*\nmoral*\nrank\nreplace\ncomplex\ninjury*\noutcome\ninsurance*\nimpression*\nhousehold*\nclaim*\npersonality*\npersonnel*\nemployee\nreserve\napproach*\ncapacity*\ngenerally*\nautomobile\nmale\nregardless*\ncontact\nwealthy*\nestimate*\nincident*\ndevice\nerror\nrelationship\nrecently\nscale\nunion\nclimate*\navaliable\ncriticism*\ndiet*\ncivilian*\nground\nliberal*\nestablish*\nindicate\naccomplish\nfinally\nspot*\npotential*\nprofessional*\nideal\nreflect\nconsiderable*\ninfluence\ntrace\nattitude\nchemical\nnetwork\npositive\nterritory*\nengage*\nwitness*\nwelfare*\ncareer\nattach*\nprofit\nmusician\npurchase\ncompetitive\nparticularly*\nassign\nresponse\npace*\ncomplaint\nidentify\narise\nvictim*\nsample\nmodify\nproperty\nstructure\ntarget\nbelief\nminority*\nresistant*\ntheory*\nsignal*\nbloom*\ncheat\ninstance\ntransfer\nthreaten*\nabroad\naudience\nscan\ncorporation\nthreat*\ngas*\npromote\nindustrial*\nstyle\ngrant\napply\nextend\ninstall\nimpact\nfunction\nuser\npropose*\nalter\nagency*\ncontribute\neducate\nabsent*\npoison*\nairline\npossibility\nflash\nnuclear*\nnucleus*\nraw\nextensive\nmilitary*\ndirectly\ndeny\nabsorb*\ncommittee\ncomplain*\naid\nprotein*\nstatement\ninstitution*\nroute\nassociate*\ngrowth\nconvince*\nliberate*\ncell\npublish\nyoungster\nfailure\nfaint*\nrob*\nresident*\nfund*\nappearance\nportable\nefficient\npreference\nsolution\nconfidence*\ntreatment*\nadopt*\nskilled\ncultivate*\nrespond\nvary*\nexit\nsurvey*\nlest*\nvehicle\nconstant\nspeaker\natmosphere*\nlatter\nreform*\neconomy*\nprimary\ndiffer\ncapable\ndistinct*\ndefine\nresist*\nargument\ntransform\ndespite*\nstrengthen*\ndistinguish*\nemotional\ndata\nachievement*\nstrategy*\nsufficient*\nban\npoverty*\nwage*\nwisdom*\nassemble*\npredict\naccurate*\nadapt*\nrisk*\nliquid*\nthunder*\nvirtue*\nfemale\nrecommend\nequality\neconomic*\neconomics*\nemit\nbar\narrange*\nconference*\nimprovement*\nprevious\nsensible*\nexchange\nconsumption*\nintelligence*\ndebate*\ncriticize*\nrail*\nreveal\nspray*\ninvestment*\nreinforce*\ncope*\nexceed*\nconfuse*\naware*\nsuperior\nemphasize\nregion\npop\nintensity*\nappreciate*\ncolleague*\ntransportation\neveryday\nfame*\nfamiliar*\nurban*\nspan\nessential*\ninhabitant*\nweapon\naccumulate*\neliminate*\nremarkable*\nremedy*\nmislead*\nwhale*\ncliff*\ndiscard*\naspect*\nshortage\nmobile\ncrime*\nrelax\nfleet*\ndisplay\nmask*\nreverse\nsecurity\nemphasis*\nlucky\nsignificant*\naircraft*\ncease*\ntransmit\ngasoline*\nconduct*\nabandon\nstimulate*\nbind\npressure*\ncharacterize*\ncycle\nenable\ncraft*\nconsist*\nvital*\npowerful\nnavy*\nauthority\nshrink*\nrid\nsurround*\nalike*\narouse*\nexcessive*\ndispute*\nbehave\nelectrical\nhighly\nselect\ncontrast\ninfant\nathlete*\noverseas*\nelevator*\napart\nreality*\ncommitment*\ngaze*\ntough*\nexpense\nsensitive*\nanxiety*\nevidence*\nimage\njournal\ndelivery\ncommit\nadvertisement*\ncoordinate*\nurgent*\ntalent*\npeculiar*\nhandle\nhandsome\nrepresent\nexception\nspecific*\nbalance\nindoor\nrelease\nincreasingly\nreputation*\nforbid*\ninspire*\nusage\ndistress*\ncommunicate*\nappoint*\nreaction\nsalad\ninternal\nprior*\ngenerous*\nfundamental*\nversion\nappointment*\ndefinite*\ncabinet*\naluminum*\nalways\nitem\ncode\nprosperity*\nresponsibility*\nanalyze\ninterfere\ngenerate\nequip\nworldwide\nmission*\nspecialize*\nemployment\nswitch\nobserve*\nnegative\ninvention*\nhumor*\ninferior*\ntypical\ncommand\nconfirm\nintelligent\nlabel\npigeon*\nancient*\nslight*\ndomestic*\nvacant*\nconvert\nforth\nrelate\ndisturb*\nengine\nslice*\nnavigation\nelectronic\nelectronics\nparliament*\nnecessarily\nemerge*\nnumerous\ngenuine*\nconstruct\nannoy*\ncharacter\nstrain*\nobtain\nnecessity\nproportion*\nloyalty*\nlubricate*\ninsert\nviolence\nnaturally\nexport\ntender*\nabsence*\nclassify*\nmood*\ncrisis*\ncomprehension*\ndiscipline*\ntax\ninfluential*\ninform*\noriginal*\nmanagement\nreluctant*\nhousewife\nexpose*\nentitle*\nenvy*\ntendency*\ncommission\nregister\nmedia\ncounty*\nreproduce\nneighborhood*\ndisposal*\ncuriosity*\npassive*\ngap\ndump\nrarely*\nsuggestion\nlocate\ninteraction*\nundoubtedly\nsomewhat*\nsum\nrack*\ntransmission*\nexternal\ncrack*\nconvenience*\nadequate*\nvolunteer*\nphenomenon*\ncomparison*\ntypewriter\nchannel\nsophisticated*\nconclude*\nsection\nparticipate*\ndepression*\nqueue\nvice*\nlaunch\nmanner*\nexhaust*\nundertake*\nmotivate*\nproposal*\ntremendous*\nperspective*\naggressive*\nacademic*\nlag*\napplication\ndistribute*\ncontrary*\ncomprise*\nelement\nunlike\nmostly*\nmotel*\nbackground\nvisual\nrefine*\nresponsible*\npetroleum*\nlegal*\ncivilization*\npump*\nquote*\noutward*\ndecrease\nfatal*\naccuse*\naccustomed*\nobjective*\nconservation*\noptical*\ndelicate*\nmechanic*\nmechanics*\nscholarship*\ncarpenter*\nfluent*\nswallow*\nepisode*\nattraction*\norbit*\nmixture\nscreen\nadministration\nabuse*\nomit*\naccommodation*\nacceptance*\nconflict*\nsoda\nscheme\nconservative*\nattribute\nleisure*\nretire\nmere*\ncomment\nsalary\npreserve*\noverall*\nensure\nimpose*\nunfortunately*\nevolution*\naccess\nidentical*\njoint*\nintention*\nfee\ndebt\nadvisable*\nsequence\ncourt*\nintroduction\ncompetent*\nfederal*\ntemper*\npercentage*\nconsiderate*\nillegal\nlargely*\nintellectual\nsenior*\nmature*\ninterval\ngrasp*\noutput\ndrum*\ncautious*\nrude*\nelect*\nstir*\ninsight*\ndurable*\nhorizontal*\nhorn*\nphilosophy*\nappropriate*\nfaulty*\ngenius*\ndownward*\nexecutive*\nsurplus*\nlibrarian*\nstretch*\nhandy*\ndeliberate*\ncapture*\nphrase*\nalternative*\naward\nincline*\ncancer*\ncollection\nglimpse*\ndemonstrate*\nskim*\ninstruct*\nconstitution*\nmanufacture*\ndrama*\nrelief*\nagent\ntrail*\nconnection\nmill*\ncommander*\nhandful*\nmedium*\nleadership\ncreature*\ninstrument*\nsubstitute*\nchin*\nsteady*\nspecialist*\nadjust*\nenforce*\norgan*\ngrocer*\ncreep*\ncooperate*\nsympathetic*\nstorage\ndepart*\nrender*\nprivilege*\nteenager*\ncontribution\nfeedback*\nacquisition*\nexistence*\nexplore\nwax*\nmess*\nprince*\ngenerator*\nfatigue*\naccompany*\nrural*\nhoney\nattain*\nbillion\nuncover*\nlocomotive*\ntrap*\nassociation*\nspite*\ninterview\npessimistic*\nbark*\ndevil*\nuniverse*\nreduction*\npsychological*\ninvade*\nidentity*\npermanent*\nscrew*\ninterpretation*\neditor\nguarantee*\nclassic*\npose*\ndelegate*\nartificial*\ncassette*\nromantic*\nannual*\napartment*\ndeposit*\nfantasy*\nmud*\nauthor\nassure*\ncorrespond*\noutlet*\ntopic\nrival*\ninitiative*\nslide*\nextreme\nmisunderstand\nevident*\ncasual*\nroutine*\ntrumpet*\nancestor*\nstaff*\nnotion*\ncounter\nfabric*\noccasion*\nlump*\nhopeless*\ndocument\nprecaution*\nintend*\ncash*\nhardware\ntidy\nresolve\nprotective*\nquit\nsevere*\nextension\ntrial*\nexpectation\ntelescope*\npassport\nexploit*\ndemocracy*\nrequirement\nfile\nneglect*\nexaggerate*\nthirst*\novernight*\nplot\nestate*\nliter*\nvariation*\ncopper*\ndevise*\nprinciple*\nsportsman*\ncreative\nformer*\nunity*\nsimilarly*\nassumption*\nreception*\n\nEnding","slug":"English/CET4笔记","date":"2022-05-25T09:59:41.000Z","categories_index":"英语","tags_index":"英语,笔记","author_index":"Honman"},{"id":"212ace37ed6016bdbeaf8c136445f0e5","title":"Chrome 浏览器常用快捷键","content":"Chrome 浏览器常用快捷键Mac 上的 Chrome 快捷键\n导航\n打开新标签页：Command + T\n关闭当前标签页：Command + W\n切换到下一个标签页：Control + Tab\n切换到上一个标签页：Control + Shift + Tab\n切换到特定的标签页：Command + 数字键（例如，Command + 1 切换到第一个标签页）\n重新加载当前页面：Command + R\n停止加载页面：Command + .\n\n\n标签页操作\n在新标签页中打开链接：Command + 点击链接\n在后台打开链接：Command + 点击链接\n关闭当前窗口：Command + Shift + W\n最小化窗口：Command + M\n全屏模式切换：Control + Command + F\n\n\n查找和搜索\n在页面中查找：Command + F\n查找下一个匹配项：Command + G\n查找上一个匹配项：Command + Shift + G\n在新标签页中进行搜索：Command + L，然后输入搜索关键词，按 Enter 键\n\n\n开发者工具\n打开开发者工具：Option + Command + I\n打开开发者工具的控制台面板：Option + Command + J\n切换到下一个面板：Control + ]\n切换到上一个面板：Control + [\n\n\n其他操作\n打开历史记录：Command + Y\n打开书签栏：Command + Shift + B\n打开下载页面：Command + Shift + J\n\nWindows 上的 Chrome 快捷键\n导航\n打开新标签页：Ctrl + T\n关闭当前标签页：Ctrl + W\n切换到下一个标签页：Ctrl + Tab\n切换到上一个标签页：Ctrl + Shift + Tab\n切换到特定的标签页：Ctrl + 数字键（例如，Ctrl + 1 切换到第一个标签页）\n重新加载当前页面：Ctrl + R\n停止加载页面：Esc\n\n\n标签页操作\n在新标签页中打开链接：Ctrl + 点击链接\n在后台打开链接：Ctrl + 点击链接\n关闭当前窗口：Ctrl + Shift + W\n最小化窗口：Alt + Space, N\n全屏模式切换：F11\n\n\n查找和搜索\n在页面中查找：Ctrl + F\n查找下一个匹配项：Ctrl + G\n查找上一个匹配项：Ctrl + Shift + G\n在新标签页中进行搜索：Ctrl + L，然后输入搜索关键词，按 Enter 键\n\n\n开发者工具\n打开开发者工具：Ctrl + Shift + I\n打开开发者工具的控制台面板：Ctrl + Shift + J\n切换到下一个面板：Ctrl + ]\n切换到上一个面板：Ctrl + [\n\n\n其他操作\n打开历史记录：Ctrl + H\n打开书签栏：Ctrl + Shift + B\n打开下载页面：Ctrl + J\n\n","slug":"快捷键/Chrome 浏览器常用快捷键","date":"2019-08-24T00:30:00.000Z","categories_index":"计算机,快捷键","tags_index":"笔记,快捷键","author_index":"Honman"}]